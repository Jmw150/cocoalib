      JBMill
      Copyright (c)  2014-2015  John Abbott,  Anna M. Bigatti   (orig authors: Pierre Pytlik, Mario Albert)
      GNU Free Documentation License, Version 1.2
%!includeconf: ../aux-txt2tags/config.t2t
      TeXTitle{PBMill}{Mario Albert}


== Examples ==[examples]
%----------------------------------------------------------------------
- [ex-Pommaret1.C ../../examples/index.html#ex-Pommaret1.C]
- [ex-Pommaret2.C ../../examples/index.html#ex-Pommaret2.C]

== User documentation for PBMill ==
%======================================================================

The files ``PBMill.H``, ``StabilityAlgorithm.H`` introduce several classes for computing and working with **Pommaret Basis**.
The normal user should only use the classes ``Involutive::PBMill`` and ``Involutive::PBMill::Builder`` to interact with Pommaret bases.


=== Computing a Pommaret Basis ===
%----------------------------------------------------------------------

To compute a Pommaret basis the user should use subclasses of ``Involutive::PBMill::Builder``.
The user can choose between four subclasses:
- ``Converter`` -- It takes a Janet basis and casts it to a Pommaret basis. This builder object does not perform a coordinate transformation.
- ``DeltaRegularTransformator`` -- It takes a generating set and transforms it to a delta-regular Pommaret basis via coordinate transformations.
- ``StableLTITransformator`` -- It takes a generating set and transforms it to a Pommaret basis via coordinate transformations, such that the leading ideal is stable.
- ``StronglyStableLTITransformator`` -- It takes a generating set and transforms it to a  Pommaret basis via coordinate transformations, such that the leading ideal is strongly stable.

==== Using Involutive::PBMill::Converter ====

To construct a ``Involutive::PBMill::Converter`` object the user has to use the standard constructor.
The only configuration method is ``setJBMill(mill)`` where ``mill`` is a ``JBMill``.
It sets the ``JBMill`` which should be transformed to a ``PBMill``.
If ``builder`` is a configured ``Converter`` object the user can construct a new ``PBMill`` with ``PBMill(builder)``.

==== Using Involutive::PBMill::DeltaRegularTransformator ====

To construct a ``Involutive::PBMill::DeltaRegularTransformator`` object the user has to use the standard constructor.
For configuration of the building process there are several methods:

- ``setInput(v)`` -- ``v`` must be a ``vector<RingElem>``. It sets the generating set of the ideal to ``v``.
- ``setInput(cBegin, cEnd)`` -- ``cBegin`` and ``cEnd`` must be a ``vector<RingElem>::const_iterator`` and must define a range of ``RingElem``. The method sets the generating set of the ideal to this range.
- ``setJanetStrategy(strat)`` -- ``strat`` must be a ``Involutive::StrategyFlag``. Possible enums are ``TQDegree``, ``TQBlockHigh``, ``TQBlockLow`` (default) or ``GBCompletion``. During the computation we compute Janet bases. This Flag controls which algorithm should be used to compute these Janet bases.
- ``setStrategy(strat)`` -- ``strat`` must be a ``Involutive::DeltaRegularTransformator::StrategyFlag``. Possible enums are ``SingleWithPermutation``, ``SingleWithoutPermutation``, ``AllWithPermutation`` and ``AllWithoutPermutation``. It defines the algorithm which should be used to compute delta-regular coordinates. If this method is not called the Builder object uses the ``SingleWithoutPermutation`` strategy.

If ``builder`` is a configured ``DeltaRegularTransformator`` object the user can construct a new ``PBMill`` with ``PBMill(builder)``.
The computation of delta-regular coordinates will be done during the construction of ``PBMill``.

==== Using Involutive::PBMill::StableLTITransformator and Involutive::PBMill::StronglyStableLTITransformator====

The construction and usage of ``StableLTITransformator`` and ``StronglyStableLTITransformator`` is nearly the same than for the ``DeltaRegularTransformator``. The only difference is the method ``setStrategy(strat)``. There are only two possible enums of type ``StableLTITransformator`` (or ``StronglyStableLTITransformator``): ``Single`` (default) or ``All``.

The methods are chainable, e.g. the user can do the following: ``builder.setInput(input).setStrategy(Single)``. If the user calls a method more than one time only the input of the last method call is taken into account.

=== Using the PBMill ===
%----------------------------------------------------------------------

In addition to the methods of the baseclass ``JBMill`` the class ``PBMill`` defines the following methods. Let I be the ideal generated by the Pommaret basis:

- ``myReturnPB()`` -- returns the minimal Pommaret basis as ``vector<RingElem>``
- ``myDepth()`` -- returns the depth of I as ``long``.
- ``myProjDim()`` -- returns the projective dimension of I as ``long``.
- ``mySocle()`` -- returns the socle of I as ``vector<RingElem>``.
- ``myExtremalBettiNumbers()`` -- returns the extremal betti numbers of I as ``map<pair<long, long>, long>``.
- ``myMaxStronglyIndependentSet()`` -- returns the unique maximal strongly independent set of P/I as ``vector<RingElem>``.
- ``IamCohenMacaulay()`` -- tests if I is Cohen-Macaulay. Returns a ``bool``.
- ``myRegularity()`` -- returns the regularity of I as ``long``.
- ``mySatiety()`` -- returns the satiety of I as ``long``.
- ``mySaturation()`` -- returns the saturation of I as ``vector<RingElem>``.



== Maintainer documentation for PBMill and StabilityAlgorithm ==
%======================================================================

The Pommaret basis is always a Janet basis, too. Therefore the datastructures for represententing a Pommaret basis are the same than for the Janet bases. Everything of the following lives in the namespace ``CoCoA::Involutive``.

===PBMill===

This file defines all necessary things for dealing with Pommaret bases.
====PBMill====

This class has as base class ``JBMill``. It does not introduce new data members, because the representation of a Pommaret basis is the same than for a Janet basis. The main differnce between these to classes is that ``PBMill`` only accept generating sets in delta-regular coordinates. In addition to that it implements some methods which are only appliccable when we have a Pommaret basis.

====PBMill::Builder====

This class is designed to construct a Pommaret basis.
The goal of this class is to separate the construction of the ``PBMill`` from its representation.
The 'Gang of Four' (Gamma, Helm, Johnson, Vlissides - Design Patterns) served
as template for the construction.
The corresponding pattern is called Building Pattern.
This class is purley virtual. The real implementation is in the subclasses.
To construct a ``PBMill`` out of the builder object the user can call a constructor of ``PBMill`` with a configured builder object.

====PBMill::Converter====
This class is a subclass of ``PBMill::Builder``. It trys convert a ``JBMill`` direclty to a ``PBMill``, without changing coordinates.

====PBMill::Transformator====
This class is a subclass of ``PBMill::Builder``. It is again a purley virtual class. It acts as base class for all Builder-classes which applying coordinate transformations to get a specific stability position.

====PBMill::DeltaRegularTransformator====
This class is a subclass of ``PBMill::Transformator``. It transforms a Janet basis to a Pommaret basis with delta-regular coordinates. The user can choose between four different strategies which are definied in the enum ``PBMill::DeltaRegularTransformator::StrategyFlag``.

====PBMill::StableLTITransformator====
This class is a subclass of ``PBMill::Transformator``. It transforms a Janet basis to a Pommaret basis with stable leading ideal. The user can choose between two different strategies which are definied in the enum ``PBMill::StableLTITransformator::StrategyFlag``.

====PBMill::StronglyStableLTITransformator====
This class is a subclass of ``PBMill::Transformator``. It transforms a Janet basis to a Pommaret basis with strongly stable leading ideal. The user can choose between two different strategies which are definied in the enum ``PBMill::StronglyStableLTITransformator::StrategyFlag``.

===StabilityAlgorithm===

==== StabilityAlgorithm ====

This class provides an interface for computing different stability positions.
It defines a method to compute a Janet basis (which is in our case always a Pommaret basis as well)for a given input, and a method to get a JanetContainer which should contain the computed Janet basis.
Also it contains as basic data the polynomial ring and the PPMonoid.
Every class which computes a stability position has to be a subclass of this class.

==== DeltaRegular ====

This class is a subclass of ``StabilityAlgorithm``. It should transform the given ideal into delta-regular coordinates. The algorithm to compute delta-regular coordinates is quite simple. It checks if the given input is delta-regular. If not it changes the coordinates (only changes from x_i to x_i+x_j) and checks it again, until it reaches delta-regular coordinates. In addition to that it there is an ``enum DeltaRegular::UsagePermutations``, where the user can decide whether we also use variable permutations as transformation. The computation of transformations like x_i -> x_i + x_j is implemented in the method ``DoComputeImage`` which is virtual.

==== DeltaRegularAll ====

This class is a subclass of ``DeltaRegular``. The implementation is almost the same than ``DeltaRegular``. The only difference is the method ``DoComputeImage``. This class also computes transformation like x_i -> x_i + x_j_1 + ... + x_j_s.

==== StableLTI ====

This class is a subclass of ``StabilityAlgorithm``. It should transform the given ideal into coordinates, such that the leading ideal is stable. The algorithm to compute this coordinates is quite simple. It checks if the given input are in the correct position. If not it changes the coordinates (only changes from x_i to x_i+x_j) and checks it again, until it reaches suitable coordinates. The computation of transformations like x_i -> x_i + x_j is implemented in the method ``DoComputeImage`` which is virtual. In addition to that the check if the position is correct is again a virtual method.

==== StableLTIAll ====
This class is a subclass of ``StableLTI``. The implementation is almost the same than ``StableLTI``. The only difference is the method ``DoComputeImage``. This class also computes transformation like x_i -> x_i + x_j_1 + ... + x_j_s.

==== StronglyStableLTI ====
This class is a subclass of ``StableLTI``. It should transform the given ideal into coordinates, such that the leading ideal is strongly stable.
The implementation is almost the same than ``StableLTI``. The only difference is the check of coordinates. It replaces the check of stability by a check of strong stability.

==== StronlyStableLTIAll ====
This class is a subclass of ``StronglyStableLTI``. The implementation is almost the same than ``StronglyStableLTI``. The only difference is the method ``DoComputeImage``. This class also computes transformation like x_i -> x_i + x_j_1 + ... + x_j_s.

====Problems&Ideas related to StabilityAlgorithm====
If we could make ``StableLTI`` to a subclass of ``DeltaRegular`` it would be quite nice, because this would represent the mathematical hierachy as well.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

