<html>
<head>  <title>Examples</title>  </head>

<body>
<h1 align=center>CoCoALib Examples</h1>

The programs in this directory form part of the documentation of CoCoALib.
They are self-explanatory and illustrative; they should be <i>read</i> (rather than
merely compiled and run).  Each one concentrates on certain features of CoCoALib.

<h3>Where to start</h3>

If you are completely new to the CoCoA Library then you should start
by looking at these examples which are the simplest and give an idea
of the "philosophy" behind the CoCoA Library:
<pre>
  ex-ring1.C
  ex-RingQQ1.C
  ex-RingElem1.C
</pre>

To compile all the example programs, just issue the command
<pre>
  make
</pre>
from inside this directory; or the command <tt>make examples</tt> from the COCOA_ROOT directory.

<p>
You can compile just one example (say <tt>ex-ring1</tt>) by executing:
<pre>
  make ex-ring1
</pre>


<h3>Writing Your Own Programs</h3>

An easy way to create your own program using CoCoALib is the following
<ul>
  <li>copy <tt>ex-empty.C</tt> into another file, say <tt>prog.C</tt></li>
  <li> write your code inside the procedure <tt>program</tt> in this copy</li>
  <li> compile your program with the command <tt>make prog</tt></li>
  <li> run your program with the command <tt>./prog</tt></li>
</ul>

<h2>Short Descriptions of the Example Programs</h2>

<table>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-00-intro.C" name="ex-00-intro.C">ex-00-intro.C</a></th>
<td>
This example shows some very basic features of CoCoALib.  See also 
the examples ex-c++-XXX for some basic C++ guidelines.             


</td></tr><tr><td colspan=2><pre>
This example shows some very basic features of CoCoALib.           
We show types for representing "big" integers and rationals.     
We also show how to do some compututations with polynomials.       


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-AlexanderDual.C" name="ex-AlexanderDual.C">ex-AlexanderDual.C</a></th>
<td>
Program showing `AlexanderDual' and `PrimaryDecomposition' on 
monomial ideals.  If Frobby is available, it is used too.     


</td></tr><tr><td colspan=2><pre>
This example shows how to compute the `AlexanderDual' and the       
`PrimaryDecomposition' of monomial ideals.  These operations are    
offered by both CoCoALib and the external library Frobby.  This     
program shows how to check whether Frobby is available, and if so,  
how to call its functions with CoCoALib data.                       


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-ApproxPts1.C" name="ex-ApproxPts1.C">ex-ApproxPts1.C</a></th>
<td>
A short example showing how to use the approximate point preprocessing algorithms.
See the file ex-ApproxPt1.in for a sample input.


</td></tr><tr><td colspan=2><pre>
A short example which reads a set of approximate points (with common epsilon)
and then applies the various preprocessing algorithms to them.  It prints out
the resulting preprocessed set with the corresponding weights, and the time taken.

</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-BenchmarkToolkit.C" name="ex-BenchmarkToolkit.C">ex-BenchmarkToolkit.C</a></th>
<td>
</td></tr><tr><td colspan=2><pre>
</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-BigInt1.C" name="ex-BigInt1.C">ex-BigInt1.C</a></th>
<td>
Program showing basic use of BigInt values: creation, printing, and  
some simple arithmetic.                                              


</td></tr><tr><td colspan=2><pre>
This program illustrates basic operations on BigInt values, showing that   
they can be used much like normal C++ ints except that there is a almost   
no limit on the magnitude of the values.                                   
NB If you need extreme efficiency then use the GMP library directly.       
Contrast this example with ex-RingZZ1.                                     


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-BigInt2.C" name="ex-BigInt2.C">ex-BigInt2.C</a></th>
<td>
Program to calculate the modular inverse of a number.  
You must give as input the modulus and the residue;    
the residue need not be reduced.                       


</td></tr><tr><td colspan=2><pre>
This program illustrates that BigInt values can be used much like normal C++ 
ints except that there is a almost no limit on the magnitude of the values.  
NB If you need extreme efficiency then use the GMP library directly.         
Contrast this example with ex-RingZZ1.                                       


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-BigInt3.C" name="ex-BigInt3.C">ex-BigInt3.C</a></th>
<td>
Program to find a (probable) prime with a specified number of bits.


</td></tr><tr><td colspan=2><pre>
This program shows that BigInts can be used much like normal C++ ints
with the advantage that there is almost no limit on the magnitude of 
the values.  Here we generate random BigInts and test them for being 
probable primes -- stopping as soon as we find a likely prime.       
NB If you need extreme efficiency then use the GMP library directly. 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-BigRat1.C" name="ex-BigRat1.C">ex-BigRat1.C</a></th>
<td>
Program illustrating basic use of BigRat values (i.e. rational numbers) 
showing that they can be used with a natural syntax.                


</td></tr><tr><td colspan=2><pre>
Program giving example of basic arithmetic with exact rational numbers 
represented as values of type BigRat.  The syntax recalls that used for    
the built-in C++ numerical types.  Emphasis is on convenience rather   
utmost execution speed.  To understand better the difference between   
a BigRat value and an element of the ring RingQ, contrast this example     
with ex-RingQ1.C.                                                      


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-BigRatInterval1.C" name="ex-BigRatInterval1.C">ex-BigRatInterval1.C</a></th>
<td>
This example shows how to create objects of type BigRatInterval,  
and how to do basic arithmetic with them.    


</td></tr><tr><td colspan=2><pre>
This example shows how to create objects of type BigRatInterval,  
and how to do basic arithmetic with them.    


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-BuildInfo.C" name="ex-BuildInfo.C">ex-BuildInfo.C</a></th>
<td>
This is a very short example showing what you can do with BuildInfo. 


</td></tr><tr><td colspan=2><pre>
BuildInfo::PrintAll gives important information in the (enormously 
unlikely :-) event that you need to report a bug in CoCoALib. 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-CoprimeFactorBasis1.C" name="ex-CoprimeFactorBasis1.C">ex-CoprimeFactorBasis1.C</a></th>
<td>
This example shows how to compute a factor base using an object  
of type GCDFreeBasis_RingElem.                                   


</td></tr><tr><td colspan=2><pre>
This example shows how to compute a factor base using an object of
type GCDFreeBasis_RingElem.  The gennerators of the factor base   
may be supplied individually, or all together in a vector.        


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-CpuTimeLimit1.C" name="ex-CpuTimeLimit1.C">ex-CpuTimeLimit1.C</a></th>
<td>
This example shows how to use a CpuTimeLimit object to limit        
the CPU time used in a function.  Compare this example with that in 
ex-CpuTimeLimit2.C.

</td></tr><tr><td colspan=2><pre>
This example shows how to use a CpuTimeLimit object to limit the    
CPU time used in a function containing a loop: just call the memfn  
operator(), which will throw TimeoutException if timeout occurs.    
Note that timeout may occur a bit later than requested.             


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-CpuTimeLimit2.C" name="ex-CpuTimeLimit2.C">ex-CpuTimeLimit2.C</a></th>
<td>
This example shows how to use a CpuTimeLimit object to limit the   
CPU time used in a section of code, and what myPrepareForNewLoop   
does.  Compare this example with ex-CpuTimeLimit1.C.

</td></tr><tr><td colspan=2><pre>
This example shows how to use a CpuTimeLimit object to limit the   
CPU time used in a section of code.  In particular, it shows use of
myPrepareForNewLoop between two loops (with differing costs for a  
single iteration).  Compare this example with ex-CpuTimeLimit1.C.

</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-DivMask1.C" name="ex-DivMask1.C">ex-DivMask1.C</a></th>
<td>
This example program shows the use of DivMasks.  
See also the example program ex-PPWithMask1.C    


</td></tr><tr><td colspan=2><pre>
We show how to use DivMasks directly -- it is a bit tedious!             
See also the example ex-PPWithMask1.C, which has a friendlier interface. 
We show how the various different DivMaskRules can be selected.          


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-DivMask2.C" name="ex-DivMask2.C">ex-DivMask2.C</a></th>
<td>
This example program performs some divisibility tests on PPs     
using DivMasks; it measures the effectiveness of the various     
DivMaskRules.  See ex-PPWithMask2 for some similar timing tests. 


</td></tr><tr><td colspan=2><pre>
This example program illustrates the effectiveness of the various    
DivMaskRules when using DivMasks as a quick non-divisibility check.  
Using DivMasks to check divisibility we can obtain two answers:      
'Surely not' or 'Maybe'.  The intention here is to see how often     
'Maybe' really means 'Yes, divisible'.  We see that the effectiveness
depends also on the presence of unused indeterminate in the PPMonoid.


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-DynamicBitset1.C" name="ex-DynamicBitset1.C">ex-DynamicBitset1.C</a></th>
<td>
This example program shows the use of DynamicBitsets.  


</td></tr><tr><td colspan=2><pre>
We show how to convert to and from PPMonoidElem.             
We list the available operations which are a lot faster than 
the corresponding ones on PPMonoidElems.                     
By default DynamicBitsets are printed as STL bitsets, i.e.   
0th bit in the rightmost position.  We show other options.   

Note that the ordering is xel, i.e. like lex but starting    
the comparison from the position with highest index (as they 
are printed by default)

</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-DynamicBitset2.C" name="ex-DynamicBitset2.C">ex-DynamicBitset2.C</a></th>
<td>
This example program shows the use of DynamicBitsets.  


</td></tr><tr><td colspan=2><pre>
We show how to convert to and from RingElem.             
We create an ideal I and convert its generator into DynamicBitsets.


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-ExternalLibs1.C" name="ex-ExternalLibs1.C">ex-ExternalLibs1.C</a></th>
<td>
This is an example program showing how to see which external  
libraries have been compiled into CoCoALib.                   


</td></tr><tr><td colspan=2><pre>
This is an example program showing how to see which external  
libraries have been compiled into CoCoALib.                   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-FloatApprox1.C" name="ex-FloatApprox1.C">ex-FloatApprox1.C</a></th>
<td>
This program makes simple use of the "floating point" approximation 
functions: MantissaAndExponent10 and MantissaAndExponent2, FloatApprox.

</td></tr><tr><td colspan=2><pre>
Example of use of MantissaAndExponent10 and related MantExp10 structure. 
Example of use of MantissaAndExponent2 and related MantExp2 structure.   
Example of use of FloatApprox (similatr to MantissaAndExponent2).        


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-GFan1.C" name="ex-GFan1.C">ex-GFan1.C</a></th>
<td>
This program shows what can be computed in CoCoALib using GFan:  
a library for computations in ..., 
....

</td></tr><tr><td colspan=2><pre>
This program shows what can be computed in CoCoALib using GFan:  
a library for computations in ..., 
....

</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-GMPAllocator1.C" name="ex-GMPAllocator1.C">ex-GMPAllocator1.C</a></th>
<td>
Program to find lengths of 3n+1 sequences -- using CoCoA::GMPAllocator  


</td></tr><tr><td colspan=2><pre>
This example shows how to specify that a CoCoALib custom allocator be used
for managing the memory for small GMP values.  If you do computations    
involving many small big-integers (e.g. up to about 40 decimal digits) then
the custom allocator may give slightly better run-time performance (with 
debugging turned off!)  The argument to the constructor for GlobalManager
indicates that the CoCoALib allocator is to be used for GMP values.      


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-GMPAllocator2.C" name="ex-GMPAllocator2.C">ex-GMPAllocator2.C</a></th>
<td>
Program comparing memory allocators for GMP values; compares speed.  


</td></tr><tr><td colspan=2><pre>
This example shows the various ways of specifying the memory manager to  
be used by the GMP library.  The choice of memory manager is indicated as
an argument to the GlobalManager constructor.  Here we illustrate four   
choices: the CoCoALib default, the system allocator, the specialized     
GMPAllocator (with and without explicit indication of the slice size).   
The program measures the speed of computation with these various choices.


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-HomomorphismFns1.C" name="ex-HomomorphismFns1.C">ex-HomomorphismFns1.C</a></th>
<td>
This is a template file for example programs.  
The program itself does nothing whatsoever.    


</td></tr><tr><td colspan=2><pre>
Make a copy of this file (called "foo.C", say) and put your code 
inside the procedure "program".                                  
To compile your file in the examples directory just do this:       
  make foo                                                         


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-IdealOfPoints1.C" name="ex-IdealOfPoints1.C">ex-IdealOfPoints1.C</a></th>
<td>
This example show how to call IdealOfPoints.  


</td></tr><tr><td colspan=2><pre>
This short example show how to call IdealOfPoints.                
The points are specified as rows of a matrix (over some field k). 
You need a polynomial ring for the answer: its coeff ring must be 
the same field k as used in the matrix.                           


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-IntegrationUIBCToSparsePolyRing.C" name="ex-IntegrationUIBCToSparsePolyRing.C">ex-IntegrationUIBCToSparsePolyRing.C</a></th>
<td>
This is a template file for example programs.  
The program itself does nothing whatsoever.    


</td></tr><tr><td colspan=2><pre>
Make a copy of this file (called "foo.C", say) and put your code 
inside the procedure "program".                                  
To compile your file in the examples directory just do this:       
  make foo                                                         


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-Janet1.C" name="ex-Janet1.C">ex-Janet1.C</a></th>
<td>
In this file we explain how to compute the Janet Basis in CoCoA.  


</td></tr><tr><td colspan=2><pre>
 We explain the function JanetBasis and show whicht options we can choose. 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-Janet2.C" name="ex-Janet2.C">ex-Janet2.C</a></th>
<td>
In this file we explain how to using some functions which are using the Janet Basis.  


</td></tr><tr><td colspan=2><pre>
 PrintNonMultVar, PrintMultVar, IsPommaretBasis, StandardRepresentation(f) 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-LogStream1.C" name="ex-LogStream1.C">ex-LogStream1.C</a></th>
<td>
This is a short example showing how to use LogStream, and how to  
make it refer to a different output stream.                       


</td></tr><tr><td colspan=2><pre>
This is a short example showing how to use LogStream, and how to  
make it refer to a different output stream.                       


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-MVT-Simplicial.C" name="ex-MVT-Simplicial.C">ex-MVT-Simplicial.C</a></th>
<td>
This program contains the code described in ISSAC 2019 paper: 
  Bigatti, Heras, Saenz-De-Cabezon
  "Monomial resolutions for efficient computation of simplicial homology"
  https://doi.org/10.1145/3326229.3326266

</td></tr><tr><td colspan=2><pre>
The paper examples are available at:
  http://www.dima.unige.it/~bigatti/cocoa/ex-MVT-Simplicial-tests.zip
This program reads from stdin.  For your convenience run it as:
  ./ex-MVT-Simplicial < ex-MVT-Simplicial-tests/<...>


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-MVT-SqFr.C" name="ex-MVT-SqFr.C">ex-MVT-SqFr.C</a></th>
<td>
MVT for square free monomial ideals  


</td></tr><tr><td colspan=2><pre>
MVT for square free monomial ideals  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-MVT-edge.C" name="ex-MVT-edge.C">ex-MVT-edge.C</a></th>
<td>
MVT for square free monomial ideals  


</td></tr><tr><td colspan=2><pre>
MVT for square free monomial ideals  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-MVT.C" name="ex-MVT.C">ex-MVT.C</a></th>
<td>
Example of use of the Mayer-Vietoris trees.  


</td></tr><tr><td colspan=2><pre>
Example of use of the Mayer-Vietoris trees.  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-MathSat1.C" name="ex-MathSat1.C">ex-MathSat1.C</a></th>
<td>
This program shows a prototype for MathSAT communication.


</td></tr><tr><td colspan=2><pre>
This program shows the first prototype for MathSAT communication.
The CoCoA class to use is MathSAT::env.                          
Only linear constraints, defined by matrices or polynomials.     
The matrices have n+1 columns: last col is for constants.        
The linear polynomials are compared with 0 (eq0, neq0, leq0, lt0).


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-MathSat2.C" name="ex-MathSat2.C">ex-MathSat2.C</a></th>
<td>
This program shows a prototype for MathSAT communication.


</td></tr><tr><td colspan=2><pre>
This program shows another example for MathSAT communication.    
Similar to ex-MathSAT1, also shows the use of verbosity.         


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-MorseGraph.C" name="ex-MorseGraph.C">ex-MorseGraph.C</a></th>
<td>
In this file we explain how to compute a free Resolution via Pommaret Basis in CoCoA.  


</td></tr><tr><td colspan=2><pre>
 JBResolution, JBBettiDiagramm, JBMinimalResolution. 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-NF.C" name="ex-NF.C">ex-NF.C</a></th>
<td>
Example program illustrating an implementation of Normal Remainder 
wrt a list of polynomials.                                         
If the list is a Groebner Basis, NR returns the Normal Form.       


</td></tr><tr><td colspan=2><pre>
This is just an example!  If you want to compute Normal Forms 
you should use the library function "NF".                   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-Normaliz1.C" name="ex-Normaliz1.C">ex-Normaliz1.C</a></th>
<td>
This program shows what can be computed in CoCoALib using Normaliz:  
a library for computations in affine monoids, vector configurations, 
lattice polytopes, and rational cones.

</td></tr><tr><td colspan=2><pre>
This program shows what can be computed in CoCoALib using Normaliz:  
a library for computations in affine monoids, vector configurations, 
lattice polytopes, and rational cones.

</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-Normaliz2.C" name="ex-Normaliz2.C">ex-Normaliz2.C</a></th>
<td>
This example shows how to set some libnormaliz flags.

</td></tr><tr><td colspan=2><pre>
This example reads a normaliz input file and computes the support hyperplanes.
It also shows how to set some libnormaliz flags.

</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-NumTheory-crypto1.C" name="ex-NumTheory-crypto1.C">ex-NumTheory-crypto1.C</a></th>
<td>
Interactive program for investigating cryptosystems.  
Implementation using BigInt.    


</td></tr><tr><td colspan=2><pre>
 DiffieHellman   
 ElGamal         
 RSA             
 Rabin           
 ====                                                      


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-NumTheory1.C" name="ex-NumTheory1.C">ex-NumTheory1.C</a></th>
<td>
This program illustrates the use of some basic number theoretic functions.


</td></tr><tr><td colspan=2><pre>
This programs show how to use some of the basic number theoretic functions.
Many of the examples use machine integers for convenience, but all the     
functions also work with BigInt values (except NextPrime and PrevPrime).   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-NumTheory2.C" name="ex-NumTheory2.C">ex-NumTheory2.C</a></th>
<td>
This program illustrates use of CRTMill to build a large integer 
from its residues modulo various different primes.               


</td></tr><tr><td colspan=2><pre>
This program illustrates use of CRTMill to build a large integer 
from its residues modulo various different primes.               


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-NumTheory3.C" name="ex-NumTheory3.C">ex-NumTheory3.C</a></th>
<td>
This example uses eratosthenes to build a sieve for testing quickly   
whether a number is prime.  We compute many Goldbach representations. 


</td></tr><tr><td colspan=2><pre>
This program tests how hard it is to find a "Goldbach" represetation 
of an integer; i.e. a sum of two primes.  It has to do many primality  
tests, so it is faster to use a table than call IsPrime repeatedly.    


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-NumTheory4.C" name="ex-NumTheory4.C">ex-NumTheory4.C</a></th>
<td>
This program shows how to reconstruct a rational from several     
residue-modulus pairs (allowing for some of them to be wrong).    


</td></tr><tr><td colspan=2><pre>
This program shows how to reconstruct a rational from several        
residue-modulus pairs (allowing for some of them to be wrong).       
CoCoALib offers two methods: one using continued fractions, the other
using lattice reduction.  The actual reconstruction is performed     
inside ContFracTrial or LatticeTrial.                                


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-OrderingGrading1.C" name="ex-OrderingGrading1.C">ex-OrderingGrading1.C</a></th>
<td>
Predefined and user-defined orderings and gradings 
on PPMonoid and PolyRing.                          


</td></tr><tr><td colspan=2><pre>
Each ordering is degree-compatible with grading over Z^GradingDim 
i.e. the grading is given by the first GradingDim rows            
of the ordering matrix.                                           


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-OrthogPolys1.C" name="ex-OrthogPolys1.C">ex-OrthogPolys1.C</a></th>
<td>
This program illustrates calling the functions for making  
orthogonal polynomials (Chebyshev, Hermite, Laguerre).     


</td></tr><tr><td colspan=2><pre>
This program illustrates calling the functions for making  
orthogonal polynomials (Chebyshev, Hermite, Laguerre).     


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PPMonoidElem1.C" name="ex-PPMonoidElem1.C">ex-PPMonoidElem1.C</a></th>
<td>
Example of use of power products and PPMonoids.     
Program exhibiting most functions on power products.


</td></tr><tr><td colspan=2><pre>
</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PPMonoidElem2.C" name="ex-PPMonoidElem2.C">ex-PPMonoidElem2.C</a></th>
<td>
Example of use of power products in different PPMonoids.   
Program exhibiting timings of the different implementations.


</td></tr><tr><td colspan=2><pre>
The implementations of PPMonoids are optimized for different uses:  
PPMonoidEv:   stores the Exponent vector                            
              good for accessing the exponents, slow for ordering   
PPMonoidOv:   stores the Order vector                               
              good for ordering, slow for accessing the exponents   
PPMonoidEvOv: stores the Exponent vector and the Order vector       
              good for accessing the exponents and for ordering     
              uses more memory and takes more time to assign        
PPMonoidBigEv: stores the Exponent vector as BigInt's               
              necessary if you use big exponents (>2^10)            
              obviously slow   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PPMonoidHom1.C" name="ex-PPMonoidHom1.C">ex-PPMonoidHom1.C</a></th>
<td>
This program shows how to create and use a PPMonoidHom.  


</td></tr><tr><td colspan=2><pre>
This program shows how to create and use a PPMonoidHom.  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PPVector1.C" name="ex-PPVector1.C">ex-PPVector1.C</a></th>
<td>
This example program shows the use of PPVector.            
PPVector is still work in progress, so syntax might change 


</td></tr><tr><td colspan=2><pre>
PPVector is a vector of PPWithMask.                       
It's been designed to represent the list of generators of 
monomial ideals (e.g. to facilitate interreduction).      
USE WITH CARE!  The interface may still change slightly.

</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PPWithMask1.C" name="ex-PPWithMask1.C">ex-PPWithMask1.C</a></th>
<td>
This example program shows the use of PPWithMasks for 
testing divisibility between PPs.                     
Compare with ex-DivMask1.C.                           


</td></tr><tr><td colspan=2><pre>
We show how to use PPWithMasks for testing divisibility.      
This program is very similar to ex-DivMask1.C.  The main      
differences are that this program is shorter and clearer, and 
it does a proper job of testing divisibility (even when the   
 useless null rule is used).                                  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PPWithMask2.C" name="ex-PPWithMask2.C">ex-PPWithMask2.C</a></th>
<td>
This example program performs some divisibility speed tests   
using PPWithMasks; it shows the difference in speed which can 
be achieved using various DivMaskRules.                       


</td></tr><tr><td colspan=2><pre>
This example program test the speed of the divisibility test  
on values of type PPwithMask.  The main aim is to show that   
different DivMaskRules can produces differing behaviour, and  
which rule is best depends on the problem (e.g. few indets    
and high degrees, or many indets and low degrees).  Here we   
see also that unused indets can affect the speed.             
In case you're interested, the program ex-DivMask2 measures   
the effectiveness of the various DivMaskRules.                


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PolyInput1.C" name="ex-PolyInput1.C">ex-PolyInput1.C</a></th>
<td>
This program shows a very crude way to read a polynomial from the input;
this could be useful for importing some kind of raw data.
See ex-PolyInput2.C for much better, human usable, functions.


</td></tr><tr><td colspan=2><pre>
</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PolyInput2.C" name="ex-PolyInput2.C">ex-PolyInput2.C</a></th>
<td>
This program shows how read a polynomial from a string or a file.


</td></tr><tr><td colspan=2><pre>
This program shows the easiest way to read a RingElem (not just polys) 
from an expression written in a string or in a file.                   
It is much more refined than what was available/shown in ex-PolyInput1.
NB As always, reading from string is convenient but NOT efficient.     


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PolyIterator1.C" name="ex-PolyIterator1.C">ex-PolyIterator1.C</a></th>
<td>
Program showing how to iterate through "sparse" polynomials.


</td></tr><tr><td colspan=2><pre>
Unlike in CoCoA-5, there no functions in CoCoALib to extract the      
support, the coeff list or the monomials from a polynomial.  Instead  
CoCoALib offers an "iterator" over the terms in a sparse polynomial:
you can access the coeff and PP directly from the iterator.           


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PolyIterator2.C" name="ex-PolyIterator2.C">ex-PolyIterator2.C</a></th>
<td>
Program showing how to homogenize a sparse polynomial using iterators.


</td></tr><tr><td colspan=2><pre>
This is just an example!  If you want to homogenize polynomials  
you should use the library function "homog".                   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PolyRing1.C" name="ex-PolyRing1.C">ex-PolyRing1.C</a></th>
<td>
Example showing how to create some simple polynomial rings.             
It also shows some of the operations specific to elements of PolyRings. 
See also ex-ring2.C                                                     


</td></tr><tr><td colspan=2><pre>
This example program exhibits two things: various ways of creating 
polynomial rings, and several operations specific to elements of a 
polynomial ring.                                                   
In the procedure "program" there are examples of creating        
polynomial rings.                                                  
In the procedure "SomeComputations" there are brief examples of  
the operations specific to elements of PolyRings (e.g. deg).       
See also ex-ring2.C.                                               


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PolyRing2.C" name="ex-PolyRing2.C">ex-PolyRing2.C</a></th>
<td>
Example showing how to write polynomials using "monomial" 
See also ex-PolyRing1.C                                     


</td></tr><tr><td colspan=2><pre>
Because of C/C++ precedence on operator "^" we cannot overload
it to define powers, as a consequence writing power-products can
be quite tedious or difficult to read.                          
Here we show how to write a simple function to create exponent  
vectors to be passed to "monomial".                           
I wish there were a better way to initialise a C++ vector...    


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PolyRing3.C" name="ex-PolyRing3.C">ex-PolyRing3.C</a></th>
<td>
This example program shows how to extract the "coefficients" 
of a polynomial, and also how to compute some other operations 
on the coefficients                                            


</td></tr><tr><td colspan=2><pre>
This example program shows how to extract the "coefficients" 
of a polynomial, and also how to compute some other operations 
on the coefficients (e.g. content).  CoCoALib offers two notions
of coefficient: one is the natural one dictated by the ring,   
and the other comes from identifying e.g. k[x,y,z] and k[x,z][y]


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-PolyRing4.C" name="ex-PolyRing4.C">ex-PolyRing4.C</a></th>
<td>
Example showing how to create more polynomial rings.              
(follows ex-PolyRing1.C)                                          


</td></tr><tr><td colspan=2><pre>
More specialized and optimized polynomial rings                   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-Pommaret1.C" name="ex-Pommaret1.C">ex-Pommaret1.C</a></th>
<td>
In this file we explain how to compute several stability positions.  


</td></tr><tr><td colspan=2><pre>
In this file we explain how to compute several stability positions.  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-Pommaret2.C" name="ex-Pommaret2.C">ex-Pommaret2.C</a></th>
<td>
In this file we explain how to using some methods which are using the Pommaret Basis.  


</td></tr><tr><td colspan=2><pre>
In this file we explain how to using some methods which are using the Pommaret Basis.  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-ProgressReporter1.C" name="ex-ProgressReporter1.C">ex-ProgressReporter1.C</a></th>
<td>
This is a simple example showing how to use a ProgressReporter. 


</td></tr><tr><td colspan=2><pre>
An example of how to use a ProgressReporter to print occasional 
updates during a long iterative computation.                    


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-QuotientBasis.C" name="ex-QuotientBasis.C">ex-QuotientBasis.C</a></th>
<td>
Program showing how to compute a quotient basis of a 0-dimensional ideal.


</td></tr><tr><td colspan=2><pre>
The function "QuotientBasis" is now included in CoCoALib,          
so this example is a lot shorter than it was before version 0.9943.  
It returns a vector of PPMonoidElem.


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RandomBigInt1.C" name="ex-RandomBigInt1.C">ex-RandomBigInt1.C</a></th>
<td>
This program illustrates use of the pseudo-random number generator of CoCoALib.
The numbers are independent and uniformly distributed in the given range; both 
ends of the range are reachable.                                               
See RandomSeqBool if you want random bools,                                    
  & RandomSeqLong if you want random machine integers.                         
See also RandomSource for a general random generator.                          


</td></tr><tr><td colspan=2><pre>
CoCoALib offers a way to make uniform pseudo-random number generators.      
When creating the generator you must specify the (inclusive) upper and lower
bounds for the random numbers which will be generated.  When creating a     
generator you may specify a `seed'; this allows different pseudo-random     
sequences to be produced, though the sequence is completely determined by   
its initial seed value.                                                     


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RandomBool1.C" name="ex-RandomBool1.C">ex-RandomBool1.C</a></th>
<td>
This program illustrates use of the pseudo-random bit generator of CoCoALib.  
The bits are independent, identically distributed; each with equal probability
of being true or false.  It is also possible to generate biased bits.         
See RandomSeqLong & RandomSeqBigInt if you want random integers.              
See also RandomSource for a general random generator.                         


</td></tr><tr><td colspan=2><pre>
CoCoALib offers a pseudorandom bit generator.  The generator can be   
seeded when it is created; this allows different pseudo-random        
sequences to be produced, though the sequence is completely determined
by the initial seed value.  The `NextBiasedBool' function filters a   
random bit sequence to produce `true' with a specified probability.   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RandomLong1.C" name="ex-RandomLong1.C">ex-RandomLong1.C</a></th>
<td>
This program illustrates the pseudo-random number generator of CoCoALib: 
  RandomSeqLong.                                                         
The numbers are independent and uniformly distributed in the given range;
both ends of the range are reachable.                                    
See RandomSeqBool if you want random bools,                              
and RandomSeqBigInt if you want random large integers.                   
See also RandomSource for a general random generator.                    


</td></tr><tr><td colspan=2><pre>
CoCoALib offers a way to make uniform pseudo-random number generators.   
When creating the generator you must specify the (inclusive)             
upper and lower bounds for the random numbers which will be generated.   
When creating a generator you may specify a `seed';                      
this allows different pseudo-random sequences to be produced,            
though the sequence is completely determined by its initial seed value.  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RandomSource1.C" name="ex-RandomSource1.C">ex-RandomSource1.C</a></th>
<td>
This program shows the easiest way to produce                   
random booleans, machine integers, and big integers.            


</td></tr><tr><td colspan=2><pre>
This program uses GlobalRandomSource() to generate uniformly   
distributed random bits/booleans, machine integers in a given  
range, and big integers in a given range.  For the booleans and
machine integers it produces a histogram.                      
Use of globals could be dangerous in multi-threaded programs.  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RandomSource2.C" name="ex-RandomSource2.C">ex-RandomSource2.C</a></th>
<td>
This program shows basic use of a RandomSource object to produce
random booleans, machine integers, and big integers.            
Also shows how to seed and reseed a RandomSource.               
This program uses explicitly a RandomSource object to generate 
distributed random bits/booleans, machine integers in a given  
range, and big integers in a given range.                      


</td></tr><tr><td colspan=2><pre>
This program uses explicitly a RandomSource object to generate 
distributed random bits/booleans, machine integers in a given  
range, and big integers in a given range.                      


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingElem1.C" name="ex-RingElem1.C">ex-RingElem1.C</a></th>
<td>
First introduction to polynomial rings and polynomials (RingElem) 


</td></tr><tr><td colspan=2><pre>
Create your first polynomial ring and polynomial.           
Basic operations an printing. 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingElem2.C" name="ex-RingElem2.C">ex-RingElem2.C</a></th>
<td>
Example showing operations on RingElem for a ring or a PolyRing.


</td></tr><tr><td colspan=2><pre>
This is a long list of function calls from different rings.  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingFp1.C" name="ex-RingFp1.C">ex-RingFp1.C</a></th>
<td>
Inefficient program to compute sqrt(2) modulo a given number.    
Simple example using finite fields or integers modulo N.


</td></tr><tr><td colspan=2><pre>
The program asks the user for the value of N, it creates the     
ring of integers mod N, and finally uses "brute force" to find 
all square-roots of 2 modulo N.                                  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingFp2.C" name="ex-RingFp2.C">ex-RingFp2.C</a></th>
<td>
When computing over a finite field normally it is best to use the
function NewZZmod to create the field.  However, for the curious 
it is possible to create small prime finite fields stating the   
particular implemention method (there are 3 possibilities).      


</td></tr><tr><td colspan=2><pre>
This program compares the speeds of computing sums and products in   
the three different implementations of small prime finite fields.    
It performs the timing tests for different sizes of prime, and       
illustrates that different implementations have different upper      
limits for the characteristic -- these limits depend on the platform.
It also gives the performance of the finite field created by NewZZmod


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingFq1.C" name="ex-RingFq1.C">ex-RingFq1.C</a></th>
<td>
This example illustrates how to create an algebraic extension of a finite 
field, and how to obtain its generator.                                   


</td></tr><tr><td colspan=2><pre>
This example illustrates how to create an algebraic extension of a finite 
field, and how to obtain its generator.  We use the (group) generator to  
run through all the elements of the finite field.                         


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingHom1.C" name="ex-RingHom1.C">ex-RingHom1.C</a></th>
<td>
The example in this file shows how to create and use some 
homomorphisms between rings.                              


</td></tr><tr><td colspan=2><pre>
CanonicalHom is an easy way to make these homomorphisms:  
R --> R/I,    R --> R[x],   R --> FractionField(R),       
R --> R,      QQ --> R,     ZZ --> R,                     
PolyAlgebraHom makes the R-algebra homomorphisms:         
R[x] --> R,   R[x] --> R[y]                               


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingHom2.C" name="ex-RingHom2.C">ex-RingHom2.C</a></th>
<td>
Operations between elements of different rings are not allowed 
but we can use homomorphisms to map the elements into the      
same ring. 


</td></tr><tr><td colspan=2><pre>
The example in this file shows how to create and use some      
homomorphisms between rings.  In particular, it gives a simple 
example of mixed ring arithmetic: the user must map all values 
into a single ring before combining them arithmetically.       


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingHom3.C" name="ex-RingHom3.C">ex-RingHom3.C</a></th>
<td>
This program shows how we define a ring homomorphism       
to perform a change of coordinates in a polynomial ring.   


</td></tr><tr><td colspan=2><pre>
</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingHom4.C" name="ex-RingHom4.C">ex-RingHom4.C</a></th>
<td>
This program shows how we define a ring homomorphism       
to evaluate polynomials.                                   


</td></tr><tr><td colspan=2><pre>
</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingHom5.C" name="ex-RingHom5.C">ex-RingHom5.C</a></th>
<td>
The example in this file shows how to create and use some 
homomorphisms between rings.                              


</td></tr><tr><td colspan=2><pre>
We compute these polynomials (with parameters) in some rings: 
f = (2*a/3-1)*x[0] + 1/a;  g = x[0]-a;                        


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingHom6.C" name="ex-RingHom6.C">ex-RingHom6.C</a></th>
<td>
The example in this file shows how to create a RingHom from 
one quotient ring to another.                               


</td></tr><tr><td colspan=2><pre>
The example in this file shows how to create a RingHom from 
one quotient ring to another.  First we make a RingHom from 
a polynomial ring to the codomain (a quotient ring), then we
use the function `InducedHom' to extend it to the full domain.


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingQQ1.C" name="ex-RingQQ1.C">ex-RingQQ1.C</a></th>
<td>
Some simple computations with rational numbers.                       
This example illustrates how to create the field of rational numbers. 
It shows that we can compute 7/3 in QQ but not in ZZ.                 
It shows how to map an integer into a rational number.                


</td></tr><tr><td colspan=2><pre>
Familiarize yourself with the example ex-RingZZ1.C before proceeding. 
As C++ does not natively have any rings, we must construct them from  
scratch.                                                              


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingTwinFloat1.C" name="ex-RingTwinFloat1.C">ex-RingTwinFloat1.C</a></th>
<td>
Example showing some features of RingTwinFloat.
Program to explore the precision offered by RingTwinFloat


</td></tr><tr><td colspan=2><pre>
</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingTwinFloat2.C" name="ex-RingTwinFloat2.C">ex-RingTwinFloat2.C</a></th>
<td>
Program exhibiting a way of using ever higher precisions...            
This example shows how failure can be a success: this pathological     
computation produces the **same wrong result** when using normal       
floating point arithmetic at any given finite precision!  However,     
since twin floats are self-checking, we detect that there is a problem.


</td></tr><tr><td colspan=2><pre>
Example showing iterative increase of precision using RingTwinFloat    
until the answer is found (or some maximum precision is reached).      
This program will always fail to find the limit: J-M Muller's sequence 
actually converges to 6 (rather slowly), however it is pathological    
because it converges to 100 using any finite precision arithmetic.     
RingTwinFloat detects the onset of pathological convergence to 100, and
throws an InsufficientPrecision exception.                             


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingTwinFloat3.C" name="ex-RingTwinFloat3.C">ex-RingTwinFloat3.C</a></th>
<td>
Program showing how some RingTwinFloat values can have more precision   
than that requested.                                                    


</td></tr><tr><td colspan=2><pre>
Example showing that certain RingTwinFloat values may have a precision  
higher than that requested.  In this case we request 64 bits (i.e.      
about 19 decimal digits), but in fact we can remove the nineteen most   
significant digits and still have a result with the requested precision.
So the original value of the variable third did in fact have at         
least 127 bits correct (i.e. about 38 decimal digits).                   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingTwinFloat6.C" name="ex-RingTwinFloat6.C">ex-RingTwinFloat6.C</a></th>
<td>
(Advanced) example illustrating the `soft transitions' from false to uncertain 
and from uncertain to true in the equality test between twin floats (as eps    
to zero when comparing 1+eps to 1).                                            


</td></tr><tr><td colspan=2><pre>
Example illustrating the `soft transitions' from false to uncertain      
and from uncertain to true in the equality test between twin floats.     
For many small values of eps this example computes 1+eps and compares    
the to 1 (either by direct comparison, or by subtacting and seeing if    
the difference is positive or zero.  Direct comparison is better than    
computing the difference (which throws InsufficientPrecision more often).


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingWeyl1.C" name="ex-RingWeyl1.C">ex-RingWeyl1.C</a></th>
<td>
An example about RingWeyl, the interface is not quite settled yet.


</td></tr><tr><td colspan=2><pre>
All these examples about RingWeyl will probably be merged into one.


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingWeyl2.C" name="ex-RingWeyl2.C">ex-RingWeyl2.C</a></th>
<td>
An example about RingWeyl, the interface is not quite settled yet.


</td></tr><tr><td colspan=2><pre>
This shows a computation of a Groebner Basis.
All these examples about RingWeyl will probably be merged into one.


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingWeyl3.C" name="ex-RingWeyl3.C">ex-RingWeyl3.C</a></th>
<td>
An example about RingWeyl, the interface is not quite settled yet.


</td></tr><tr><td colspan=2><pre>
This shows a computation of a Groebner Basis.
All these examples about RingWeyl will probably be merged into one.


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingWeyl4.C" name="ex-RingWeyl4.C">ex-RingWeyl4.C</a></th>
<td>
An example about RingWeyl, the interface is not quite settled yet.


</td></tr><tr><td colspan=2><pre>
This shows a computation of a Groebner Basis.
All these examples about RingWeyl will probably be merged into one.


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingWeyl5.C" name="ex-RingWeyl5.C">ex-RingWeyl5.C</a></th>
<td>
An example about RingWeyl, the interface is not quite settled yet.


</td></tr><tr><td colspan=2><pre>
This shows a computation of a Groebner Basis.
All these examples about RingWeyl will probably be merged into one.


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RingZZ1.C" name="ex-RingZZ1.C">ex-RingZZ1.C</a></th>
<td>
This is a basic example about the creation and use of the ring of integers.
It illustrates the CoCoALib "philosophy" of first creating a ring, and   
then computing with values in that ring.                                   
The C++ commands for performing arithmetic on RingElems have a natural     
syntax (except we cannot use ^ for powers).                                
It warns about "mixed ring arithmetic", which is forbidden in CoCoALib.  


</td></tr><tr><td colspan=2><pre>
To calculate with elements of a ring we must first create the   
ring, then we can create C++ objects of type RingElem which     
belong to the ring -- a RingElem can change its value but not   
the ring to which it belongs.                                   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-RootBound1.C" name="ex-RootBound1.C">ex-RootBound1.C</a></th>
<td>
This program illustrates use of the RootBound function for      
obtaining an upper bound on the abs value of the complex roots. 


</td></tr><tr><td colspan=2><pre>
This program illustrates use of the RootBound function for      
obtaining an upper bound on the abs value of the complex roots. 
The function has an optional second arg.  The second arg says   
how many Graeffe iterations to perform; these lead to a better  
bound, but can be slow for large polynomials (as the example    
makes clear).                                                   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-SmallFp1.C" name="ex-SmallFp1.C">ex-SmallFp1.C</a></th>
<td>
This example illustrates basic use of SmallFpImpl for arithmetic in a
small prime finite field.  ex-SmallFp3 shows how to compute more     
efficiently, but it is not for the faint-hearted!                    


</td></tr><tr><td colspan=2><pre>
This example illustrates basic use of SmallFpImpl for arithmetic in a
small prime finite field.  ex-SmallFp3 shows how to compute more     
efficiently, but it is not for the faint-hearted!                    
Here we see how to create a SmallFpImpl object, and its use for basic
arithmetic (add, sub, mul, div, power) on finite field elements.     


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-SmallFp2.C" name="ex-SmallFp2.C">ex-SmallFp2.C</a></th>
<td>
This simple example shows how to use the SmallFp export conventions
"SymmResidues" and "NonNegResidues", and the effect they have. 


</td></tr><tr><td colspan=2><pre>
This simple example shows how to use the SmallFp export conventions
"SymmResidues" and "NonNegResidues", and the effect they have. 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-SmallFp3.C" name="ex-SmallFp3.C">ex-SmallFp3.C</a></th>
<td>
**ADVANCED**  This example program is for advanced CoCoALib users. 
It shows how to use SmallFpImpl for efficient arithmetic in a small
prime finite field.  Not for the faint-hearted!                    


</td></tr><tr><td colspan=2><pre>
**ADVANCED**  This example program is for advanced CoCoALib users.    
SmallFpImpl enables you to perform arithmetic efficiently in a small  
prime finite field.  The catch is that efficient use is not as simple 
as using RingElems directly.  We take as a specific illustrative      
example the computation of an inner product.  Be prepared to spend    
some time reading and comprehending the code!                         


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-SparsePolyOps1.C" name="ex-SparsePolyOps1.C">ex-SparsePolyOps1.C</a></th>
<td>
This is a template file for example programs.  
The program itself does nothing whatsoever.    


</td></tr><tr><td colspan=2><pre>
Make a copy of this file (called "foo.C", say) and put your code 
inside the procedure "program".                                  
To compile your file in the examples directory just do this:       
  make foo                                                         


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-SparsePolyOps2.C" name="ex-SparsePolyOps2.C">ex-SparsePolyOps2.C</a></th>
<td>
This example shows simple use of RealRadical and HasRealRoot3.  


</td></tr><tr><td colspan=2><pre>
This example shows simple use of RealRadical and HasRealRoot3.  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-SparsePolyOps3.C" name="ex-SparsePolyOps3.C">ex-SparsePolyOps3.C</a></th>
<td>
This shows how to use the functions SturmSeq and NumRealRoots.  


</td></tr><tr><td colspan=2><pre>
This shows how to use the functions SturmSeq and NumRealRoots.  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-ToString1.C" name="ex-ToString1.C">ex-ToString1.C</a></th>
<td>
This program illustrates use of the decimal string conversion functions.


</td></tr><tr><td colspan=2><pre>
Example of use FloatStr, ScientificStr and DecimalStr for printing 
rationals in a comprehensible/decimal format.                      


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-ToString2.C" name="ex-ToString2.C">ex-ToString2.C</a></th>
<td>
This program illustrates use of the decimal string conversion functions.


</td></tr><tr><td colspan=2><pre>
Example of use FloatStr, ScientificStr and DecimalStr for printing 
rationals in a comprehensible/decimal format.                      


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-UtilsTemplate1.C" name="ex-UtilsTemplate1.C">ex-UtilsTemplate1.C</a></th>
<td>
This program shows how to use some of the "template utilities" 
in CoCoALib: e.g. sum, product, LexCmp3.                         


</td></tr><tr><td colspan=2><pre>
This program illustrates use of product, sum, and LexCmp3.      
The functions are fairly general, but we present just a simple  
case.  They can also be used with lists instead of vectors      


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-VectorOperations1.C" name="ex-VectorOperations1.C">ex-VectorOperations1.C</a></th>
<td>
Program to demonstrate printing of vectors (and lists). 


</td></tr><tr><td colspan=2><pre>
This example shows how to print out a C++ vector of values.          
It also shows that you can just as easily print a vector of vectors. 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-VerificationLevel1.C" name="ex-VerificationLevel1.C">ex-VerificationLevel1.C</a></th>
<td>
This is a program showing how to use VerificationLevel.  


</td></tr><tr><td colspan=2><pre>
This is a program showing how to use VerificationLevel.  
We construct a polynomial which confuses MinPolyQuot, then
show that MinPolyQuot gives the wrong answer if verification
is 0; but it get the right answer if verification is 2.
The guaranteed correct answer can be obtained by passing "guaranteed()"

</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-bool3.C" name="ex-bool3.C">ex-bool3.C</a></th>
<td>
This program shows a simple use of three-state booleans. 


</td></tr><tr><td colspan=2><pre>
This program shows a simple use of three-state booleans.        
We define a quick primality test which is guaranteed to be fast 
but which sometimes has to return a verdict of "Don't know" so
it can keep its guarantee of speed.  We then see how often the  
quick test gives a definite answer, and how often it has to say 
"Don't know".                                                 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-c++-arith.C" name="ex-c++-arith.C">ex-c++-arith.C</a></th>
<td>
This is an example showing some basic arithmetic ops in C++.   


</td></tr><tr><td colspan=2><pre>
This is an example showing some basic arithmetic ops in C++. 
With a strong caution about division and computing powers.   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-c++-basic.C" name="ex-c++-basic.C">ex-c++-basic.C</a></th>
<td>
This is an example showing some very basic C++:  comments, 
variable declaration (and init) for basic types and how to print. 


</td></tr><tr><td colspan=2><pre>
This is an example showing some very basic C++:  comments, 
variable declaration (and init) for basic types and        
how to print.  See also ex-c++-bool.C                      


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-c++-bool.C" name="ex-c++-bool.C">ex-c++-bool.C</a></th>
<td>
This is an example showing basic use of booleans in C++.  
See also ex-c++-basic.C.                                  


</td></tr><tr><td colspan=2><pre>
This is an example showing basic use of booleans in C++.  
Note especially the `smart' operators for `and' and `or'. 
See also ex-c++-basic.C.                                  


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-c++-class.C" name="ex-c++-class.C">ex-c++-class.C</a></th>
<td>
This is a (harder) example showing the implemention of a simple C++ class.
It shows class definition, and use of an object of that class.            
The class contains a general factorization of an integer.                 


</td></tr><tr><td colspan=2><pre>
This is a (harder) example showing the implemention of a simple C++ class.
It shows class definition, and use of an object of that class.            
The class contains a general factorization of an integer.  The class data 
members are `private' so their values can be seen or changed only by      
`member functions' or `friend functions'.                                 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-c++-fn-defn.C" name="ex-c++-fn-defn.C">ex-c++-fn-defn.C</a></th>
<td>
This is an example showing some basic function definitions in C++. 
The command `return' ends computation in the function/procedure;   
in a function it also says which value to return to the caller.    


</td></tr><tr><td colspan=2><pre>
This is an example showing some basic function definitions in C++. 
The command `return' ends computation in the function/procedure;   
in a function it also says which value to return to the caller.    
C++ barely distinguishes between "functions" (which return a     
value) and "procedures" (which return no value).                 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-c++-integers.C" name="ex-c++-integers.C">ex-c++-integers.C</a></th>
<td>
This is an example showing the C++ integer type "long", which
we recommend just for indexing; otherwise use "BigInt".      


</td></tr><tr><td colspan=2><pre>
This is an example showing the C++ integer type "long".  There  
are other types with different bit-widths; all can be "signed"  
or "unsigned" (just for non-negative values).  Computations     
are fast, but values may overflow silently (on most computers). 
We give an example showing how awkward it can be to avoid or    
anticipate overflow -- there are no such problem with BigInt!   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-c++-loop-for1.C" name="ex-c++-loop-for1.C">ex-c++-loop-for1.C</a></th>
<td>
This is an example showing some basic "for" loops in C++. 
It also shows "continue" and "break" inside a loop.     


</td></tr><tr><td colspan=2><pre>
This is an example showing some basic "for" loops in C++.    
It also shows "continue" and "break" inside a loop.        
We restrict to simple integer "for" loops.  See also examples
for vectors and iterators.                                     


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-c++-loop-for2.C" name="ex-c++-loop-for2.C">ex-c++-loop-for2.C</a></th>
<td>
This is an example showing the new style "for" loop in C++.   
See ex-c++-loop-for1.C for "continue" and "break" commands. 


</td></tr><tr><td colspan=2><pre>
This is an example showing the new style "for" loop in C++.   
See ex-c++-loop-for1.C for "continue" and "break" commands. 
We show how to state whether the elements are copied.           


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-c++-loop-while.C" name="ex-c++-loop-while.C">ex-c++-loop-while.C</a></th>
<td>
This is an example showing some basic "for" loops in C++. 
It also shows "continue" and "break" inside a loop.     


</td></tr><tr><td colspan=2><pre>
This is an example showing some basic "for" loops in C++.    
It also shows "continue" and "break" inside a loop.        
We restrict to simple integer "for" loops.  See also examples
for vectors and iterators.                                     


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-c++-vector1.C" name="ex-c++-vector1.C">ex-c++-vector1.C</a></th>
<td>
This is an example showing some basic use of C++ vectors    
(which are a bit like lists in CoCoA-5).                    
See also ex-c++-loop-for2.C for iterating over the elements.


</td></tr><tr><td colspan=2><pre>
This is an example showing some basic use of C++ vectors.    
C++ has few built-in types, but the STL (Standard Template   
Library) contains many useful extensions.  std::vector is    
is one of these extensions.  It is a homogeneous array: a    
collection of many objects of the same type, and each one    
may be accessed directly by an integer index (from 0 to n-1) 
See also ex-c++-loop-for2.C for iterating over the elements. 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-c++-vector2.C" name="ex-c++-vector2.C">ex-c++-vector2.C</a></th>
<td>
This is an example showing how to translate CoCoA-5 list  
functions APPEND, FIRST & LAST into C++.                  


</td></tr><tr><td colspan=2><pre>
This is an example showing how to translate CoCoA-5 list  
functions APPEND, FIRST & LAST into C++.  APPEND translates
nicely into push_back. Also first(L) and last(L) have nice
translations; BUT first(L,k) and last(L,k) do not have    
efficient translations -- there are usually better, but   
different techniques in C++.                              


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-convert1.C" name="ex-convert1.C">ex-convert1.C</a></th>
<td>
This program illustrates use of some of the "conversion" functions. 


</td></tr><tr><td colspan=2><pre>
This program illustrates use of some of the "conversion" functions.  
These functions convert integer/rational values from one type into     
another preserving the value -- if the conversion cannot be safely made
then this is indicated (via a boolean or an error).                    


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-empty.C" name="ex-empty.C">ex-empty.C</a></th>
<td>
This is a template file for example programs.  
The program itself does nothing whatsoever.    


</td></tr><tr><td colspan=2><pre>
Make a copy of this file (called "foo.C", say) and put your code 
inside the procedure "program".                                  
To compile your file in the examples directory just do this:       
  make foo                                                         


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-error1.C" name="ex-error1.C">ex-error1.C</a></th>
<td>
This example shows how to throw, catch and create your own errors. 


</td></tr><tr><td colspan=2><pre>
CoCoALib uses C++ exceptions to inform the user that a problem has occurred.    
This simple example illustrates the CoCoALib convention for reporting an error: 
call the macro CoCoA_THROW_ERROR which both constructs the "ErrorInfo" value  
and throws it.  It also shows how to catch these CoCoALib exceptions, which are 
always objects of type "ErrorInfo".  The most useful part of a CoCoALib       
exception is its error code: after catching a CoCoALib exception we can check   
whether its code is one we expected (and can deal with).  The full list of      
possible error codes can be found in the header file CoCoA/error.H.             


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-factor1.C" name="ex-factor1.C">ex-factor1.C</a></th>
<td>
This example shows how to interpret the result of a factorization. 


</td></tr><tr><td colspan=2><pre>
This example shows how to interpret the result of a factorization. 
It creates a ring element (belonging to a polynomial ring), and    
factorizes it.  The result is a "factorization object".  We show 
how to access/use the various fields in this object.               


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-frobby1.C" name="ex-frobby1.C">ex-frobby1.C</a></th>
<td>
This program shows what can be computed in CoCoALib using 
the C++ library Frobby


</td></tr><tr><td colspan=2><pre>
  "Frobby - Computations With Monomial Ideals"  
Web page: http://www.broune.com/frobby/

</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-geobucket1.C" name="ex-geobucket1.C">ex-geobucket1.C</a></th>
<td>
This program shows how to use geobuckets for long sums.          
It compares timings between normal sum "+=" and geobucket sum. 


</td></tr><tr><td colspan=2><pre>
We simulate a long sum:
we add the summands of a long polynomial f (and f*x) one at a time,   
and do it twice to consider also the arithmetics on the coefficients. 
The advantage for geobuckets comes when f is quite long.              
Geobuckets are to be used as a temporary value;                       
the final result is then copied into a RingElem.

</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-hilbert1.C" name="ex-hilbert1.C">ex-hilbert1.C</a></th>
<td>
This example is just for testing the Hilbert code.                   
It might disappear as soon as HilbertSeries is included in CoCoALib. 


</td></tr><tr><td colspan=2><pre>
This code also shows how to create the "chess examples".           


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-ideal1.C" name="ex-ideal1.C">ex-ideal1.C</a></th>
<td>
This example shows how to create ideals from ring elements. 


</td></tr><tr><td colspan=2><pre>
This short example shows how to create ideals from one or more 
ring elements.  If there are at most 4 generators this can be  
done directly; otherwise put the generators in a vector, and   
create the ideal from the vector.                              


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-ideal2.C" name="ex-ideal2.C">ex-ideal2.C</a></th>
<td>
This example shows some operations on ideals. 


</td></tr><tr><td colspan=2><pre>
This short example shows how to perform various operations  
involving ideals.  Certain operations are valid only for    
ideals in a polynomial ring.                                


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-interrupt1.C" name="ex-interrupt1.C">ex-interrupt1.C</a></th>
<td>
This short example shows an easy way of making CoCoALib programs  
handle signals (or interrupts), by converting them to exceptions. 


</td></tr><tr><td colspan=2><pre>
This short example shows an easy way of making CoCoALib programs  
handle signals (or interrupts), by converting them to exceptions. 
There are two crucial parts: create a SignalWatcher to say which  
signals to watch for, and call CheckForInterrupt when it is       
convenient to act upon the interrupting signal.                   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-interrupt2.C" name="ex-interrupt2.C">ex-interrupt2.C</a></th>
<td>
This example shows how to make a CoCoALib programs watch for   
signals only during a section of code.  Look at ex-interrupt1  
before looking at this example!  Compare what happens when you 
interrupt the first computation, and when you interrupt the    
second (identical) computation.                                


</td></tr><tr><td colspan=2><pre>
This example shows how to make a CoCoALib programs watch for   
signals only during a section of code.  Look at ex-interrupt1  
before looking at this example!  Compare what happens when you 
interrupt the first computation, and when you interrupt the    
second (identical) computation.                                


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-limits.C" name="ex-limits.C">ex-limits.C</a></th>
<td>
This example shows the numeric limits for CoCoALib.  


</td></tr><tr><td colspan=2><pre>
The numeric limits of CoCoALib depend on many factors: 
some choices from the authors of CoCoALib,                  
the compilation flags of CoCoALib, which in turn depend on  
the architecture of your machine and the compilations flags 
used by the gmp and boost libraries.                        


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-matrix1.C" name="ex-matrix1.C">ex-matrix1.C</a></th>
<td>
Example program illustrating the creation of matrices, and some 
operations on them. 


</td></tr><tr><td colspan=2><pre>
Example program illustrating the creation of matrices, and some 
basic operations on them. 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-matrix2.C" name="ex-matrix2.C">ex-matrix2.C</a></th>
<td>
Example program illustrating the creation of matrix views, and some  
effects of "aliasing".  Examples of matrix views include transposes
submatrices, block matrices, and concatenated matrices.              


</td></tr><tr><td colspan=2><pre>
Example program illustrating the creation of matrix views, and some    
effects of "aliasing", i.e. where there is more than one way to refer
to a single entry of the matrix.  We gives examples of creating various
views: ZeroMat, IdentityMat, transpose, submat, BlockMat2x2, ConcatHor 
and ConcatVer.

</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-matrix3.C" name="ex-matrix3.C">ex-matrix3.C</a></th>
<td>
This program shows how to solve linear systems (matrix equations). 


</td></tr><tr><td colspan=2><pre>
This program shows how to solve linear systems (matrix equations). 
At the moment linear system solving is only partially implemented. 
It will work if the matrix is over a field; otherwise it may fail. 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-matrix4.C" name="ex-matrix4.C">ex-matrix4.C</a></th>
<td>
This example shows how to use MatByRows & MatByCols.  


</td></tr><tr><td colspan=2><pre>
A simple example showing how a C++ vector can be viewed as a matrix.
You can even view the same vector in several different ways.        


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-module1.C" name="ex-module1.C">ex-module1.C</a></th>
<td>
Example program illustrating the creation of free modules, and 
some operations on them. 


</td></tr><tr><td colspan=2><pre>
Please note that the module code is still rather young. 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-module2.C" name="ex-module2.C">ex-module2.C</a></th>
<td>
Example program illustrating the creation of polynomial modules
with ordering and shifts. 


</td></tr><tr><td colspan=2><pre>
Please note that the module code is still rather young. 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-obsolescent.C" name="ex-obsolescent.C">ex-obsolescent.C</a></th>
<td>
This example program shows how to call an obsolescent CoCoALib function. 


</td></tr><tr><td colspan=2><pre>
This example program shows how to call an obsolescent CoCoALib function. 
You must do two things: 
(1) include the header file CoCoA/obsolescent.H 
(2) give the option AllowObsolescentFns to GlobalManager

</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-ring1.C" name="ex-ring1.C">ex-ring1.C</a></th>
<td>
This example program shows how to use the rings ZZ and QQ,          
and how to perform various operations on ring elements (RingElem).  


</td></tr><tr><td colspan=2><pre>
Use of the fundamental rings ZZ and QQ.                              
Creation of ring elements (C++ type RingElem).                       
Operations allowed on elements of the same ring:                     
  zero(R) and one(R)                                                 
  a + b, a - b, a * b                                                
  -a                                                                 
  a = b   (assignment)                                               
  a == b  and  a != b  (comparison)                                  
  IsZero(a), IsOne(a), IsMinusOne(a)                                 
Moreover other operations might be allowed, for example:             
  a > b   if the ring is ordered                                     
  a / b   if exact division is possible (and implemented!)           
See ex-RingHom*.C for how to move elements from one ring to another. 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-ring2.C" name="ex-ring2.C">ex-ring2.C</a></th>
<td>
This example program shows how to create various types of ring, and 
several operations one can perform on rings (e.g. querying their    
properties).                                                        


</td></tr><tr><td colspan=2><pre>
This example creates several different sorts of ring,            
and then calls PrintRingInfo on each one.                        
PrintRingInfo calls various functions to obtain information      
about each ring passed to it.  Naturally, some query functions   
make sense only for certain types of ring (e.g. NumIndets(R)).   


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-symbol1.C" name="ex-symbol1.C">ex-symbol1.C</a></th>
<td>
Creation of symbols, and some simple operations on them.


</td></tr><tr><td colspan=2><pre>
Symbols are used to give print names to indeterminates.  Their main   
use is as an argument to a pseudo-ctor for a PPMonoid or a polynomial 
ring -- see examples for those types.                                 


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-symbol2.C" name="ex-symbol2.C">ex-symbol2.C</a></th>
<td>
This program shows simple use of the functions for creating new   
anonymous symbols.                                                


</td></tr><tr><td colspan=2><pre>
Often algorithms need one to work with an addition new indeterminate
which must be different from all indeterminates already being use.  
In CoCoALib we can create new "anonymous" indeterminates guaranteed
to be different from all others.  This examples shows how to create 
them singly, and also several all together.                         


</pre></td></tr>
<!--=====================================-->
<tr bgcolor="#ddddff">
<th valign=top><a href="ex-verbose1.C" name="ex-verbose1.C">ex-verbose1.C</a></th>
<td>
This program illustrates the use of VerboseLog for producing progress  
reports on the various steps of an algorithm.                          


</td></tr><tr><td colspan=2><pre>
This program illustrates the use of VerboseLog for producing progress    
reports on the various steps of an algorithm.  You must set the global   
verbosity level using the fn SetVerbosityLevel (higher values mean more  
messages are printed) immediately before the call you want to investigate
and set it back to 0 afterwards!                                         


</pre></td></tr>
</table></body></html>
