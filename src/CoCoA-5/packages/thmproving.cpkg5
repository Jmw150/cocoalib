Package $thmproving

export ThmCollinear;
export ThmOnCircle;
export ThmLenSquare;
export ThmParallel;
export ThmPerpendicular;
export ThmEqualCos;
export ThmEqualTan;
export ThmIdealOfConditions;
export ThmProve;
export ThmOptimalHypothesisIdeal;
export ThmAlmostGoodSetOfConditions;

export ThmMan;
-- export ThmExamples;
export ThmExample_FeetAndMidpoint;
export ThmExample_Pappus;
export ThmExample_DegenerateParallelogram;

// export ExampleTitle;


Define About()
  PrintLn "    Topic   : Theorem proving";
  PrintLn "    Keywords: Theorem proving, hypothesis, thesis, condition";
  PrintLn "    Authors : L. Bazzotti, G. Dalzotto";
  PrintLn "    Version : CoCoA 4.3";
  PrintLn "    Date    : 8 November 2000 (rev.3  27 May 2003)";
  PrintLn "    ";
  PrintLn "    Maintainer : J.Abbott";
  PrintLn "    Version  : CoCoA-5.3";
  PrintLn "    Date     : 20 Feb 2020";
EndDefine; -- About

------[   help & examples   ]--------

Define ThmMan()
  PrintLn "SYNTAX";
  PrintLn "    -- here  POINT  means  [POLY, POLY]";
  PrintLn "    ThmCollinear(A: POINT, B: POINT, C: POINT): POLY";
  PrintLn "    ThmOnCircle(A: POINT, B: POINT, C: POINT, D: POINT): POLY";
  PrintLn "";
  PrintLn "    ThmLenSquare(AB: [POINT,POINT]): POLY";
  PrintLn "    ThmParallel(AB: [POINT,POINT], CD: [POINT,POINT]): POLY";
  PrintLn "    ThmPerpendicular(AB: [POINT,POINT], CD: [POINT,POINT]): POLY";
  PrintLn "";
  PrintLn "    ThmEqualCos(ABC: [POINT,POINT,POINT], DEF: [POINT,POINT,POINT]): POLY";
  PrintLn "    ThmEqualTan(ABC: [POINT,POINT,POINT], DEF: [POINT,POINT,POINT]): POLY";
  PrintLn "";
  PrintLn "    ThmIdealOfConditions(HypothesisIdeal: IDEAL , ThesisIdeal: IDEAL): IDEAL";
  PrintLn "    ThmProve(HypothesisIdeal: IDEAL , ThesisIdeal: IDEAL): RECORD";
  PrintLn "    ThmOptimalHypothesisIdeal(HypothesisIdeal: IDEAL, ConditionsIdeal: IDEAL)";
  PrintLn "                                                                     : IDEAL";
  PrintLn "    ThmAlmostGoodSetOfConditions(HypothesisIdeal: IDEAL, ConditionsIdeal:";
  PrintLn "                                                               IDEAL): LIST";
  PrintLn "";
  PrintLn "DESCRIPTION";
  PrintLn "";
  PrintLn "Given a putative theorem in Euclidean geometry, we introduce Cartesian";
  PrintLn "coordinates in the Euclidean plane, and translate the hypotheses and the";
  PrintLn "theses into algebraic relations.  This package deals with the problem of";
  PrintLn "determining whether this putative theorem is algebraically true.";
  PrintLn "";
  PrintLn "For more information and definitions of the terms used here, see the article:";
  PrintLn "Bazzotti, Dalzotto, Robbiano \"Remarks on Geometric Theorem Proving\"";
  PrintLn "which was published in Proceedings of the ADG-2000 conference,";
  PrintLn "LNAI, Springer-Verlag vol. 2061 pages 104--128.";
  PrintLn "";
  PrintLn "";
  PrintLn "The hypotheses and the theses can be translated into algebraic";
  PrintLn "relations using the following functions:";
  PrintLn "";
  PrintLn "ThmCollinear(A, B, C)";
  PrintLn "     returns a polynomial whose vanishing expresses that the points A,";
  PrintLn "     B and C are collinear.";
  PrintLn "ThmOnCircle(A, B, C, D),";
  PrintLn "     returns a polynomial whose vanishing expresses that the points A,";
  PrintLn "     B, C and D lie on a circle.";
  PrintLn "";
  PrintLn "ThmLenSquare([A,B])";
  PrintLn "     returns the square of the length of the segment connecting the";
  PrintLn "     points A and B.";
  PrintLn "ThmParallel([A,B], [C,D]),";
  PrintLn "     returns a polynomial whose vanishing expresses that the line";
  PrintLn "     through A and B and the line through C and D are parallel.";
  PrintLn "ThmPerpendicular([A,B], [C,D]),";
  PrintLn "     returns a polynomial whose vanishing expresses that the line";
  PrintLn "     through A and B and the line through C and D are perpendicular.";
  PrintLn "";
  PrintLn "ThmEqualCos(ABC,DEF),";
  PrintLn "     returns a polynomial whose vanishing expresses that the cosines";
  PrintLn "     of the angles ABC and DEF are equal.";
  PrintLn "ThmEqualTan([A,B,C], [D,E,F]),";
  PrintLn "     returns a polynomial whose vanishing expresses that the tangents";
  PrintLn "     of the oriented angles ABC and DEF are equal.";
  PrintLn "";
  PrintLn "Let HypothesisIdeal be the ideal generated by the polynomials whose";
  PrintLn "vanishing expresses the hypotheses, and let ThesisIdeal be the ideal";
  PrintLn "generated by the polynomials whose vanishing express the theses of the";
  PrintLn "theorem.  Consider all the degeneracy conditions which can be seen";
  PrintLn "from the statement of the theorem.  Call DegeneratePoly their product,";
  PrintLn "compute saturate(HypothesisIdeal,ideal(DegeneratePoly)), and call";
  PrintLn "this ideal HypothesisIdeal again.";
  PrintLn "";
  PrintLn "ThmIdealOfConditions(HypothesisIdeal,ThesisIdeal),";
  PrintLn "     returns the Ideal of Conditions, i.e. the ideal of the";
  PrintLn "     polynomials f such that the theorem is algebraically true under";
  PrintLn "     the condition that f doesn't vanish.";
  PrintLn "";
  PrintLn "ThmProve(HypothesisIdeal,ThesisIdeal),";
  PrintLn "  checks whether the theorem is algebraically true;";
  PrintLn "  the result is a Record whose field \"Statement\" says whether the";
  PrintLn "  putative theorem is true; if it is false, then there is another";
  PrintLn "  field \"ConditionIdeal\" giving the Ideal of Conditions.";
  PrintLn "";
  PrintLn "In the case the theorem is algebraically false, the following";
  PrintLn "functions help to understand why.";
  PrintLn "";
  PrintLn "ThmOptimalHypothesisIdeal(HypothesisIdeal,ConditionsIdeal),";
  PrintLn "     returns the Optimal Hypothesis Ideal, i.e. an ideal which";
  PrintLn "     contains the hypothesis ideal, and whose prime components are";
  PrintLn "     exactly those on which the theorem is algebraically true.";
  PrintLn "";
  PrintLn "ThmAlmostGoodSetOfConditions(HypothesisIdeal,ConditionsIdeal),";
  PrintLn "     returns an Almost Good Set of Conditions, i.e. a list of list of";
  PrintLn "     not trivial conditions.";
  PrintLn "     Each list contains equivalent conditions, so a Good Set of";
  PrintLn "     Conditions is determined by choosing a representative condition";
  PrintLn "     in each list.";
  PrintLn ExampleTitle("Theorem Proving Examples");
  PrintLn "--Feet and Midpoints";
  PrintLn "--In every triangle the circle passing through the feet of the three";
  PrintLn "--altitudes intersects the sides of the triangle in their midpoints.";
  PrintLn "ThmExample_FeetAndMidpoint();";
  PrintLn;
  PrintLn "---Pappus's Theorem";
  PrintLn "-- Let A, B, C be three points on a line, and let D, E, F  be three points";
  PrintLn "-- on another line. Let S be the intersection point of BD and AE, Q the";
  PrintLn "-- intersection point of CD and AF, P the intersection point of EC and";
  PrintLn "-- BF. Then P, Q, S are collinear.";
  PrintLn "ThmExample_Pappus();";
  PrintLn "";
  PrintLn "---Theorem of Degenerate Parallelogram";
  PrintLn "-- Given a parallelogram, the intersection point of the diagonals lies";
  PrintLn "-- on a side.";
  PrintLn "ThmExample_DegenerateParallelogram();";
enddefine; -- ThmMan


define ThmExample_FeetAndMidpoint()
  PrintLn ExampleTitle("Theorem Feet and Midpoints");
  PrintLn "--\"In every triangle the circle passing through the feet of the three";
  PrintLn "--altitudes intersects the sides of the triangle in their midpoints.\"";
  PrintLn "";
  PrintLn "-- Let A,B, and C be the vertices of a triangle.";
  PrintLn "-- WLOG A can be taken to be the origin (by a suitable translation),";
  PrintLn "-- and B can be taken to lie on the X axis (by a suitable rotation).";
  PrintLn "-- Let D, E and F be the feet of the altitudes,";
  PrintLn "-- and O, the centre of the circle passing through D, E & F.";
  println "/**/ use R ::= QQ[x[1..5],y[2..5]];";
  println "/**/ A:=[0,0];        B:=[x[1],0];      C:=[x[2],y[2]];";
  println "/**/ D:=[x[2],0];     E:=[x[3],y[3]];   F:=[x[4],y[4]];";
  println "/**/ O:=[x[5],y[5]];";
  PrintLn "";
  PrintLn "-- We shall show that M, the midpoint of side AB lies on the circle.";
  PrintLn "-- By symmetry, if one midpoint lies on the circle then they all will.";
  println "/**/ M:=[x[1]/2,0];";
  PrintLn "";
  println "/**/ H1 := ThmCollinear(F,A,C);           -- F lies on the edge AC";
  println "/**/ H2 := ThmPerpendicular([A,C],[F,B]); -- AC is perpendicular to FB";
  println "/**/ H3 := ThmCollinear(E,C,B);           -- E lies on the edge BC";
  println "/**/ H4 := ThmPerpendicular([A,E],[B,C]); -- AE is perpendicular to BC";
  println "/**/ H5 := ThmPerpendicular([D,C], [A,B]);";
  println "/**/ H6 := ThmLenSquare([O,E]) - ThmLenSquare([O,D]); -- OE = OD as distances";
  println "/**/ H7 := ThmLenSquare([O,D]) - ThmLenSquare([O,F]); -- OD = OF as distances";
  PrintLn "";
  println "/**/ HypothesisIdeal := ideal(H1,H2,H3,H4,H5,H6);";
  PrintLn "";
  PrintLn "--Now we exclude the case of a degenerate triangle.";
  println "/**/ D1 := x[1];   ---- x[1]=0 means A=B";
  println "/**/ D2 := y[2];   ---- y[2]=0 means C is on AB";
  println "/**/ DegeneratePoly := D1*D2;";
  println "/**/ HypothesisIdeal := saturate(HypothesisIdeal,ideal(DegeneratePoly));";
  PrintLn "";
  println "/**/ T1 := ThmLenSquare([O,M]) - ThmLenSquare([O,D]);";
  println "/**/ ThesisIdeal := ideal(T1);";
  PrintLn "";
  println "/**/ Thm := ThmProve(HypothesisIdeal,ThesisIdeal);  Thm.Statement;";
  PrintLn "   --The theorem is algebraically false. So you can find an Optimal";
  PrintLn "   --Hypothesis Ideal or an Almost Good Set of Conditions to";
  PrintLn "   --understand why the theorem is algebraically false.";
  PrintLn "";
  println "/**/ ConditionIdeal := Thm.ConditionIdeal;";
  PrintLn "";
  println "/**/ ThmOptimalHypothesisIdeal(HypothesisIdeal, ConditionIdeal);";
  PrintLn "   --In this case the Optimal Hypothesis Ideal is very difficult to read.";
  PrintLn "";
  PrintLn "";
  println "/**/ ThmAlmostGoodSetOfConditions(HypothesisIdeal, ConditionIdeal);";
  PrintLn "   --This functions returns";
  println "/**/ [[x[1]^2y[3] - x[4]^2y[3] - 2x[1]x[5]y[3] + 2x[4]x[5]y[3] +";
  println "/**/ 2x[1]x[5]y[4] - 2x[4]x[5]y[4] - y[2]y[4]^2 - 2x[1]^2y[5] + 2x[4]^2y[5]";
  println "/**/ + 2y[2]y[3]y[5] + 2y[2]y[4]y[5] - 2y[3]y[4]y[5],";
  PrintLn "(...)";
  -- println "/**/ x[4]y[3]y[4] - x[5]y[3]y[4] - 1/2x[3]y[4]^2 + x[5]y[4]^2 - x[4]y[4]y[5],";
  -- println "/**/ x[1]y[3]y[4] - x[5]y[3]y[4] - 1/2x[3]y[4]^2 + x[5]y[4]^2 -";
  -- println "/**/ 2x[1]y[4]y[5] + 2x[3]y[4]y[5] - x[4]y[4]y[5],";
  -- PrintLn "";
  -- println "/**/ x[1]y[4]^2 - x[3]y[4]^2 - 2x[1]y[4]y[5] + 2x[3]y[4]y[5],";
  -- PrintLn "";
  -- println "/**/ x[3]y[4]^3 - 2x[5]y[4]^3 - 2x[3]y[4]^2y[5] + 2x[4]y[4]^2y[5] +";
  -- println "/**/ 4x[5]y[4]^2y[5] - 4x[4]y[4]y[5]^2,";
  -- PrintLn "";
  -- println "/**/ x[4]x[5]y[4]^3 - 2x[5]^2y[4]^3 + 1/2y[2]y[4]^4 + 4x[5]^2y[4]^2y[5]";
  -- println "/**/ - y[2]y[4]^3y[5] + y[4]^4y[5] - 4x[4]x[5]y[4]y[5]^2 -";
  -- println "/**/ 2y[4]^3y[5]^2,";
  -- PrintLn "";
  -- println "/**/ x[4]^2y[4]^3 - 4x[5]^2y[4]^3 + y[2]y[4]^4 + y[4]^5 +";
  -- println "/**/ 4x[4]x[5]y[4]^2y[5] + 8x[5]^2y[4]^2y[5] - 2y[2]y[4]^3y[5] -";
  -- println "/**/ 4x[4]^2y[4]y[5]^2 - 8x[4]x[5]y[4]y[5]^2 - 4y[4]^3y[5]^2,";
  -- PrintLn "";
  -- println "/**/ x[3]y[2] - 2x[5]y[2] + x[1]y[3] - x[4]y[3] - x[3]y[4] + 2x[5]y[4]";
  -- println "/**/ - 2x[1]y[5] + 4x[2]y[5] - 2x[4]y[5],";
  -- PrintLn "";
  -- println "/**/ x[1]y[2] - 2x[5]y[2] - x[3]y[4] + 2x[5]y[4] - 2x[1]y[5] +";
  -- println "/**/ 4x[2]y[5] - 2x[4]y[5],";
  -- PrintLn "";
  -- println "/**/ x[4]y[2] - x[3]y[4],";
  -- PrintLn "";
  -- println "/**/ x[2]y[4] - x[3]y[4],";
  -- PrintLn "";
  -- println "/**/ x[1]x[2] - x[4]^2 - y[2]y[4] + y[3]y[4] - y[4]^2,";
  -- PrintLn "";
  -- println "/**/ x[2]^2 - x[4]^2 - y[2]y[4] + 2y[3]y[4] - y[4]^2,";
  -- PrintLn "";
  -- println "/**/ x[2]x[4] - x[4]^2 + y[3]y[4] - y[4]^2,";
  -- PrintLn "";
  -- println "/**/ x[2]x[5] - x[4]x[5] - 1/2y[2]y[4] + y[3]y[4] - y[4]y[5],";
  -- PrintLn "";
  -- println "/**/ x[2]y[3] - x[4]y[3],";
  -- PrintLn "";
  -- println "/**/ x[3]y[3]y[4] - x[5]y[3]y[4] - 1/2x[3]y[4]^2 + x[5]y[4]^2 - x[4]y[4]y[5],";
  -- PrintLn "";
  -- println "/**/ x[3]x[5]y[4] - x[4]x[5]y[4] - 1/2y[2]y[4]^2 + 2y[3]y[4]y[5] - y[4]^2y[5],";
  -- PrintLn "";
  -- println "/**/ x[3]x[4]y[4] - x[4]^2y[4] - y[4]^3 + 2y[3]y[4]y[5],";
  -- PrintLn "";
  -- println "/**/ y[3]^2y[4] - 2y[3]y[4]y[5],";
  -- PrintLn "";
  -- println "/**/ y[2]y[3]y[4] - 2y[3]y[4]y[5],";
  -- PrintLn "";
  -- println "/**/ y[3]y[4]^2 - 2y[3]y[4]y[5],";
  -- PrintLn "";
  -- println "/**/ x[5]^2y[2] - 1/2x[1]x[5]y[3] + 1/2x[4]x[5]y[3] - 1/4y[2]^2y[3] -";
  -- println "/**/ x[5]^2y[4] - 1/4y[2]^2y[4] + x[1]x[5]y[5] - x[4]x[5]y[5] +";
  -- println "/**/ 1/2y[2]y[3]y[5] - 3/2y[2]y[4]y[5] + 3y[3]y[4]y[5] - 2y[4]y[5]^2]]";
  PrintLn "";
  PrintLn "   --There is only one list of equivalent conditions.  We can pick";
  PrintLn "   --the one we like best (i.e. the simplest one): x[2]y[3] - x[4]y[3]";
  PrintLn "   --The theorem is algebraically true under the condition that";
  PrintLn "   --x[2]y[3] - x[4]y[3] doesn't vanish, which means that the triangle";
  PrintLn "   --is not right-angled.";
enddefine; -- ThmExample_FeetAndMidpoint


define ThmExample_Pappus()
  PrintLn ExampleTitle("Pappus Theorem");
  PrintLn "-- Let A, B, C be three points on a line, and let D, E, F  be three points";
  PrintLn "-- on another line. Let S be the intersection point of BD and AE, Q the";
  PrintLn "-- intersection point of CD and AF, P the intersection point of EC and";
  PrintLn "-- BF. Then P, Q, S are collinear.";
  PrintLn "";
  PrintLn "/**/ use R ::= QQ[x[1..8],y[3..8]];";
  PrintLn "";
  PrintLn "/**/ A:=[0,0];         B:=[x[1],0];      C:=[x[2],0];";
  PrintLn "/**/ D:=[x[3],y[3]];   E:=[x[4],y[4]];   F:=[x[5],y[5]];";
  PrintLn "/**/ P:=[x[6],y[6]];   Q:=[x[7],y[7]];   S:=[x[8],y[8]];";
  PrintLn "";
  PrintLn "/**/ H1 := ThmCollinear(D,E,F);";
  PrintLn "/**/ H2 := ThmCollinear(S,B,D);";
  PrintLn "/**/ H3 := ThmCollinear(S,A,E);";
  PrintLn "/**/ H4 := ThmCollinear(Q,C,D);";
  PrintLn "/**/ H5 := ThmCollinear(Q,A,F);";
  PrintLn "/**/ H6 := ThmCollinear(P,E,C);";
  PrintLn "/**/ H7 := ThmCollinear(P,B,F);";
  PrintLn "/**/ HypothesisIdeal := ideal(H1,H2,H3,H4,H5,H6,H7);";
  PrintLn "";
  PrintLn "/**/ DegeneratePoly := y[3]*y[4]*y[5];";
  PrintLn "";
  PrintLn "/**/ HypothesisIdeal := saturate(HypothesisIdeal,ideal(DegeneratePoly));";
  PrintLn "";
  PrintLn "/**/ T1 := ThmCollinear(P,Q,S);";
  PrintLn "/**/ ThesisIdeal := ideal(T1);";
  PrintLn "";
  PrintLn "/**/ ThmProve(HypothesisIdeal, ThesisIdeal);";
  PrintLn "-- The theorem is algebraically true with the saturated HypothesisIdeal";
  PrintLn "-- so the theorem is true if none of D,E,F in on the line through A, B and C";
  PrintLn "";
enddefine; -- ThmExample_Pappus
  

define ThmExample_DegenerateParallelogram()
  PrintLn ExampleTitle("Theorem of Degenerate Parallelogram");
  PrintLn "-- Given a parallelogram, the intersection point of the diagonals lies";
  PrintLn "-- on a side.";
  PrintLn "";
  PrintLn "/**/ Use R ::= QQ[x[1..4],y[2..4]];";
  PrintLn "";
  PrintLn "/**/ A := [0,0];        B := [x[1],0];";
  PrintLn "/**/ C := [x[2],y[2]];  D := [x[3],y[3]];";
  PrintLn "/**/ O := [x[4],y[4]];";
  PrintLn "";
  PrintLn "/**/ H1 := ThmParallel([A,B],[D,C]);";
  PrintLn "/**/ H2 := ThmParallel([A,D],[B,C]);";
  PrintLn "/**/ H3 := ThmCollinear(O,A,C);";
  PrintLn "/**/ H4 := ThmCollinear(O,D,B);";
  PrintLn "/**/ HypothesisIdeal := ideal(H1,H2,H3,H4);";
  PrintLn "";
  PrintLn "/**/ T1 := ThmCollinear(O,A,B);";
  PrintLn "/**/ ThesisIdeal := ideal(T1);";
  PrintLn "";
  PrintLn "/**/ Thm := ThmProve(HypothesisIdeal,ThesisIdeal);";
  PrintLn " --The theorem is algebraically false.";
  PrintLn "";
  PrintLn "/**/ ConditionsIdeal := Thm.ConditionsIdeal;";
  PrintLn "";
  PrintLn "/**/ ThmAlmostGoodSetOfConditions(HypothesisIdeal,ConditionsIdeal);";
  PrintLn " --In this case the Almost Good Set Of Conditions is very hard to";
  PrintLn " --read, so try to calculate an Optimal Hypothesis Ideal.";
  PrintLn "";
  PrintLn "/**/ ThmOptimalHypothesisIdeal(HypothesisIdeal,ConditionsIdeal);";
  PrintLn " --This function returns the ideal";
  PrintLn "ideal(x[1]y[4], x[1]y[2], x[1]y[3],";
  PrintLn "      x[3]y[2] -x[2]y[3], x[4]y[2] -x[2]y[4], x[4]y[3] -x[3]y[4])";
  PrintLn " --whose meaning is clear. You  conclude that the theorem is";
  PrintLn " --algebraically true for the parallelograms which degenerate into a";
  PrintLn " --segment.";
enddefine;

------[   Main functions   ]--------

define ThmCollinear(A, B, C)
  return (C[1]-A[1])*(C[2]-B[2])-(C[2]-A[2])*(C[1]-B[1]);
EndDefine; -- Collinear

define ThmParallel(AB, CD)
  A := AB[1];  B := AB[2];
  C := CD[1];  D := CD[2];
  return (B[1]-A[1])*(D[2]-C[2])-(B[2]-A[2])*(D[1]-C[1]);
EndDefine; -- Parallel

define ThmPerpendicular(AB, CD)
  A := AB[1];  B := AB[2];
  C := CD[1];  D := CD[2];
  return (B[1]-A[1])*(D[1]-C[1])+(B[2]-A[2])*(D[2]-C[2]);
EndDefine; -- Perpendicular

define ThmLenSquare(AB)
  A := AB[1];  B := AB[2];
  return (B[1]-A[1])^2+(B[2]-A[2])^2;
EndDefine; -- LenSquare


define ThmEqualTan(ABC, DEF)
  A := ABC[1];  B := ABC[2];   C := ABC[3];
  D := DEF[1];  E := DEF[2];   F := DEF[3];
  BA := [B, A];  BC := [B, C];
  ED := [E, D];  EF := [E, F];
  return  ($.Y(BA)*$.X(BC) - $.Y(BC)*$.X(BA)) *
          ($.X(ED)*$.X(EF) + $.Y(ED)*$.Y(EF)) -
          ($.Y(ED)*$.X(EF) - $.Y(EF)*$.X(ED)) *
          ($.X(BA)*$.X(BC) + $.Y(BA)*$.Y(BC));
EndDefine; -- EqualTan

define ThmOnCircle(A, B, C, D)
  ABC := [A, B, C];
  ADC := [A, D, C];
  return ThmEqualTan(ABC, ADC);
EndDefine; -- OnCircle

define ThmEqualCos(ABC, DEF)
  A := ABC[1];  B := ABC[2]; C := ABC[3];
  D := DEF[1];  E := DEF[2]; F := DEF[3];
  BA := [B, A]; BC := [B, C];
  ED := [E, D]; EF := [E, F];
  Num_1 := $.X(BA)*$.X(BC) + $.Y(BA)*$.Y(BC);
  Num_2 := $.X(ED)*$.X(EF) + $.Y(ED)*$.Y(EF);
  Pol := Num_1^2*ThmLenSquare(ED)*ThmLenSquare(EF)-
         Num_2^2*ThmLenSquare(BA)*ThmLenSquare(BC);
  return Pol;
EndDefine; -- EqualCos

-------------------- --------------------

define ThmIdealOfConditions(HypothesisIdeal, ThesisIdeal)
  return saturate(HypothesisIdeal,ThesisIdeal);
EndDefine; -- IdealOfConditions


define ThmProve(HypothesisIdeal, ThesisIdeal)
  IC := ThmIdealOfConditions(HypothesisIdeal,ThesisIdeal);
  if 1 isin IC then
    return record[Statement:=true];
  else
    return record[Statement:=false, ConditionIdeal:=IC];
  endif;
EndDefine; -- ProveThm


define ThmOptimalHypothesisIdeal(HypothesisIdeal,ConditionsIdeal)
  return saturate(HypothesisIdeal,ConditionsIdeal);
EndDefine; -- OptimalHypothesisIdeal


define ThmAlmostGoodSetOfConditions(HypothesisIdeal,ConditionsIdeal)
  P := RingOf(HypothesisIdeal); // assume this is a polyring
  K := CoeffRing(P); // assume this is a field
  nvars := NumIndets(P);
  TheoremProvingNewRing := NewPolyRing(K, concat(SymbolRange("x",1,nvars), ["z"]));
  z := indet(TheoremProvingNewRing, NumIndets(TheoremProvingNewRing));
  IntoNewRing := PolyAlgebraHom(P, TheoremProvingNewRing, first(indets(TheoremProvingNewRing),nvars));
  BackToOrigRing := PolyAlgebraHom(TheoremProvingNewRing, P, concat(indets(P), [zero(P)]));
//  TheoremProvingNewRing ::=  CoeffRing[x[1..NumIndets()], z];
//  Using TheoremProvingNewRing Do
  Hyp := ideal([IntoNewRing(gen) | gen in gens(HypothesisIdeal)]);
  IC := ideal([IntoNewRing(gen) | gen in gens(ConditionsIdeal)]);
  Conditions := Gens(IC);
  ListOfConditionsAndIdeals :=
    [ record[Ideal:=Elim(z,Hyp+ideal(C*z-1)), Poly:=C] | C In Conditions];
    if [ X in ListOfConditionsAndIdeals | not(1 isin X.Ideal) ] = [] then
      return  [];
    endif;
    AlmostGoodList := [];
    foreach ElementOfL in ListOfConditionsAndIdeals do
      Inserted := false;
      I := 1;
      while I <= Len(AlmostGoodList) and not(Inserted) do
	if AlmostGoodList[I].Ideal = ElementOfL.Ideal then
	  append(ref AlmostGoodList[I].Polys, ElementOfL.Poly);
	  Inserted := true;
	elif IsContained(ElementOfL.Ideal, AlmostGoodList[I].Ideal)  then
	  AlmostGoodList[I] := record[Ideal:=ElementOfL.Ideal,
				      Polys:=[ElementOfL.Poly]];
	  Inserted := true;
	elif IsContained(AlmostGoodList[I].Ideal, ElementOfL.Ideal) then
	  Inserted := true;
	endif;
	I := I+1;
      endwhile;
      if not(Inserted) then
	append(ref AlmostGoodList, record[Ideal:=ElementOfL.Ideal,
 	                              Polys:=[ElementOfL.Poly]]);
      endif;
    endforeach;
    AlmostGood := [X.Polys | X In AlmostGoodList];
//  EndUsing;
  return [BackToOrigRing(PolyList) | PolyList in AlmostGood];
EndDefine; -- AlmostGoodSetOfConditions



--------------------------------
define ExampleTitle(str)
  return "\n------<   Example: " + str + "   >------\n";
enddefine; -- ExampleTitle
  

------[   Auxiliary functions   ]--------

define X(AB)
  -- Computes the component x of the vector AB
  A := AB[1];  B := AB[2];
  return B[1]-A[1];
EndDefine; -- X

define Y(AB)
  -- Computes the component y of the vector AB
  A := AB[1];  B := AB[2];
  return B[2]-A[2];
EndDefine; -- Y


EndPackage; -- contrib/thmproving
