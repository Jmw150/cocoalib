\documentclass[a4paper]{mybook}
\ifx\pdfoutput\undefined % if we're not running pdftex
\else
\usepackage{hyperref}
\hypersetup{
  pdfpagelayout=OneColumn,
  pdfstartview      = FitH,%     % La page prend toute la largeur}
%  bookmarks, 
  bookmarksopenlevel = 1,
%  bookmarksnumbered,
%  pagecolor = {green},
  colorlinks = {true},
  linkcolor = {blue},
  naturalnames,
}
\fi
\usepackage[usenames,dvipsnames]{color}
\usepackage{fancyvrb} % coloured boxes around verbatim region
\usepackage{supertabular} % page breaks in supertabular
\usepackage{amsfonts}
\usepackage{longtable}

\def\cocoa{{CoCoA}}
\newenvironment{command}{}{} % does nothing: may be useful for debugging
\newcommand\SeeAlso{\par\textcolor{OrangeRed}{\textbf{\large See Also: }}}

\title{\Huge{\textsf{{\cocoa-}5.4.0\\Manual}}}

\author{John Abbott and Anna M. Bigatti}


\setcounter{secnumdepth}{1} 
\setcounter{tocdepth}{1} 

\setlength{\textwidth}{17cm}
\setlength{\oddsidemargin}{-.5cm}
\setlength{\evensidemargin}{-.5cm}

\setlength{\textheight}{24cm}
\setlength{\topmargin}{-1.5cm}

\setlength{\parskip}{4pt}
\setlength{\parindent}{0pt}

\tolerance=5000

\renewcommand{\thechapter}{\thepart-\arabic{chapter}}

\begin{document}

\maketitle

\tableofcontents





% -- NEW PART  --------------------------------
\part{Alphabetical List of Commands}
\setcounter{chapter}{-1}


\chapter{Special Characters}  %----=== CHAPTER LETTER ===----
\label{Special Characters}

\section{operators, shortcuts}
\label{operators, shortcuts}
\begin{command} % -- COMMAND: operators, shortcuts ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
A := B         A: variable, B: OBJECT  assignment
A ::= K[...]   A: variable, K: RING    assignment special syntax for rings
A = B    A,B: OBJECT        returns BOOL
A <> B   A,B: OBJECT        returns BOOL
A < B    A,B: OBJECT        returns BOOL
A <= B   A,B: OBJECT        returns BOOL
A > B    A,B: OBJECT        returns BOOL
A >= B   A,B: OBJECT        returns BOOL
A >< B   A,B: LIST        returns LIST
A..B     A,B: INT           returns LIST 
A..B     A,B: RINGELEM (indets)  returns LIST 
[...]                       returns LIST
[..|..]                     returns LIST
I : J    I, J: IDEAL        returns IDEAL
L[N]     L: LIST, N: INT    returns OBJECT
S[N]     S: STRING, N: INT  returns STRING
M[i,j]   M: MAT, i,j: INT   returns RINGELEM
R.F      R: RECORD and F field name      returns OBJECT
R/I      R: RING, I: IDEAL  returns RING
***E***  E: expression      returns OBJECT
?S       S: STRING          prints manual
<< S     S: STRING          [OBSOLESCENT]
\end{Verbatim}


\subsection*{Description}

``\verb&A := B;&'' compute ``\verb&B&'' then assign the result to ``\verb&A&''
\par 
``\verb&A ::= <ring-spec>&''  for the special ring syntax (see ``\verb&NewPolyRing&'' (\ref{NewPolyRing} pg.\pageref{NewPolyRing}))
\par 
``\verb&A = B&''   test whether ``\verb&A&'' and ``\verb&B&'' are equal (see ``\verb&Order Comparison Operators&'' (\ref{Order Comparison Operators} pg.\pageref{Order Comparison Operators}))
\par 
``\verb&A <> B&''  test whether ``\verb&A&'' and ``\verb&B&'' are not equal (see ``\verb&Order Comparison Operators&'' (\ref{Order Comparison Operators} pg.\pageref{Order Comparison Operators}))
\par 
``\verb&A < B&''  test whether ``\verb&A&'' is smaller than ``\verb&B&'' (see ``\verb&Order Comparison Operators&'' (\ref{Order Comparison Operators} pg.\pageref{Order Comparison Operators}))
\par 
``\verb&A >< B&''  equivalent to ``\verb&CartesianProduct(A, B)&'', ``\verb&CartesianProductList([A,B])&''
\par 
``\verb&A..B&''    is the ``\verb&Range Operator&'' (\ref{Range Operator} pg.\pageref{Range Operator}) (see ``\verb&List Constructors&'' (\ref{List Constructors} pg.\pageref{List Constructors}))
\par 
``\verb&[...]&''   build a new list (see ``\verb&List Constructors&'' (\ref{List Constructors} pg.\pageref{List Constructors}))
\par 
``\verb&[..|..]&'' build a new list (see ``\verb&List Constructors&'' (\ref{List Constructors} pg.\pageref{List Constructors}))
\par 
``\verb&I : J&''   equivalent to ``\verb&colon(I, J)&''
\par 
``\verb&L[N]&''    access ``\verb&N&''-th entry of list ``\verb&L&'' (indexes start from 1)
\par 
``\verb&S[N]&''    access ``\verb&N&''-th char of string ``\verb&L&'' (indexes start from 1)
\par 
``\verb&M[i,j]&''  access entry ``\verb&i,j&'' in matrix ``\verb&M&''
\par 
``\verb&R.F&''     ``\verb&record field selector&'' (\ref{record field selector} pg.\pageref{record field selector}) for field named ``\verb&F&'' of record ``\verb&R&''
\par 
``\verb&R/I&''     equivalent to ``\verb&NewQuotientRing(R,I)&''
\par 
``\verb&***E***&'' interpret ``\verb&E&'' in ``\verb&CoCoA-4 mode&'' (\ref{CoCoA-4 mode} pg.\pageref{CoCoA-4 mode})
\par 
``\verb&$<< S$&''  OBSOLESCENT equivalent to ``\verb&source(S)&''
\par 
``\verb&? string&'' prints the manual page for ``\verb&string&'', or a list of matching manual pages

\SeeAlso %---- SEE ALSO ----
  colon(\ref{colon} pg.\pageref{colon}), 
    Equality Operator(\ref{Equality Operator} pg.\pageref{Equality Operator}), 
    Order Comparison Operators(\ref{Order Comparison Operators} pg.\pageref{Order Comparison Operators}), 
    List Constructors(\ref{List Constructors} pg.\pageref{List Constructors}), 
    CartesianProduct, CartesianProductList(\ref{CartesianProduct, CartesianProductList} pg.\pageref{CartesianProduct, CartesianProductList}), 
    NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing}), 
    NewQuotientRing(\ref{NewQuotientRing} pg.\pageref{NewQuotientRing}), 
    record field selector(\ref{record field selector} pg.\pageref{record field selector}), 
    Range Operator(\ref{Range Operator} pg.\pageref{Range Operator}), 
    source(\ref{source} pg.\pageref{source}), 
    Manual(\ref{Manual} pg.\pageref{Manual}), 
    Character Set and Special Symbols(\ref{Character Set and Special Symbols} pg.\pageref{Character Set and Special Symbols}), 
    CoCoA Operators: introduction(\ref{CoCoA Operators: introduction} pg.\pageref{CoCoA Operators: introduction})
\end{command} % -- end command --------------------------------

\chapter{A}  %----=== CHAPTER LETTER ===----
\label{A}

\section{abs}
\label{abs}
\begin{command} % -- COMMAND: abs ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
abs(N: INT): INT
abs(N: RAT): RAT
abs(N: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the absolute value of ``\verb&N&''.  If ``\verb&N&'' is a
``\verb&RINGELEM&'' then it must belong to an ordered ring.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  abs(-3);
3

/**/  abs(-2/3);
2/3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  sign(\ref{sign} pg.\pageref{sign})
\end{command} % -- end command --------------------------------

\section{adj}
\label{adj}
\begin{command} % -- COMMAND: adj ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
adj(M: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the classical adjoint of the square matrix ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[t,x,y,z];
/**/  adj(mat([[x,y,z],[t,y,x],[x,x^2,x*y]]));
matrix( /*RingWithID(44, "QQ[t,x,y,z]")*/
 [[-x^3 +x*y^2, -x*y^2 +x^2*z, x*y -y*z],
  [-t*x*y +x^2, x^2*y -x*z, -x^2 +t*z],
  [t*x^2 -x*y, -x^3 +x*y, -t*y +x*y]])

/**/   FF_5 := NewZZmod(5);
/**/   adj(matrix(FF_5, [[1,2],[3,1]]));
matrix( /*ZZ/(5)*/
 [[1, -2],
  [2, 1]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  inverse(\ref{inverse} pg.\pageref{inverse})
\end{command} % -- end command --------------------------------

\section{AffHilbert [OBSOLESCENT]}
\label{AffHilbert [OBSOLESCENT]}
\begin{command} % -- COMMAND: AffHilbert [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&AffHilbertFn&'' (\ref{AffHilbertFn} pg.\pageref{AffHilbertFn}).

\end{command} % -- end command --------------------------------

\section{AffHilbertFn}
\label{AffHilbertFn}
\begin{command} % -- COMMAND: AffHilbertFn ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
AffHilbertFn(R: (Poly or Quotient)RING): TAGGED("$hp.Hilbert")
AffHilbertFn(R: (Poly or Quotient)RING, N: INT): INT
\end{Verbatim}


\subsection*{Description}

The first form of this function computes the affine Hilbert function
for ``\verb&R&''.  The second form computes the ``\verb&N&''-th value of the affine
Hilbert function.  The weights of the indeterminates of ``\verb&R&'' must all
be 1.  For evaluating of the Hilbert function repeatedly, use the
function ``\verb&EvalHilbertFn&'' (\ref{EvalHilbertFn} pg.\pageref{EvalHilbertFn}) instead of ``\verb&AffHilbertFn(R, N)&'' in order
to speed up execution.
\par 
The coefficient ring must be a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  AffHilbertFn(R/ideal(z^4-1, x*z^4-y-3));
H(0) = 1
H(1) = 3
H(t) = 4t - 2   for t >= 2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  AffHilbertSeries(\ref{AffHilbertSeries} pg.\pageref{AffHilbertSeries}), 
    EvalHilbertFn(\ref{EvalHilbertFn} pg.\pageref{EvalHilbertFn}), 
    HilbertPoly(\ref{HilbertPoly} pg.\pageref{HilbertPoly}), 
    HVector(\ref{HVector} pg.\pageref{HVector}), 
    HilbertSeries(\ref{HilbertSeries} pg.\pageref{HilbertSeries})
\end{command} % -- end command --------------------------------

\section{AffHilbertSeries}
\label{AffHilbertSeries}
\begin{command} % -- COMMAND: AffHilbertSeries ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
AffHilbertSeries(R: (Poly or Quotient)RING): TAGGED("$hp.PSeries")
\end{Verbatim}


\subsection*{Description}

This function computes the affine Hilbert-Poincare series of ``\verb&M&''.
The grading must be a positive $Z^1$-grading (\textit{i.e.} ``\verb&GradingMat&'' (\ref{GradingMat} pg.\pageref{GradingMat})
must have a single row with positive entries), and the ordering must
be degree compatible.
In the standard case, \textit{i.e.} the weights of all
indeterminates are 1, the result is simplified so that the power
appearing in the denominator is the dimension of ``\verb&M&'' + 1.
\par 
It used to be called ``\verb&AffPoincare&''.
\par 
NOTES:
\par (i) the coefficient ring must be a field.
\par (ii) these functions produce tagged objects: they cannot safely be
     (non-)equality to other values.
\par 
For further details on affine Hilbert functions see the book:
Kreuzer, Robbiano "Computer Commutative Algebra II", Section 5.6.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  AffHilbertSeries(R/ideal(z^4-1, x*z^4-y-3));
(1 +x +x^2 +x^3) / (1-x)^2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  AffHilbertFn(\ref{AffHilbertFn} pg.\pageref{AffHilbertFn}), 
    HilbertSeries(\ref{HilbertSeries} pg.\pageref{HilbertSeries})
\end{command} % -- end command --------------------------------

\section{AffPoincare [OBSOLESCENT]}
\label{AffPoincare [OBSOLESCENT]}
\begin{command} % -- COMMAND: AffPoincare [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&AffHilbertSeries&'' (\ref{AffHilbertSeries} pg.\pageref{AffHilbertSeries}).

\end{command} % -- end command --------------------------------

\section{alias}
\label{alias}
\begin{command} % -- COMMAND: alias ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
alias B_1,...,B_r

where each B_i is a \textbf{binding} of the form: Identifier := $PackageName
\end{Verbatim}


\subsection*{Description}

This function is for declaring both global and local aliases for
package names.  Recall that package names are meant to be long in
order to avoid conflicts between the names of functions that are read
into a CoCoA session.  However, it is inconvenient to have to type out
the long package name when referencing a function.  So the user
chooses an alias to take the place of the package name; the alias is
just a means to avoid typing.
\par 
1.  Global aliases.  To avoid typing the full package name as a prefix
to package functions, one may declare a short global alias during a
CoCoA session.  A list of the global aliases is produced by the
function ``\verb&aliases&'' (\ref{aliases} pg.\pageref{aliases}).  For examples, see the chapter on packages in the
manual, in particular the section, ``Global Aliases'' (\ref{Global Aliases} pg.\pageref{Global Aliases}).  Online, enter
``\verb&?global aliases&''.
\par 
2.  Local aliases.  A local alias has the same syntax as a global
alias, however it appears inside a package definition.  The local
aliases work only inside the package and do not conflict with any
global aliases already defined.  In fact, in order to avoid conflicts,
global aliases are not recognized within a package.  For examples,
again look in the chapter for packages.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  alias LL := $abcd;
/**/  aliases();

Coclib       = $coclib
Approx       = $approx
(...)
TP           = $contrib/thmproving
TV           = $contrib/typevectors
LL           = $abcd
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  aliases(\ref{aliases} pg.\pageref{aliases}), 
    Introduction to Packages(\ref{Introduction to Packages} pg.\pageref{Introduction to Packages})
\end{command} % -- end command --------------------------------

\section{aliases}
\label{aliases}
\begin{command} % -- COMMAND: aliases ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
aliases(): TAGGED("aliases")
\end{Verbatim}


\subsection*{Description}

This function prints a list of global aliases for packages. Aliases
are formed with the function ``\verb&alias&'' (\ref{alias} pg.\pageref{alias}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  alias LL := $abcd;
/**/  aliases();

Coclib       = $coclib
Approx       = $approx
(...)
TP           = $contrib/thmproving
TV           = $contrib/typevectors
LL           = $abcd
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  alias(\ref{alias} pg.\pageref{alias}), 
    Introduction to Packages(\ref{Introduction to Packages} pg.\pageref{Introduction to Packages})
\end{command} % -- end command --------------------------------

\section{AllReducedGroebnerBases [OBSOLETE]}
\label{AllReducedGroebnerBases [OBSOLETE]}
\begin{command} % -- COMMAND: AllReducedGroebnerBases [OBSOLETE] ------------



\subsection*{Description}

Renamed to ``\verb&GroebnerFanIdeals&'' (\ref{GroebnerFanIdeals} pg.\pageref{GroebnerFanIdeals}).

\end{command} % -- end command --------------------------------

\section{AlmostQR}
\label{AlmostQR}
\begin{command} % -- COMMAND: AlmostQR ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
AlmostQR(M: MAT): RECORD
\end{Verbatim}


\subsection*{Description}

This function computes the decomposition of the matrix into an
orthogonal and an upper triangular matrix with 1 on the diagonal.
[\textbf{orthogonal} meaning that $Q^{T} * Q$ is a diagonal matrix]
\par 
The auxiliary (possibly slow!) function ``\verb&Mat.SimplifySquareFactorsInAQR&''
modifies ``\verb&Q&'' and ``\verb&R&'' in the decomposition so that the entries of the
diagonal matrix $Q^{T} * Q$ are squarefree rationals.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ M := matrix([ [4, -2, 3],  [3, 2, -2],  [0, 0, 3] ]);
/**/ Dec := AlmostQR(M);
/**/ indent(Dec);
record[
  Q := matrix(QQ,
 [[4, -42/25, 0],
  [3, 56/25, 0],
  [0, 0, 3]]),
  R := matrix(QQ,
 [[1, -2/25, 6/25],
  [0, 1, -17/14],
  [0, 0, 1]])
]

/**/  $mat.SimplifySquareFactorsInAQR(ref Dec);
/**/  indent(Dec);
record[
  Q := matrix(QQ,
 [[4/5, -3/5, 0],
  [3/5, 4/5, 0],
  [0, 0, 1]]),
  R := matrix(QQ,
 [[5, -2/5, 6/5],
  [0, 14/5, -17/5],
  [0, 0, 3]]),
  SqDiag := [1,  1,  1]
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Matrix Normal Form(\ref{Matrix Normal Form} pg.\pageref{Matrix Normal Form})
\end{command} % -- end command --------------------------------

\section{and}
\label{and}
\begin{command} % -- COMMAND: and ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
A and B
where A, B: BOOL; return BOOL
\end{Verbatim}


\subsection*{Description}

This operator represents the logical conjunction of ``\verb&A&'' and ``\verb&B&''.
CoCoA first evaluates ``\verb&A&''; if that gives ``\verb&false&'' then the result
is ``\verb&false&'', and ``\verb&B&'' is not evaluated.  Otherwise if ``\verb&A&'' gives ``\verb&true&''
then ``\verb&B&'' is evaluated, and its value is the final result.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  A := -1;
/**/  A >= 0 and FloorSqrt(A) < 10;  --> calls FloorSqrt only if A >= 0
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  or(\ref{or} pg.\pageref{or}), 
    not(\ref{not} pg.\pageref{not})
\end{command} % -- end command --------------------------------

\section{append}
\label{append}
\begin{command} % -- COMMAND: append ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
append(ref L: LIST, E: OBJECT)
\end{Verbatim}


\subsection*{Description}

Append the object ``\verb&E&'' to the list ``\verb&L&''; this call returns nothing!
\par 
NOTE: the old CoCoA-4 syntax ``\verb&Append(L, E)&'' is still allowed, but
produces a warning; replace the call by ``\verb&append(ref L, E)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[t,x,y,z];
/**/  L := [1,2,3];
/**/  append(ref L, 4);
/**/  L;
[1, 2, 3, 4]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ref(\ref{ref} pg.\pageref{ref}), 
    concat(\ref{concat} pg.\pageref{concat}), 
    ConcatLists(\ref{ConcatLists} pg.\pageref{ConcatLists}), 
    remove(\ref{remove} pg.\pageref{remove})
\end{command} % -- end command --------------------------------

\section{apply [OBSOLESCENT]}
\label{apply [OBSOLESCENT]}
\begin{command} % -- COMMAND: apply [OBSOLESCENT] ------------



\subsection*{Description}

To apply a homomorphism ``\verb&phi&'' to all elements in second argument ``\verb&X&''
(RINGELEM, LIST, or MAT)
just use normal "function call" syntax: ``\verb&phi(X)&''.
\par 
See also ``\verb&Introduction to RINGHOM&'' (\ref{Introduction to RINGHOM} pg.\pageref{Introduction to RINGHOM})
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  S ::= QQ[x[1..3]];
/**/  phi := PolyAlgebraHom(R, S, indets(S));
/**/  phi([x^2-y, z-2]);         -- was  apply(phi, [x^2-y, z-2])  up to 5.3.3
[x[1]^2 -x[2], x[3] -2]
/**/  phi(mat([[x,1], [y,z]]));  -- was  apply(phi, mat(...))   up to 5.3.3
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ApproxPointsNBM}
\label{ApproxPointsNBM}
\begin{command} % -- COMMAND: ApproxPointsNBM ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ApproxPointsNBM(P: RING, Pts: MAT, Toler: MAT): RECORD
\end{Verbatim}


\subsection*{Description}

This function returns a record containing four fields: namely,
``\verb&QuotientBasis&'', ``\verb&BBasis&'', ``\verb&AlmostVanishing&'' and ``\verb&StableBBasisFound&''.
\par 
The field ``\verb&QuotientBasis&'' contains a factor-closed set of
power-products, and the field ``\verb&AlmostVanishing&'' contains a list
of "almost vanishing" polynomials.  If the cardinality of the field
``\verb&QuotientBasis&'' is equal to the number of points, it is in fact a
"quotient basis" of the ideal of points, and in this case a
border basis founded on it is also returned in the field ``\verb&BBasis&''
and the field ``\verb&StableBBasisFound&'' is set to ``\verb&true&'' (otherwise
it is ``\verb&false&'').
\par 
The first argument is a list of points in k-dimensional space, and the
second argument is the list of k positive tolerances (one for each
dimension).  So that the answer can be represented, the current ring
must have at least k indeterminates; the term ordering is ignored as
it plays no role in determining the border basis.
\par 
Verbosity range 80-95 (80, 90, 95).
\par 
Thanks to John Abbott and Maria-Laura Torrente for the implementation.
For a full description of the algorithms we refer to the paper C.Fassino
\textbf{Almost Vanishing Polynomials for Sets of Limited Precision Points}
 (Journal of Symbolic Computation 45 (2010), 19--37).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ P ::= QQ[x,y];
/**/ Eps := [0.1, 0.1];
/**/ Points := [[10, 0], [-10, 0], [0, 10], [0, -10], [7, 7], [-7, -7]];
/**/ indent(ApproxPointsNBM(P, mat(Points), RowMat(Eps)));
record[
  AlmostVanishing := [x^2 +(2/49)*x*y +y^2 -100,
                      x*y^2 +(49/51)*y^3 +(-4900/51)*y, y^4 +51*x*y -100*y^2],
  BBasis := [x^2 +(2/49)*x*y +y^2 -100, x*y^2 +(49/51)*y^3 +(-4900/51)*y,
             x^2*y +(49/51)*y^3 +(-4900/51)*y, y^4 +51*x*y -100*y^2, x*y^3 -49*x*y],
  QuotientBasis := [1, y, x, y^2, x*y, y^3],
  StableBBasisFound := true
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IdealOfPoints(\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}), 
    StableBBasis5(\ref{StableBBasis5} pg.\pageref{StableBBasis5})
\end{command} % -- end command --------------------------------

\section{ApproxSolve}
\label{ApproxSolve}
\begin{command} % -- COMMAND: ApproxSolve ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ApproxSolve(L: LIST of RINGELEM): RECORD
\end{Verbatim}


\subsection*{Description}

This function returns approximations to the real solutions (points) of a
0-dimensional polynomial system ``\verb&L&'': these approximations are
given as a LIST of LISTs of rationals in the field ``\verb&AffinePts&'';
the field ``\verb&indets&'' gives the indets corresponding to the positions
in the coordinates of each solution.
\par 
The polynomials in ``\verb&L&'' must have rational coefficients.
Approximate coordinates are given for non-rational solutions.
A heuristic is used to determine the precision (which may vary
depending on each solution point).
\par 
Useful verbosity range 20--20.
\par 
See also ``\verb&RationalSolve&'' (\ref{RationalSolve} pg.\pageref{RationalSolve}) which finds all solutions all of whose
coordinates are rational.
\par 
NOTE: up to version 5.3.2 the output was just the LIST of solutions.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  L := [x^3-y^2+z-1, x-2, (y-3)*(y+2)];
/**/  RationalSolve(L);
record[AffinePts := [[2, -2, -3], [2, 3, 2]], indets = [x,y,z]]
/**/  ApproxSolve(L);
record[AffinePts := [[2, -2, -3], [2, 3, 2]], indets = [x,y,z]]

/**/  L := [x^3-y^2+z-1, x^2-2, (y-3)*(y+2)];
/**/  AS := ApproxSolve(L);
--> use FloatStr or DecimalStr to make result more readable
/**/  indent([[ FloatStr(coord) | coord in pt] | pt in AS.AffinePts]);
[
  ["1.4142",  "-2.0000",  "2.1716"],
  ["-1.4142",  "-2.0000",  "7.8284"],
  ["1.4142",  "3.0000",  "7.1716"],
  ["-1.4142",  "3.0000",  "12.828"]
]

-- Verify we have an approximate answer:
/**/  indent([ [ FloatStr(eval(f, pt)) | f in L ] | pt in AS.AffinePts]);
[
  ["7.1576*10^(-19)",  "5.0612*10^(-19)",  "0.0000"],
  ["-7.1576*10^(-19)",  "5.0612*10^(-19)",  "0.0000"],
  ["2.8208*10^(-19)",  "1.9946*10^(-19)",  "0.0000"],
  ["-2.8208*10^(-19)",  "1.9946*10^(-19)",  "0.0000"]
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LinSolve(\ref{LinSolve} pg.\pageref{LinSolve}), 
    RationalSolve(\ref{RationalSolve} pg.\pageref{RationalSolve})
\end{command} % -- end command --------------------------------

\section{AreGensMonomial}
\label{AreGensMonomial}
\begin{command} % -- COMMAND: AreGensMonomial ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
AreGensMonomial(I: IDEAL): BOOL
\end{Verbatim}


\subsection*{Description}

This function checks if the \textbf{given generators} for ``\verb&I&'' are
monomial, and stores this information in ``\verb&I&'': this is useful if
it has thousands of generators and we want to know if we can use
special algorithms for monomial generators.
\par 
NOTE: this function return false if at least one generator in ``\verb&gens(I)&'' 
is not monomial even if \textbf{there exits} another set of generators
which are monomial.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x[1..100]];
/**/  AreGensMonomial(ideal(x[1], x[1]+x[2]));
false

/**/  I := ideal(support(sum(indets(P))^3));
/**/  t0 := CpuTime(); AreGensMonomial(I); TimeFrom(t0);
true
0.040
/**/  t0 := CpuTime(); AreGensMonomial(I); TimeFrom(t0);
true
0.000
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  AreGensSqFreeMonomial(\ref{AreGensSqFreeMonomial} pg.\pageref{AreGensSqFreeMonomial}), 
    IsTerm(\ref{IsTerm} pg.\pageref{IsTerm}), 
    HasGBasis(\ref{HasGBasis} pg.\pageref{HasGBasis})
\end{command} % -- end command --------------------------------

\section{AreGensSqFreeMonomial}
\label{AreGensSqFreeMonomial}
\begin{command} % -- COMMAND: AreGensSqFreeMonomial ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
AreGensSqFreeMonomial(I: IDEAL): BOOL
\end{Verbatim}


\subsection*{Description}

This function checks if the \textbf{given generators} for ``\verb&I&'' are
monomial and square-free, and stores this information in ``\verb&I&'':
this is useful if it has thousands of generators and we want to know
if we can use special algorithms for square-free monomial generators.
\par 
NOTE: this function returns ``\verb&true&'' only if the given generators
(\textit{i.e.} those from ``\verb&gens(I)&'') are all square-free monomials,
regardless of whether \textbf{there exists another} set of generators which are
all square-free monomials.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  AreGensSqFreeMonomial(ideal(x, y));
true
/**/  AreGensSqFreeMonomial(ideal(x, x^2));
false
/**/  AreGensSqFreeMonomial(ideal(x, x+y));
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  AreGensMonomial(\ref{AreGensMonomial} pg.\pageref{AreGensMonomial}), 
    IsSqFree(\ref{IsSqFree} pg.\pageref{IsSqFree}), 
    HasGBasis(\ref{HasGBasis} pg.\pageref{HasGBasis})
\end{command} % -- end command --------------------------------

\section{ArrBettiNumbers}
\label{ArrBettiNumbers}
\begin{command} % -- COMMAND: ArrBettiNumbers ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrBettiNumbers(A: LIST): LIST 
\end{Verbatim}


\subsection*{Description}

This function returns the list ``\verb&[b_0,b_1,...,b_l]&'' of the Betti numbers
from the list ``\verb&A&'' of hyperplanes in the arrangement.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, x-y, y];
/**/ ArrBettiNumbers(A);
[1,  3,  2]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrBoolean}
\label{ArrBoolean}
\begin{command} % -- COMMAND: ArrBoolean ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrBoolean(S: RING, k: INT): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the boolean arrangement in the first ``\verb&k&''
variables of the polynomial ring ``\verb&S&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ ArrBoolean(S, 3);
[x,  y,  z]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrBraid}
\label{ArrBraid}
\begin{command} % -- COMMAND: ArrBraid ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrBraid(S: RING, k: INT): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the braid arrangement in the first k variables of the polynomial ring S.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ ArrBraid(S, 3);
[x -y,  x -z,  y -z]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrCatalanA}
\label{ArrCatalanA}
\begin{command} % -- COMMAND: ArrCatalanA ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrCatalanA(S: RING, k: INT): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the Catalan arrangement of type A in the first k variables of the polynomial ring S.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ ArrCatalanA(S, 2);
[x -y,  x -y -1,  x -y +1]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrCatalanB}
\label{ArrCatalanB}
\begin{command} % -- COMMAND: ArrCatalanB ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrCatalanB(S: RING, k: INT): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the Catalan arrangement of type B in the first k variables of the polynomial ring S.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ ArrCatalanB(S, 2);
[x,  y,  x -y,  x +y,  x -1,  y -1,  x -y -1,  x +y -1,  x +1,  y +1,  x -y +1,  x +y +1]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrCatalanD}
\label{ArrCatalanD}
\begin{command} % -- COMMAND: ArrCatalanD ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrCatalanD(S: RING, k: INT): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the Catalan arrangement of type D in the first k variables of the polynomial ring S.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ ArrCatalanD(S, 2);
[x -y,  x +y,  x -y -1,  x +y -1,  x -y +1,  x +y +1]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrCharPoly}
\label{ArrCharPoly}
\begin{command} % -- COMMAND: ArrCharPoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrCharPoly(A: LIST): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the characteristic polynomial from the list A of hyperplanes in the arrangement in the variable t.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, x-y, y];
/**/ ArrCharPoly(A);
t^2 -3*t +2
/**/ RingOf(ArrCharPoly(A));
RingWithID(4, "QQ[t]")

/**/ use ZZ/(5)[x,y];	
/**/ A := [x, x-y, y];
/**/ ArrCharPoly(A);
t^2 -3*t +2
/**/ RingOf(ArrCharPoly(A));
RingWithID(4, "QQ[t]")
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ArrPoincarePoly(\ref{ArrPoincarePoly} pg.\pageref{ArrPoincarePoly}), 
    PosetCharPoly(\ref{PosetCharPoly} pg.\pageref{PosetCharPoly})
\end{command} % -- end command --------------------------------

\section{ArrCone}
\label{ArrCone}
\begin{command} % -- COMMAND: ArrCone ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrCone(A: LIST, t: RINGELEM): LIST 
\end{Verbatim}


\subsection*{Description}

This function returns the list of hyperplanes of the cone of the list
``\verb&A&'' of hyperplanes of an arrangement with respect to the
indeterminate ``\verb&t&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y,t];	
/**/ A := [x, x-1, y];
/**/ ArrCone(A, t);
[x,  x -t,  y,  t]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrDeletion}
\label{ArrDeletion}
\begin{command} % -- COMMAND: ArrDeletion ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrDeletion(A: LIST, H: RINGELEM): LIST 
\end{Verbatim}


\subsection*{Description}

This function returns the list of hyperplanes obtained by deleting
the hyperplane ``\verb&H&'' from the list ``\verb&A&'' of hyperplanes.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];
/**/ A := [x, x-1, y];
/**/ ArrDeletion(A, x-1);
[x,  y]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ArrRestriction(\ref{ArrRestriction} pg.\pageref{ArrRestriction})
\end{command} % -- end command --------------------------------

\section{ArrDerMod [OBSOLESCENT]}
\label{ArrDerMod [OBSOLESCENT]}
\begin{command} % -- COMMAND: ArrDerMod [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&ArrDerModule&'' (\ref{ArrDerModule} pg.\pageref{ArrDerModule}).

\end{command} % -- end command --------------------------------

\section{ArrDerModule}
\label{ArrDerModule}
\begin{command} % -- COMMAND: ArrDerModule ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrDerModule(Q: RINGELEM): MAT 
\end{Verbatim}


\subsection*{Description}

This function returns the matrix whose columns are a set of generators of the module of logarithmic derivations of an arrangement of hyperplanes described by its defining equation Q.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, x-y, y];
/**/ Q_A := product(A);	
/**/ ArrDerModule(Q_A);
matrix( /*RingWithID(70, "QQ[x,y]")*/
 [[x, 0],
  [y, x*y -y^2]])

/**/ use QQ[x,y,z];    
/**/ A := [x, x+z, y, 2*y-3*z];
/**/ ArrDerModule(product(A));
matrix( /*RingWithID(78, "QQ[x,y,z]")*/
 [[x, 0, 0, 0],
  [y, y^2 +(-3/2)*y*z, 0, x*y +y*z],
  [z, 0, x*y +(-3/2)*x*z +y*z +(-3/2)*z^2, x*z +z^2]])	
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ArrExponents(\ref{ArrExponents} pg.\pageref{ArrExponents}), 
    IsArrFree(\ref{IsArrFree} pg.\pageref{IsArrFree})
\end{command} % -- end command --------------------------------

\section{ArrExponents}
\label{ArrExponents}
\begin{command} % -- COMMAND: ArrExponents ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrExponents(Q: RINGELEM): LIST 
\end{Verbatim}


\subsection*{Description}

This function returns the list of exponents of a free arrangement of hyperplanes from its defining equation Q.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, x-y, y]; -- free
/**/ Q_A := product(A);	
/**/ ArrExponents(Q_A);
[1,  2]
	
/**/ use QQ[x,y,z];    
/**/ A := [x, x+z, y, 2*y-3*z]; -- not free
/**/ IsArrFree(product(A)); --> false
-- /**/ ArrExponents(product(A));  --> !!! ERROR !!! as expected, not free
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ArrDerModule(\ref{ArrDerModule} pg.\pageref{ArrDerModule}), 
    IsArrFree(\ref{IsArrFree} pg.\pageref{IsArrFree})
\end{command} % -- end command --------------------------------

\section{ArrFlats}
\label{ArrFlats}
\begin{command} % -- COMMAND: ArrFlats ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrFlats(A: LIST): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the list of flats from the list ``\verb&A&'' of hyperplanes
in the arrangement.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, x-y, y];
/**/ ArrFlats(A);
[[ideal(0)],  [ideal(x),  ideal(x -y),  ideal(y)],  [ideal(x,  y)]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ArrLattice(\ref{ArrLattice} pg.\pageref{ArrLattice})
\end{command} % -- end command --------------------------------

\section{ArrGraphical}
\label{ArrGraphical}
\begin{command} % -- COMMAND: ArrGraphical ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrGraphical(S: RING, edgesG: LIST): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the graphical arrangement with respect to the
list of edges edgesG of the graph G in the polynomial ring S.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ ArrGraphical(S, [[1,2],[1,3]]);
[x -y,  x -z]

/**/ use S::=QQ[x[1..3]];	
/**/ ArrGraphical(S, [[1,2],[1,3]]);
[x[1] -x[2],  x[1] -x[3]]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrLattice}
\label{ArrLattice}
\begin{command} % -- COMMAND: ArrLattice ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrLattice(A: LIST): LIST of LIST 
\end{Verbatim}


\subsection*{Description}

This function returns the list of relations of the lattice from the
list A of hyperplanes in the arrangement.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, x-y, y];
/**/ ArrLattice(A);
[[1,  2],  [1,  3],  [1,  4],  [2,  5],  [3,  5],  [4,  5]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ArrFlats(\ref{ArrFlats} pg.\pageref{ArrFlats})
\end{command} % -- end command --------------------------------

\section{ArrPoincarePoly}
\label{ArrPoincarePoly}
\begin{command} % -- COMMAND: ArrPoincarePoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrPoincarePoly(A: LIST): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the Poincare polynomial from the list A of
hyperplanes in the arrangement in the variable t.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, x-y, y];
/**/ ArrPoincarePoly(A);
2*t^2 +3*t +1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PosetPoincarePoly(\ref{PosetPoincarePoly} pg.\pageref{PosetPoincarePoly}), 
    ArrCharPoly(\ref{ArrCharPoly} pg.\pageref{ArrCharPoly})
\end{command} % -- end command --------------------------------

\section{ArrRestriction}
\label{ArrRestriction}
\begin{command} % -- COMMAND: ArrRestriction ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrRestriction(A: LIST, H: RINGELEM): LIST 
\end{Verbatim}


\subsection*{Description}

This function returns the list of hyperplanes in the variables
[y[1],..,y[n]] obtained by restricting to the hyperplane H of the list A of hyperplanes of an arrangement.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y,z];	
/**/ A := [x, x-z, y-z, z];
/**/ ArrRestriction(A, y-z);
[y[1],  y[1] -y[2],  y[2]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  MultiArrRestrictionZiegler(\ref{MultiArrRestrictionZiegler} pg.\pageref{MultiArrRestrictionZiegler})
\end{command} % -- end command --------------------------------

\section{ArrShiA}
\label{ArrShiA}
\begin{command} % -- COMMAND: ArrShiA ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrShiA(S: RING, k: INT): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the Shi arrangement of type A in the first k variables of the polynomial ring S.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ ArrShiA(S, 3);
[x -y,  x -z,  y -z,  x -y -1,  x -z -1,  y -z -1]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrShiB}
\label{ArrShiB}
\begin{command} % -- COMMAND: ArrShiB ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrShiB(S: RING, k: INT): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the Shi arrangement of type B in the first k variables of the polynomial ring S.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ ArrShiB(S, 2);
[x,  y,  x -y,  x +y,  x -1,  y -1,  x -y -1,  x +y -1]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrShiCatalanA}
\label{ArrShiCatalanA}
\begin{command} % -- COMMAND: ArrShiCatalanA ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrShiCatalanA(S: RING, k: INT, L: LIST): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the Shi-Catalan arrangement of type A in the first k variables of the polynomial ring S with multiplicities L[1] and L[2].
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ L:=[-1,2];
/**/ ArrShiCatalanA(S, 3, L);
[x -y,  x -z,  y -z,  x -y -1,  x -z -1,  y -z -1,  x -y +1,  x -y +2,  x -z +1,  x -z +2,  y -z +1,  y -z +2]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrShiCatalanB}
\label{ArrShiCatalanB}
\begin{command} % -- COMMAND: ArrShiCatalanB ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrShiCatalanB(S: RING, k: INT, L: LIST): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the Shi-Catalan arrangement of type B in the first k variables of the polynomial ring S with multiplicities L[1] and L[2].
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];
/**/ L:=[-1,2];	
/**/ ArrShiCatalanB(S, 2, L);
[x,  y,  x -y,  x +y,  x -1,  y -1,  x -y -1,  x +y -1,  x +1,  x +2,  y +1,  y +2,  x -y +1,  x -y +2,  x +y +1,  x +y +2]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrShiCatalanD}
\label{ArrShiCatalanD}
\begin{command} % -- COMMAND: ArrShiCatalanD ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrShiCatalanD(S: RING, k: INT, L: LIST): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the Shi-Catalan arrangement of type D in the first k variables of the polynomial ring S with multiplicities L[1] and L[2].
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ L:=[-1,2];
/**/ ArrShiCatalanD(S, 2, L);
[x -y,  x +y,  x -y -1,  x +y -1,  x -y +1,  x -y +2,  x +y +1,  x +y +2]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrShiD}
\label{ArrShiD}
\begin{command} % -- COMMAND: ArrShiD ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrShiD(S: RING, k: INT): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the Shi arrangement of type D in the first k variables of the polynomial ring S.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ ArrShiD(S, 2);
[x -y,  x +y,  x -y -1,  x +y -1]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrSignedGraphical}
\label{ArrSignedGraphical}
\begin{command} % -- COMMAND: ArrSignedGraphical ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrSignedGraphical(S: RING, PositiveEdgesG: LIST, PositiveEdgesG: LISTedgesG: LIST, loopsG: LIST): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the signed graphical arrangement with respect
to the list of positive edges ``\verb&PositiveEdgesG&'', of negative edges
``\verb&NegativeEdgesG&'' and of loops ``\verb&loopsG&'' of the signed graph ``\verb&G&''
in the polynomial ring ``\verb&S&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ ArrSignedGraphical(S, [[1,2],[1,3]],[[2,3]],[1,3]);
[x -y,  x -z,  y +z,  x,  z]

/**/ use S::=QQ[x[1..3]];	
/**/ ArrSignedGraphical(S, [[1,2],[1,3]],[[2,3]],[1,3]);
[x[1] -x[2],  x[1] -x[3],  x[2] +x[3],  x[1],  x[3]]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrToMultiArr}
\label{ArrToMultiArr}
\begin{command} % -- COMMAND: ArrToMultiArr ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrToMultiArr(A: LIST, L: LIST): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the multiarrangement obtained from the
arrangement A with respect to the list of multiplicities L.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y,z];
/**/ A := [x, y, z];
/**/ ArrToMultiArr(A, [1, 3, 2]);
[[x,  1],  [y,  3],  [z,  2]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  MultiArrToArr(\ref{MultiArrToArr} pg.\pageref{MultiArrToArr}), 
    MultiArrRestrictionZiegler(\ref{MultiArrRestrictionZiegler} pg.\pageref{MultiArrRestrictionZiegler})
\end{command} % -- end command --------------------------------

\section{ArrTuttePoly}
\label{ArrTuttePoly}
\begin{command} % -- COMMAND: ArrTuttePoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrTuttePoly(A: LIST): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the Tutte polynomial from the list A of
hyperplanes in the arrangement in the ring QQ[t[1],t[2]].

\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, x-y, y];
/**/ ArrTuttePoly(A);
t[1]^2 +t[1] +t[2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ArrPoincarePoly(\ref{ArrPoincarePoly} pg.\pageref{ArrPoincarePoly}), 
    ArrCharPoly(\ref{ArrCharPoly} pg.\pageref{ArrCharPoly})
\end{command} % -- end command --------------------------------

\section{ArrTypeB}
\label{ArrTypeB}
\begin{command} % -- COMMAND: ArrTypeB ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrTypeB(S: RING, k: INT): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the reflection arrangement of type B in the first k variables of the polynomial ring S.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ ArrTypeB(S, 3);
[x,  y,  z,  x -y,  x +y,  x -z,  x +z,  y -z,  y +z]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArrTypeD}
\label{ArrTypeD}
\begin{command} % -- COMMAND: ArrTypeD ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArrTypeD(S: RING, k: INT): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the reflection arrangement of type D in the first k variables of the polynomial ring S.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use S::=QQ[x,y,z];	
/**/ ArrTypeD(S, 3);
[x -y,  x +y,  x -z,  x +z,  y -z,  y +z]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ArtinianOrlikTeraoIdeal}
\label{ArtinianOrlikTeraoIdeal}
\begin{command} % -- COMMAND: ArtinianOrlikTeraoIdeal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ArtinianOrlikTeraoIdeal(A: LIST): IDEAL 
\end{Verbatim}


\subsection*{Description}

This function returns the artinian Orlik-Terao ideal of the list A of hyperplanes of an arrangement.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, y, x-y];
/**/ ArtinianOrlikTeraoIdeal(A);
ideal(y[1]*y[2] +y[1]*y[3] -y[2]*y[3],  y[1]^2,  y[2]^2,  y[3]^2)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  SolomonTeraoIdeal(\ref{SolomonTeraoIdeal} pg.\pageref{SolomonTeraoIdeal}), 
    OrlikTeraoIdeal(\ref{OrlikTeraoIdeal} pg.\pageref{OrlikTeraoIdeal})
\end{command} % -- end command --------------------------------

\section{ascii}
\label{ascii}
\begin{command} % -- COMMAND: ascii ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ascii(N: INT): STRING
ascii(L: LIST of INT): STRING
ascii(S: STRING): LIST of INT
\end{Verbatim}


\subsection*{Description}

In the first form, ``\verb&ascii&'' returns the character whose ASCII code is ``\verb&N&''.
\par 
In the second form, ``\verb&ascii&'' returns the string whose characters, in
order, have the ASCII codes listed in ``\verb&L&''.
\par 
The third form is the inverse of the second: it returns the ASCII codes
of the characters in ``\verb&S&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  ascii(97);
a

/**/  C := ascii("hello world");
/**/  C;
[104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]

/**/  ascii(C);
hello world
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{AsINT}
\label{AsINT}
\begin{command} % -- COMMAND: AsINT ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
AsINT(N: INT): INT
AsINT(N: RAT): INT
AsINT(N: RINGELEM): INT
\end{Verbatim}


\subsection*{Description}

If the argument is an integer value this function returns this value as
an INT, otherwise it throws an error.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y];
/**/  type(LC(3*x-y));
RINGELEM
/**/ type(AsINT(LC(3*x-y)));
INT
-- /**/ type(AsINT(LC((3/2)*x-y)));  --> !!! ERROR !!! as expected
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  AsRAT(\ref{AsRAT} pg.\pageref{AsRAT})
\end{command} % -- end command --------------------------------

\section{AsRAT}
\label{AsRAT}
\begin{command} % -- COMMAND: AsRAT ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
AsRAT(N: INT): RAT
AsRAT(N: RAT): RAT
AsRAT(N: RINGELEM): RAT
\end{Verbatim}


\subsection*{Description}

If the argument is a rational value this function returns this value as
a RAT, otherwise it throws an error.  Note that if the argument is
actually an integer the result is nevertheless a RAT (with denominator 1).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y];
/**/  type(LC(3*x-y));
RINGELEM
/**/ type(AsRAT(LC(3*x-y)));
RAT
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  AsINT(\ref{AsINT} pg.\pageref{AsINT})
\end{command} % -- end command --------------------------------

\section{assert}
\label{assert}
\begin{command} % -- COMMAND: assert ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
assert(cond: BOOL)
\end{Verbatim}


\subsection*{Description}

This function \textbf{always evaluates} its argument.  If the argument is
not ``\verb&true&'' then an exception is thrown.  This function is
intended for use only during development, and should not be used in
released code.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  define fn(X)
/**/    assert(X > 0);
/**/    return FloorSqrt(X);
/**/  enddefine;

/**/  fn(3);
1
-- /**/  fn(-3); --> !!! ERROR !!! "assertion failed", as expected
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  error(\ref{error} pg.\pageref{error})
\end{command} % -- end command --------------------------------

\chapter{B}  %----=== CHAPTER LETTER ===----
\label{B}

\section{BaseRing}
\label{BaseRing}
\begin{command} % -- COMMAND: BaseRing ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
BaseRing(RmodI: (Quotient)RING): RING
BaseRing(K: (Fraction Field)RING): RING
\end{Verbatim}


\subsection*{Description}

This function gives the "base ring" of a given ring; \textit{e.g.} if ``\verb&K&''
was constructed as the fraction field of ``\verb&R&'' then ``\verb&BaseRing(K)&''
produces ``\verb&R&'', if ``\verb&K&'' was constructed as a quotient ``\verb&R/I&'' then
``\verb&BaseRing(K)&'' produces ``\verb&R&'' (see also ``\verb&DefiningIdeal&'' (\ref{DefiningIdeal} pg.\pageref{DefiningIdeal})).
\par 
All rings in CoCoA are derived from ``\verb&ZZ&'' via various steps;
``\verb&BaseRing&'' gives the ring which is one step closer to ``\verb&ZZ&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Fpx ::= ZZ/(7)[x];
/**/  Fp := BaseRing(Fpx); --> ZZ/(7)
/**/  BaseRing(Fp) = ZZ;
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewFractionField(\ref{NewFractionField} pg.\pageref{NewFractionField}), 
    NewQuotientRing(\ref{NewQuotientRing} pg.\pageref{NewQuotientRing}), 
    DefiningIdeal(\ref{DefiningIdeal} pg.\pageref{DefiningIdeal}), 
    NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing})
\end{command} % -- end command --------------------------------

\section{BBasis5}
\label{BBasis5}
\begin{command} % -- COMMAND: BBasis5 ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
BBasis5(I: IDEAL): LIST
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function is implemented in ApCoCoALib by Stefan Kaspar.
\par 
The function ``\verb&BBasis5&'' calls the CoCoAServer to compute
a Border Basis of zero dimensional ideal I.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x, y], DegLex;
/**/  I := ideal(x^2, x*y + y^2);
***** NOT YET IMPLEMENTED *****
  BBasis := BBasis5(I);
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{BettiDiagram}
\label{BettiDiagram}
\begin{command} % -- COMMAND: BettiDiagram ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
BettiDiagram(X: IDEAL or (quotient)RING or MODULE)
\end{Verbatim}


\subsection*{Description}

This function computes the ("Macaulay-style") Betti
diagram for ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[t,x,y,z];
/**/  I := ideal(x^2-y*t, x*y-z*t, x*y);
/**/  RES := res(I);
/**/  PrintRes(RES);
0 --> R(-5)^2 --> R(-4)^4 --> R(-2)^3
/**/  B := BettiDiagram(RES);  indent(B);
record[
  Diagram := matrix(ZZ,
 [[3, 0, 0],
  [0, 4, 2]]),
  FirstShift := 2
]
/**/  PrintBettiDiagram(B);
        0    1    2
--------------------
 2:     3    -    -
 3:     -    4    2
--------------------
Tot:    3    4    2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BettiMatrix(\ref{BettiMatrix} pg.\pageref{BettiMatrix}), 
    PrintRes(\ref{PrintRes} pg.\pageref{PrintRes}), 
    PrintBettiDiagram(\ref{PrintBettiDiagram} pg.\pageref{PrintBettiDiagram}), 
    PrintBettiMatrix(\ref{PrintBettiMatrix} pg.\pageref{PrintBettiMatrix})
\end{command} % -- end command --------------------------------

\section{BettiMatrix}
\label{BettiMatrix}
\begin{command} % -- COMMAND: BettiMatrix ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
BettiMatrix(M: IDEAL|MODULE|LISTResolution)
\end{Verbatim}


\subsection*{Description}

This function returns the Betti matrix for ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[t,x,y,z];
/**/  I := ideal(x^2-y*t, x*y-z*t, x*y);
/**/  PrintRes(I);
0 --> R^2(-5) --> R^4(-4) --> R^3(-2)
/**/  BettiMatrix(I);
matrix(ZZ,
 [[0, 0, 0],
  [3, 0, 0],
  [0, 0, 0],
  [0, 4, 0],
  [0, 0, 2]])
/**/  PrintBettiMatrix(I);
--   -->  -->   --
    0    0    0
    0    0    3
    0    0    0
    0    4    0
    2    0    0
--   -->  -->   --
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PrintRes(\ref{PrintRes} pg.\pageref{PrintRes}), 
    PrintBettiDiagram(\ref{PrintBettiDiagram} pg.\pageref{PrintBettiDiagram})
\end{command} % -- end command --------------------------------

\section{BettiNumbers}
\label{BettiNumbers}
\begin{command} % -- COMMAND: BettiNumbers ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
BettiNumbers(M: IDEAL|MODULE|Resolution): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the Betti numbers for ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ M := MakeTermOrdMat(matrix([[5,5,5,1,1], [1,1,1,0,0]]));
/**/ P := NewPolyRing(QQ, "t[1],t[2],t[3],x,y", M, 2); -- ZZ^2-grading
/**/ use P;
/**/ I := ideal(t[1]^6 -t[3]^6, t[2]^6 -t[1]^5*t[3], t[1]*t[3]*x^8 -t[2]^2*y^8);
/**/ RES := res(P/I);
/**/ PrintRes(RES);
0 --> R[-78,-14] --> R[-48,-8]^2(+)R[-60,-12] --> R[-18,-2](+)R[-30,-6]^2 --> R

/**/ PrintBettiNumbers(RES);  --> just prints in a readable way
-- Betti 0 -----------
-- Betti 1 -----------
  [18,  2]: 1
  [30,  6]: 2
-- Betti 2 -----------
  [48,  8]: 2
  [60,  12]: 1
-- Betti 3 -----------
  [78,  14]: 1
----------------------

/**/ BettiNumbers(RES);  --> returns the value for further computations
[[],  [[[18,  2],  1],  [[30,  6],  2]],  [[[48,  8],  2],
 [[60,  12],  1]],  [[[78,  14],  1]]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PrintRes(\ref{PrintRes} pg.\pageref{PrintRes}), 
    BettiDiagram(\ref{BettiDiagram} pg.\pageref{BettiDiagram}), 
    BettiMatrix(\ref{BettiMatrix} pg.\pageref{BettiMatrix}), 
    PrintBettiNumbers(\ref{PrintBettiNumbers} pg.\pageref{PrintBettiNumbers})
\end{command} % -- end command --------------------------------

\section{binomial}
\label{binomial}
\begin{command} % -- COMMAND: binomial ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
binomial(N: INT, K: INT): INT
binomial(N: RINGELEM, K: INT): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function computes the binomial coefficient, \textbf{N choose K}
according to the formula $(N)(N-1)(N-2)...(N-K+1) / K!$
If ``\verb&K < 0&'' or ``\verb&K > abs(N)&'' the value is 0.
\par 
The same formula is used if ``\verb&N&'' is a ring element; in this case it
is an error if the integer ``\verb&K&'' is negative.  See the example below, to
see how to compute ``\verb&binomial(N,K)&'' where ``\verb&N&'' is a rational.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  binomial(4,2);
6

/**/  binomial(-4,3);
-20

/**/  N := 5/3;  // want to compute binomial(N,2)
/**/  AsRAT(binomial(RingElem(QQ,N), 2));  // trick: convert N to elem of QQ
5/9

/**/  use QQ[x,y];
/**/  binomial(x^2+2*y,3);
(1/6)*x^6 +x^4*y +(-1/2)*x^4 +2*x^2*y^2 -2*x^2*y +(4/3)*y^3 +(1/3)*x^2 -2*y^2 +(2/3)*y

/**/  It = (x^2+2*y)*(x^2+2*y-1)*(x^2+2*y-2)/6;
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BinomialRepr, BinomialReprShift(\ref{BinomialRepr, BinomialReprShift} pg.\pageref{BinomialRepr, BinomialReprShift})
\end{command} % -- end command --------------------------------

\section{BinomialRepr, BinomialReprShift}
\label{BinomialRepr, BinomialReprShift}
\begin{command} % -- COMMAND: BinomialRepr, BinomialReprShift ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
BinomialRepr(N: INT, K: INT): LIST of INT
BinomialReprShift(N: INT, K: INT, Up: INT, Down: INT): INT

where N and K are positive.
\end{Verbatim}


\subsection*{Description}

The function ``\verb&BinomialRepr&'' computes the ``\verb&K&''-binomial
representation of ``\verb&N&'', also called \textit{Macaulay representation},
\textit{i.e.} the unique expression
\begin{verbatim}
  N = binomial(N(K),K) + binomial(N(K-1),K-1) + ... + binomial(N(L),L)
\end{verbatim}
where $N(K) > ... > N(L) >= 1$, for some L.
The value returned is the list ``\verb&[N(t) | t in 1..K]&''
where N(t)=0 for all $t < L$.
\par 
The function call ``\verb&BinomialReprShift(N,K,up,down)&'' computes the integer
\begin{verbatim}
  binomial(N(K)  +up,    K+down) +
  binomial(N(K-1)+up,(K-1)+down) +
  ... +
  binomial(N(L)  +up,    L+down)
\end{verbatim}
It is useful in generalizations of Macaulay's theorem characterizing
Hilbert functions.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  BinRep := BinomialRepr(13,4);
/**/  BinRep;
[1, 3, 4, 5]

/**/  BinomialReprShift(13,4,1,1);
16
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  binomial(\ref{binomial} pg.\pageref{binomial})
\end{command} % -- end command --------------------------------

\section{block}
\label{block}
\begin{command} % -- COMMAND: block ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
block C_1; ... ; C_n EndBlock;

where each C_i is a command.
\end{Verbatim}


\subsection*{Description}

The ``\verb&block&'' command executes the commands as if they where one
command.  What this means in practice is that CoCoA will not print a
string of dashes after executing each ``\verb&C_i&''.  Thus, ``\verb&Block&'' is used
on-the-fly and not inside user-defined functions.  (It has nothing to
do with declaration of local variables, for instance, as one might
infer from some other computer languages.)  The following example
should make the use of ``\verb&Block&'' clear:
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Print "hello "; Print "world";
hello world
-------------------------------
/**/  Block
/**/    Print "hello ";
/**/    Print "world";
/**/  EndBlock;
hello world
-------------------------------
/**/  use QQ[x,y];
/**/  Block
/**/    PrintLn GCD([12, 24, 96]);
/**/    PrintLn LCM([12, 24, 96]);
/**/    PrintLn GCD([x+y, x^2-y^2]);
/**/    Print LCM([x+y, x^2-y^2]);
/**/  EndBlock;

12
96
x + y
x^2 - y^2
-------------------------------
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{BlockMat}
\label{BlockMat}
\begin{command} % -- COMMAND: BlockMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
BlockMat(LIST of LIST of MAT: L): MAT
\end{Verbatim}


\subsection*{Description}

This function creates a block matrix from a LIST of rows of matrices.
The following restrictions on the sizes of the matrices apply:
  in each row list: all matrices must have the same number of rows;
  for all row lists: the total number of columns must be the same.
\par 
The function ``\verb&BlockMat2x2&'' (\ref{BlockMat2x2} pg.\pageref{BlockMat2x2}) has a simpler syntax for a
2x2 block matrix.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  A := RowMat([1,2,3,4]);   B := RowMat([0,0]);
-- /**/ BlockMat2x2(A,B, B,A);  --> !!! ERROR !!! as expected
/**/  BlockMat([[A,B], [B,A]]);
matrix(QQ,
 [[1, 2, 3, 4, 0, 0],
  [0, 0, 1, 2, 3, 4]])
/**/  BlockMat([[A,B], [RowMat(1..6)]]);
matrix(QQ,
 [[1, 2, 3, 4, 0, 0],
  [1, 2, 3, 4, 5, 6]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ConcatHor(\ref{ConcatHor} pg.\pageref{ConcatHor}), 
    ConcatVer(\ref{ConcatVer} pg.\pageref{ConcatVer}), 
    ConcatHorList(\ref{ConcatHorList} pg.\pageref{ConcatHorList}), 
    ConcatVerList(\ref{ConcatVerList} pg.\pageref{ConcatVerList}), 
    ConcatDiag(\ref{ConcatDiag} pg.\pageref{ConcatDiag}), 
    ConcatAntiDiag(\ref{ConcatAntiDiag} pg.\pageref{ConcatAntiDiag}), 
    BlockMat2x2(\ref{BlockMat2x2} pg.\pageref{BlockMat2x2})
\end{command} % -- end command --------------------------------

\section{BlockMat2x2}
\label{BlockMat2x2}
\begin{command} % -- COMMAND: BlockMat2x2 ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
BlockMat2x2(A: MAT,B: MAT,C: MAT,D: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function creates a block matrix.  Each entry is a matrix.
Given A, B, C, D matrices, then ``\verb&BlockMat(A,B,C,D)&'' returns the matrix
\begin{verbatim}
                | A B |
                | C D |
\end{verbatim}
The obvious restrictions on the sizes of the matrices apply:
\par 
``\verb&NumRows(A) = NumRows(B)&''  and  ``\verb&NumRows(C) = NumRows(D)&'',
and
``\verb&NumCols(A) = NumCols(C)&''  and  ``\verb&NumCols(B) = NumCols(D)&''.
\par 
The function ``\verb&BlockMat&'' (\ref{BlockMat} pg.\pageref{BlockMat}) offers more flexibility, but
with a heavier syntax.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/    A := matrix([[1,2,3], [4,5,6]]);
/**/    B := matrix([[1,2], [3,4]]);
/**/    C := matrix([[1,1,1], [2,2,2], [3,3,3]]);
/**/    D := matrix([[4,4], [5,5], [6,6]]);
/**/    BlockMat2x2(A,B, C,D);
matrix(QQ,
 [[1, 2, 3, 1, 2],
  [4, 5, 6, 3, 4],
  [1, 1, 1, 4, 4],
  [2, 2, 2, 5, 5],
  [3, 3, 3, 6, 6]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ConcatHor(\ref{ConcatHor} pg.\pageref{ConcatHor}), 
    ConcatVer(\ref{ConcatVer} pg.\pageref{ConcatVer}), 
    ConcatDiag(\ref{ConcatDiag} pg.\pageref{ConcatDiag}), 
    ConcatAntiDiag(\ref{ConcatAntiDiag} pg.\pageref{ConcatAntiDiag}), 
    BlockMat(\ref{BlockMat} pg.\pageref{BlockMat})
\end{command} % -- end command --------------------------------

\section{Bool01}
\label{Bool01}
\begin{command} % -- COMMAND: Bool01 ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
Bool01(B: BOOL): INT
\end{Verbatim}


\subsection*{Description}

This function converts a boolean to an integer using the convention:
``\verb&false&'' becomes 0, and ``\verb&true&'' becomes 1.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Id4 := matrix([[Bool01(i=j) | i in 1..4] | j in 1..4]);
/**/  Id4;
matrix(QQ,
 [[1, 0, 0, 0],
  [0, 1, 0, 0],
  [0, 0, 1, 0],
  [0, 0, 0, 1]])
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{break}
\label{break}
\begin{command} % -- COMMAND: break ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
break
\end{Verbatim}


\subsection*{Description}

This command may be used only inside a loop statement (``\verb&for&'', ``\verb&foreach&'',
``\verb&repeat&'', or ``\verb&while&'').
\par 
When executed, the entire current loop statement is terminated, and
control passes to the command following the loop statement.  If you
just want to skip to the next iteration of the current loop statement
use instead ``\verb&continue&'' (\ref{continue} pg.\pageref{continue}).
\par 
In the case of nested loops ``\verb&break&'' leaves just the innermost loop
statement in which the ``\verb&break&'' statement appears.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  for i := 5 to 1 step -1 do
/**/    for j := 1 to 10 do
/**/      print j, " ";
/**/      if j = i then println; break; endif;
/**/    endfor;
/**/  endfor;
1 2 3 4 5
1 2 3 4
1 2 3
1 2
1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  continue(\ref{continue} pg.\pageref{continue}), 
    return(\ref{return} pg.\pageref{return}), 
    All CoCoA commands(\ref{All CoCoA commands} pg.\pageref{All CoCoA commands})
\end{command} % -- end command --------------------------------

\section{BringIn}
\label{BringIn}
\begin{command} % -- COMMAND: BringIn ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
BringIn(E: OBJECT): OBJECT
BringIn(R: RING, E: OBJECT): OBJECT
\end{Verbatim}


\subsection*{Description}

This function maps a polynomial (or a list, matrix of these) into the
current ring, or the ring ``\verb&R&'', preserving the names of the indeterminates.
Honestly, this is not-so-clean shortcut for creating and calling a
homomorphism.  (``\verb&Introduction to RINGHOM&'' (\ref{Introduction to RINGHOM} pg.\pageref{Introduction to RINGHOM}))
\par 
NOTE: this function is not implemented on IDEAL because might be
misleading: one might expect that bringing an ideal from ``\verb&K[x,y]&''
into ``\verb&K[x]&'' means eliminating ``\verb&y&''.  For this operation
call ``\verb&elim&'' (\ref{elim} pg.\pageref{elim}).
Instead, if you want to map the generators of the ideal type
``\verb&ideal(BringIn(R, gens(I)))&''.
\par 
-- Changing characteristic from non-0 to 0 is NOT YET IMPLEMENTED in CoCoA-5
When mapping from a ring of finite characteristic to one of zero
characteristic then consistent choices of image for the coefficients
are made (\textit{i.e.} if two coefficients are equal mod p then their images
will be equal).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  RR ::= QQ[x[1..4],z,y];
/**/  SS ::= ZZ[z,y,x[1..2]];
/**/  use RR;
/**/  F := (x[1]-y-z)^2;  F;
x[1]^2 -2*x[1]*z +z^2 -2*x[1]*y +2*z*y +y^2
/**/  BringIn(SS, F);
z^2 +2*z*y +y^2 -2*z*x[1] -2*y*x[1] +x[1]^2

/**/  use R ::= QQ[x,y,z];
/**/  F := (1/2)*x^3 + (34/567)*x*y*z - 890; -- poly with rational coefficients
/**/  use S ::= ZZ/(101)[x,y,z];
/**/  BringIn(F);
-50*x^3 -19*x*y*z +19
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Introduction to RINGHOM(\ref{Introduction to RINGHOM} pg.\pageref{Introduction to RINGHOM}), 
    PolyAlgebraHom(\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}), 
    QZP(\ref{QZP} pg.\pageref{QZP}), 
    ZPQ(\ref{ZPQ} pg.\pageref{ZPQ})
\end{command} % -- end command --------------------------------

\chapter{C}  %----=== CHAPTER LETTER ===----
\label{C}

\section{Call [OBSOLETE]}
\label{Call [OBSOLETE]}
\begin{command} % -- COMMAND: Call [OBSOLETE] ------------



\subsection*{Description}

[OBSOLETE] in CoCoA-5 functions can be used directly.
See ``FUNCTIONs are first class objects'' (\ref{FUNCTIONs are first class objects} pg.\pageref{FUNCTIONs are first class objects}).

\end{command} % -- end command --------------------------------

\section{CallOnGroebnerFanIdeals}
\label{CallOnGroebnerFanIdeals}
\begin{command} % -- COMMAND: CallOnGroebnerFanIdeals ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CallOnGroebnerFanIdeals(I: IDEAL, fn: FUNCTION)
\end{Verbatim}


\subsection*{Description}

Storing all the possible different (reduced) GBases in a Groebner
fan is practicable only for small examples; larger ideals may have
fans containing thousands or even millions of different Groebner bases.
Typically we are interested only in those bases satisfying a
certain property.
\par 
``\verb&CallOnGroebnerFanIdeals&'' calls the given function ``\verb&fn&'' successively
on the ideal ``\verb&I&'' mapped into different polynomial rings so that
the Groebner bases run though all possible distinct ones.  This approach
avoids storing all distinct possibilities in a big list.
\par 
Verbosity: see ``\verb&GroebnerFanIdeals&'' (\ref{GroebnerFanIdeals} pg.\pageref{GroebnerFanIdeals}).
\par 
NOTE: using this needs a little technical ability, but might make the
difference between getting an answer or filling up the RAM.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ -- print ord and GBasis if ideal I has GBases of length 3:
/**/ define PrintIfGBHasLen3(I)
/**/   if len(ReducedGBasis(I))=3 then
/**/     println OrdMat(RingOf(I));
/**/     indent(ReducedGBasis(I));
/**/   endif;
/**/ enddefine;

/**/ use R ::= QQ[a,b,c];
/**/ I := ideal(a^5+b^3+c^2-1, b^2+a^2+c-1, c^3+a^6+b^5-1);
/**/ SetVerbosityLevel(10);
/**/ CallOnGroebnerFanIdeals(I, PrintIfGBHasLen3);
******************************************************(....)
matrix(ZZ,
 [[3, 7, 7],
  [3, 6, 8],
  [0, 0, -1]])
[b^2+c+a^2-1,
 a^5+c^2-b*c-a^2*b+b-1,
 c^3+b*c^2+2*a^2*b*c+a^4*b-a*c^2+a*b*c+a^3*b-2*b*c-2*a^2*b-a*b+b+a-1]
*
matrix(ZZ,
 [[6, 7, 14],
  [6, 5, 15],
  [0, 0, -1]])
[c+b^2+a^2-1,
 -b^6-3*a^2*b^4-3*a^4*b^2+b^5+3*b^4+6*a^2*b^2+3*a^4-3*b^2-3*a^2,
 a^5+b^4+2*a^2*b^2+a^4+b^3-2*b^2-2*a^2]
******************************************************(....)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GroebnerFanIdeals(\ref{GroebnerFanIdeals} pg.\pageref{GroebnerFanIdeals}), 
    OrdMat(\ref{OrdMat} pg.\pageref{OrdMat}), 
    RingOf(\ref{RingOf} pg.\pageref{RingOf})
\end{command} % -- end command --------------------------------

\section{CanonicalBasis}
\label{CanonicalBasis}
\begin{command} % -- COMMAND: CanonicalBasis ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CanonicalBasis(F: MODULE): LIST of MODULEELEM
\end{Verbatim}


\subsection*{Description}

``\verb&CanonicalBasis(F)&'' return a list of the canonical basis elements
of the free module ``\verb&F&'': \textit{i.e.} the k-th element in the list is the
unit vector with a 1 in the k-th coordinate.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  F := NewFreeModule(R,2);
/**/  e := CanonicalBasis(F);
/**/  e[2];
[0, 1]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewFreeModule(\ref{NewFreeModule} pg.\pageref{NewFreeModule}), 
    gens(\ref{gens} pg.\pageref{gens}), 
    GensAsCols, GensAsRows(\ref{GensAsCols, GensAsRows} pg.\pageref{GensAsCols, GensAsRows})
\end{command} % -- end command --------------------------------

\section{CanonicalHom}
\label{CanonicalHom}
\begin{command} % -- COMMAND: CanonicalHom ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CanonicalHom(R: RING, S: RING): RINGHOM
\end{Verbatim}


\subsection*{Description}

CanonicalHom(R, S) -- where R and S are rings, gives the
canonical homomorphism from R to S.
Currently it works only on the most natural constructions:
\begin{verbatim}
ZZ -> S    QQ -> S
R -> R/I   R -> FractionFiels(R)
R -> R[x[1..N]]
\end{verbatim}
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  RmodI := NewQuotientRing(R, ideal(x^2-1));

/**/  phi := CanonicalHom(R, RmodI);
/**/  phi(x^3*y);
(x*y)
/**/  RingOf(It) = RmodI;
true

/**/  RingElem(RmodI, x^3*y);  -- same as phi(x^3*y)
			       -- internally computes CanonicalHom
(x*y)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewFractionField(\ref{NewFractionField} pg.\pageref{NewFractionField}), 
    NewQuotientRing(\ref{NewQuotientRing} pg.\pageref{NewQuotientRing}), 
    NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing}), 
    CanonicalHom(\ref{CanonicalHom} pg.\pageref{CanonicalHom}), 
    CoeffEmbeddingHom(\ref{CoeffEmbeddingHom} pg.\pageref{CoeffEmbeddingHom}), 
    QuotientingHom(\ref{QuotientingHom} pg.\pageref{QuotientingHom}), 
    PolyAlgebraHom(\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}), 
    PolyRingHom(\ref{PolyRingHom} pg.\pageref{PolyRingHom})
\end{command} % -- end command --------------------------------

\section{CanonicalRepr}
\label{CanonicalRepr}
\begin{command} % -- COMMAND: CanonicalRepr ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CanonicalRepr(f: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

Given an element ``\verb&f&'' in a quotient ring ``\verb&R/I&'' this function
returns a representative of ``\verb&f&'' in ``\verb&R&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[a];
/**/  RmodI := R/ideal(a^2-2);
/**/  use RmodI;
/**/  a^3;
(2*a)
/**/  RingOf(a^3);
RingWithID(9, "RingWithID(7)/ideal(a^2 -2)")
/**/  CanonicalRepr(a^3);
2*a
/**/  RingOf(CanonicalRepr(a^3));
RingWithID(7, "QQ[a]")
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewQuotientRing(\ref{NewQuotientRing} pg.\pageref{NewQuotientRing}), 
    DefiningIdeal(\ref{DefiningIdeal} pg.\pageref{DefiningIdeal})
\end{command} % -- end command --------------------------------

\section{CartesianProduct, CartesianProductList}
\label{CartesianProduct, CartesianProductList}
\begin{command} % -- COMMAND: CartesianProduct, CartesianProductList ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CartesianProduct(L1: LIST, L2: LIST, L3: LIST, ..): LIST
CartesianProductList(L: LIST of LIST): LIST
L1 >< L2
L1 >< L2 >< ... >< Ln

where each Li is a LIST
\end{Verbatim}


\subsection*{Description}

This command returns the list whose elements form the Cartesian product
of $L_1,...,L_n$.
\par 
For the N-fold product of a list with itself, one may use ``\verb&tuples&'' (\ref{tuples} pg.\pageref{tuples}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L1 := [1,2,3];
/**/  L2 := ["a","b"];
/**/  L1 >< L2 >< [5];  -- same as
/**/  CartesianProduct(L1, L2, [5]);  -- same as
/**/  CartesianProductList([L1, L2, [5]]);  -- this takes a list of lists
[[1, "a", 5], [1, "b", 5], [2, "a", 5], [2, "b", 5], [3, "a", 5], [3, "b", 5]]
-------------------------------
/**/  ChessBoard := (1..8)><(1..8);  -- Need brackets around 1..8 otherwise
                                           -- we get a parse error.
\end{Verbatim}

Be careful: in CoCoA the operator ``\verb&><&'' denotes cartesian product,
whereas the operator ``\verb&<>&'' is used for \textbf{not equal}.

\SeeAlso %---- SEE ALSO ----
  CoCoA Operators: introduction(\ref{CoCoA Operators: introduction} pg.\pageref{CoCoA Operators: introduction}), 
    operators, shortcuts(\ref{operators, shortcuts} pg.\pageref{operators, shortcuts}), 
    tuples(\ref{tuples} pg.\pageref{tuples}), 
    Equality Operator(\ref{Equality Operator} pg.\pageref{Equality Operator})
\end{command} % -- end command --------------------------------

\section{Cast [OBSOLETE]}
\label{Cast [OBSOLETE]}
\begin{command} % -- COMMAND: Cast [OBSOLETE] ------------



\subsection*{Description}

This old function is now obsolete.
These are the functions for casting:
\par 
To cast INT, RAT, STRING to a polynomial (and more in general
to a RINGELEM) use ``\verb&RingElem&'' (\ref{RingElem} pg.\pageref{RingElem}).
\par 
To cast RINGELEM to INT, RAT use ``\verb&AsINT&'' (\ref{AsINT} pg.\pageref{AsINT}), ``\verb&AsRAT&'' (\ref{AsRAT} pg.\pageref{AsRAT}).
\par 
To cast LIST to MAT use ``\verb&matrix&'' (\ref{matrix} pg.\pageref{matrix}).
To cast MAT to LIST use ``\verb&GetRows&'' (\ref{GetRows} pg.\pageref{GetRows}), ``\verb&GetCols&'' (\ref{GetCols} pg.\pageref{GetCols}).
\par 
To cast a MODULEELEM to LIST use ``\verb&compts&'' (\ref{compts} pg.\pageref{compts}).
\par 
To cast a MODULE to MAT use ``\verb&GensAsCols, GensAsRows&'' (\ref{GensAsCols, GensAsRows} pg.\pageref{GensAsCols, GensAsRows}).
To cast a MAT to MODULE use ``\verb&SubmoduleCols, SubmoduleRows&'' (\ref{SubmoduleCols, SubmoduleRows} pg.\pageref{SubmoduleCols, SubmoduleRows}).

\SeeAlso %---- SEE ALSO ----
  AsINT(\ref{AsINT} pg.\pageref{AsINT}), 
    AsRAT(\ref{AsRAT} pg.\pageref{AsRAT}), 
    gens(\ref{gens} pg.\pageref{gens}), 
    GensAsCols, GensAsRows(\ref{GensAsCols, GensAsRows} pg.\pageref{GensAsCols, GensAsRows}), 
    GetCols(\ref{GetCols} pg.\pageref{GetCols}), 
    GetRows(\ref{GetRows} pg.\pageref{GetRows}), 
    ideal(\ref{ideal} pg.\pageref{ideal}), 
    matrix(\ref{matrix} pg.\pageref{matrix}), 
    ModuleElem(\ref{ModuleElem} pg.\pageref{ModuleElem}), 
    RingElem(\ref{RingElem} pg.\pageref{RingElem}), 
    SubmoduleCols, SubmoduleRows(\ref{SubmoduleCols, SubmoduleRows} pg.\pageref{SubmoduleCols, SubmoduleRows})
\end{command} % -- end command --------------------------------

\section{ceil}
\label{ceil}
\begin{command} % -- COMMAND: ceil ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ceil(X: RAT): INT
\end{Verbatim}


\subsection*{Description}

This function returns the least integer greater than or equal to ``\verb&X&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  ceil(0.99);
1

/**/  ceil(0.01);
1

/**/  ceil(1);
1

/**/  ceil(-0.99);
0
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  floor(\ref{floor} pg.\pageref{floor}), 
    round(\ref{round} pg.\pageref{round}), 
    num(\ref{num} pg.\pageref{num}), 
    den(\ref{den} pg.\pageref{den}), 
    div(\ref{div} pg.\pageref{div})
\end{command} % -- end command --------------------------------

\section{CFApprox}
\label{CFApprox}
\begin{command} % -- COMMAND: CFApprox ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CFApprox(X: RAT, MaxRelErr: RAT): RAT
\end{Verbatim}


\subsection*{Description}

``\verb&CFApprox&'' finds the \textbf{simplest} continued fraction approximant
to ``\verb&X&'' which is within the maximum specified \textbf{relative error}.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  CFApprox(1.414213, 10^(-2));
17/12
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CFApproximants(\ref{CFApproximants} pg.\pageref{CFApproximants}), 
    ContFrac(\ref{ContFrac} pg.\pageref{ContFrac}), 
    SimplestRatBetween(\ref{SimplestRatBetween} pg.\pageref{SimplestRatBetween})
\end{command} % -- end command --------------------------------

\section{CFApproximants}
\label{CFApproximants}
\begin{command} % -- COMMAND: CFApproximants ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CFApproximants(X: RAT): LIST of RAT
\end{Verbatim}


\subsection*{Description}

``\verb&CFApproximants&'' returns a list of all continued fraction approximants
to the rational ``\verb&X&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  CFApproximants(1.414213);
[1, 3/2, 7/5, 17/12, 41/29, 99/70, 239/169, 577/408, 816/577, 1393/985,
 6388/4517, 7781/5502, 14169/10019, 21950/15521, 36119/25540, 58069/41061,
 152257/107662, 210326/148723, 1414213/1000000]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CFApprox(\ref{CFApprox} pg.\pageref{CFApprox}), 
    ContFrac(\ref{ContFrac} pg.\pageref{ContFrac})
\end{command} % -- end command --------------------------------

\section{ChainCanonicalHom}
\label{ChainCanonicalHom}
\begin{command} % -- COMMAND: ChainCanonicalHom ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ChainCanonicalHom(R: RING, S: RING): RINGHOM
\end{Verbatim}


\subsection*{Description}

This function returns the canonical homomorphism from ``\verb&R&'' to ``\verb&S&'',
where ``\verb&S&'' has been constructed from ``\verb&R&'' with a chain of
ring constructors.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[i];
/**/  K := NewQuotientRing(P, ideal(i^2+1));
/**/  R ::= K[x,y,z];

/**/  phi := ChainCanonicalHom(P, R);
/**/  RingElem(R, "x^2-i*y") / phi(RingElem(P, "(3*i-2)*(5-i)"));
((-17/338)*i -7/338)*x^2 +((7/338)*i -17/338)*y
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CanonicalHom(\ref{CanonicalHom} pg.\pageref{CanonicalHom}), 
    RingElem(\ref{RingElem} pg.\pageref{RingElem})
\end{command} % -- end command --------------------------------

\section{characteristic}
\label{characteristic}
\begin{command} % -- COMMAND: characteristic ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
characteristic(R: RING): INT
\end{Verbatim}


\subsection*{Description}

This function returns the characteristic of the ring ``\verb&R&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= ZZ/(3)[t];
/**/  S ::= QQ[x,y];
/**/  characteristic(CurrentRing);
3
/**/  S ::= QQ[x,y];
/**/  characteristic(S);
0
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsFiniteField(\ref{IsFiniteField} pg.\pageref{IsFiniteField}), 
    LogCardinality(\ref{LogCardinality} pg.\pageref{LogCardinality})
\end{command} % -- end command --------------------------------

\section{CharPoly}
\label{CharPoly}
\begin{command} % -- COMMAND: CharPoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CharPoly(M: MAT, X: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the characteristic polynomial of ``\verb&M&'',
square matrix, in the indeterminate ``\verb&X&''.
\par 
See also ``\verb&MinPoly&'' (\ref{MinPoly} pg.\pageref{MinPoly}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  CharPoly(matrix([[1,2,3],[4,5,6],[7,8,9]]), x);
x^3 -15*x^2 -18*x
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  MinPoly(\ref{MinPoly} pg.\pageref{MinPoly})
\end{command} % -- end command --------------------------------

\section{ChebyshevPoly}
\label{ChebyshevPoly}
\begin{command} % -- COMMAND: ChebyshevPoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ChebyshevPoly(N: INT, X: RINGELEM): RINGELEM
ChebyshevPoly2(N: INT, X: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

The function ``\verb&ChebyshevPoly&'' returns the Chebyshev polynomial (of 1st
type) with index ``\verb&N&'', in the indeterminate ``\verb&X&''.  The function
``\verb&ChebyshevPoly2&'' returns the Chebyshev polynomial of 2nd type.
\par 
These functions also work if ``\verb&X&'' is not an indeterminate: the result
is then the evaluation of the polynomial at the given value.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  ChebyshevPoly(3,x);
4*x^3 -3*x
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  HermitePoly(\ref{HermitePoly} pg.\pageref{HermitePoly}), 
    LaguerrePoly(\ref{LaguerrePoly} pg.\pageref{LaguerrePoly})
\end{command} % -- end command --------------------------------

\section{CheckArgTypes}
\label{CheckArgTypes}
\begin{command} % -- COMMAND: CheckArgTypes ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CheckArgTypes(Ltype: LIST of TYPE, Larg: LIST)
\end{Verbatim}


\subsection*{Description}

This function provides a basic type checking for user defined functions:
it checks whether the \textsf{TYPE}s of the elements in the third
argument, a list, correspond to the types in the second list.
If so, it returns nothing, otherwise returns an error.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  -- the following returns an error for the 2nd argument (INT)
/**/  -- CheckArgTypes([RAT, RINGELEM, MAT], [2/3, 20, LexMat(3)]);
--> !!! ERROR !!! as expected:  Arg 2 is INT but must be RINGELEM

/**/  -- the following returns nothing
/**/  CheckArgTypes([RAT, [INT,RAT,RINGELEM], MAT], [2/3, 20, LexMat(3)]);

/**/  -- an example of use for type checking
/**/  Define Pow(F, N)
/**/    CheckArgTypes([[INT,RAT,RINGELEM,IDEAL,MAT], INT], [F, N]);
/**/    Return F^N;
/**/  EndDefine; -- Pow
/**/  use QQ[x];
/**/  Pow(x, 3);
x^3
/**/  -- Pow(2, x); --> !!! ERROR !!! as expected: Arg 2 is RINGELEM but must be INT
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{ciao}
\label{ciao}
\begin{command} % -- COMMAND: ciao ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ciao
\end{Verbatim}


\subsection*{Description}

This command is used to quit CoCoA.  It may be used only at top level.

\SeeAlso %---- SEE ALSO ----
  exit(\ref{exit} pg.\pageref{exit}), 
    quit(\ref{quit} pg.\pageref{quit})
\end{command} % -- end command --------------------------------

\section{ClearDenom}
\label{ClearDenom}
\begin{command} % -- COMMAND: ClearDenom ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ClearDenom(F: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function clears the denominators of the coefficients in a
polynomial over QQ.  It simply multiplies by the least common multiple
of the denominators.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y];
/**/  f := (2/3)*x + (4/5)*y;
/**/  ClearDenom(f);
10*x +12*y
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CommonDenom(\ref{CommonDenom} pg.\pageref{CommonDenom}), 
    content(\ref{content} pg.\pageref{content}), 
    prim(\ref{prim} pg.\pageref{prim})
\end{command} % -- end command --------------------------------

\section{close}
\label{close}
\begin{command} % -- COMMAND: close ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
close(OUT: OSTREAM)
\end{Verbatim}


\subsection*{Description}

This function closes the output stream ``\verb&OUT&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  file := OpenOFile("my-test"); -- open file for output from CoCoA
/**/  print "test" on file;  -- write to my-file
/**/  close(file);  -- close the output stream, "flushes" all output
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Introduction to IO(\ref{Introduction to IO} pg.\pageref{Introduction to IO})
\end{command} % -- end command --------------------------------

\section{CloseLog}
\label{CloseLog}
\begin{command} % -- COMMAND: CloseLog ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CloseLog(D: DEVICE)
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function ``\verb&OpenLog&'' (\ref{OpenLog} pg.\pageref{OpenLog}) opens the output device D and
starts to record the output from a CoCoA session on D.
\par 
This function closes the device D and stops recording the CoCoA session on D.

\SeeAlso %---- SEE ALSO ----
  OpenLog(\ref{OpenLog} pg.\pageref{OpenLog})
\end{command} % -- end command --------------------------------

\section{CoCoA-4 mode}
\label{CoCoA-4 mode}
\begin{command} % -- COMMAND: CoCoA-4 mode ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
  *** E ***

where ``\verb&E&'' is a CoCoA-4 expression.
\end{Verbatim}


\subsection*{Description}

CoCoA-5 is not fully backward compatible with CoCoA-4, \textit{i.e.} some
CoCoA-4 programs will be rejected by CoCoA-5.  CoCoA-4 mode helps ease
the transition to CoCoA-5.
\par 
In CoCoA-4 it was not necessary to write explicitly the product between
two indeterminates; in CoCoA-5 this is obligatory.
\par 
The expression ``\verb&E&'' may also contain function calls, but only if the
function names begin with a capital letter.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  f := 2*x^2*y - 3*x*y*z - 4*y^2*z + 5*y*z^2 + 6*z^3;
/**/  g := ***2x^2y - 3xyz - 4y^2z + 5yz^2 + 6z^3***; --> C4 mode
/**/  f = g;
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Changes in the CoCoA language(\ref{Changes in the CoCoA language} pg.\pageref{Changes in the CoCoA language}), 
    not(\ref{not} pg.\pageref{not}), 
    and(\ref{and} pg.\pageref{and}), 
    or(\ref{or} pg.\pageref{or})
\end{command} % -- end command --------------------------------

\section{CocoaLimits}
\label{CocoaLimits}
\begin{command} % -- COMMAND: CocoaLimits ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CocoaLimits(): RECORD
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function returns the maximum allowable characteristic of a CoCoA
ring and the maximum allowable exponent in a CoCoA expression.  These
numbers may vary depending on the platform on which CoCoA is run.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  CocoaLimits();
record[MaxChar := 32767, MaxExp := 2147483647]
-------------------------------
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{CocoaPackagePath}
\label{CocoaPackagePath}
\begin{command} % -- COMMAND: CocoaPackagePath ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CocoaPackagePath(): STRING
\end{Verbatim}


\subsection*{Description}

This function returns the path name of the directory containing the CoCoA
libraries. It is platform dependent.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  CocoaPackagePath();
/Applications/CoCoA-5/packages
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{codomain}
\label{codomain}
\begin{command} % -- COMMAND: codomain ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
codomain(phi: RINGHOM): RING
\end{Verbatim}


\subsection*{Description}

This function returns the codomain of the homomorphism ``\verb&phi&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  P := NewPolyRing(RingQQ(), "alpha,beta");
/**/  phi := CanonicalHom(RingZZ(), P);
/**/  codomain(phi);
RingWithID(4, "QQ[alpha,beta]")
/**/  psi := CoeffEmbeddingHom(P);
/**/  codomain(psi);
RingWithID(4, "QQ[alpha,beta]")
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  codomain(\ref{codomain} pg.\pageref{codomain}), 
    Commands and Functions for RINGHOM(\ref{Commands and Functions for RINGHOM} pg.\pageref{Commands and Functions for RINGHOM}), 
    Commands and Functions returning RINGHOM(\ref{Commands and Functions returning RINGHOM} pg.\pageref{Commands and Functions returning RINGHOM})
\end{command} % -- end command --------------------------------

\section{CoeffEmbeddingHom}
\label{CoeffEmbeddingHom}
\begin{command} % -- COMMAND: CoeffEmbeddingHom ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CoeffEmbeddingHom(P: RING): RINGHOM
\end{Verbatim}


\subsection*{Description}

This function returns the coefficient embedding homomorphism of the
polynomial ring ``\verb&P&''.  ``\verb&ConstantCoeff&'' (\ref{ConstantCoeff} pg.\pageref{ConstantCoeff}) is a sort of inverse.
\par 
It is equivalent to (indeed it is called by) ``\verb&CanonicalHom(CoeffRing(P), P)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y];
/**/  phi := CoeffEmbeddingHom(P);  -- phi: QQ -> P
/**/  f := 2*x+3*y;
/**/  f/phi(LC(f));
x + (3/2)*y
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ConstantCoeff(\ref{ConstantCoeff} pg.\pageref{ConstantCoeff}), 
    CanonicalHom(\ref{CanonicalHom} pg.\pageref{CanonicalHom})
\end{command} % -- end command --------------------------------

\section{CoeffHeight}
\label{CoeffHeight}
\begin{command} % -- COMMAND: CoeffHeight ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CoeffHeight(F: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the maximum of the absolute values of the
coefficients of ``\verb&F&''; naturally, the coefficient ring must be
arithmetically ordered.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use P ::= QQ[x,y];
/**/ f := (2*x-3*y)^2;
/**/ f;
4*x^2 -12*x*y +9*y^2
/**/ CoeffHeight(f);
12
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  RootBound(\ref{RootBound} pg.\pageref{RootBound})
\end{command} % -- end command --------------------------------

\section{coefficients}
\label{coefficients}
\begin{command} % -- COMMAND: coefficients ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
coefficients(F: RINGELEM): LIST
coefficients(F: RINGELEM, S: LIST): LIST
\end{Verbatim}


\subsection*{Description}

This function returns a list of coefficients of ``\verb&F&'' which are
elements of ``\verb&CoeffRing(RingOf(F))&''.
\par 
Called with one argument ``\verb&F&'' it returns the list of all non-zero
coefficients; the order being decreasing on the terms in ``\verb&F&'' as
determined by the term-ordering of ``\verb&RingOf(F)&''.
\par 
Called with two arguments ``\verb&F,S&'' it returns the coefficients of the
list of specified terms ``\verb&S&''; their order is determined by the list
``\verb&S&''.  If a terms does not appear in ``\verb&F&'' then the corresponding
coefficient is 0.
\par 
The old form (CoCoA-4) ``\verb&Coefficients(F,x)&'' for the coefficients of
``\verb&F&'' with respect to (WRT) an indeterminate ``\verb&x&'' is now
replaced by the functions ``\verb&CoefficientsWRT&'' (\ref{CoefficientsWRT} pg.\pageref{CoefficientsWRT}) and ``\verb&CoeffListWRT&'' (\ref{CoeffListWRT} pg.\pageref{CoeffListWRT}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  F := 3*x^2*y + 5*y^2 - x*y;
/**/  Coeffs := coefficients(F);  Coeffs;  -- with one argument
[3, -1, 5]
/**/  phi := CoeffEmbeddingHom(RingOf(F));
/**/  F = ScalarProduct(phi(Coeffs), support(F));
true

/**/  Skeleton := [1, x, y, z, x^2, x*y, y^2, y*z, z^2];
/**/  Coeffs := coefficients(F, Skeleton);  Coeffs;  -- with two arguments
[0, 0, 0, 0, 0, -1, 5, 0, 0]
/**/  ScalarProduct(phi(Coeffs), Skeleton);
-x*y +5*y^2

/**/  L := CoefficientsWRT(F,[x,y,z]);  indent(L);  -- similar function
[
  record[PP := y^3, coeff := 5],
  record[PP := x^2*y, coeff := 3],
  record[PP := x*y^5, coeff := -1]
]
/**/  F = sum([X.coeff * X.PP | X in L]);
true

/**/  L := CoeffListWRT(F, y);  L;  -- similar function
[0, 3*x^2 -x, 5]
/**/  F = sum([L[d+1]*y^d | d in 0..(len(L)-1)]);
true

/**/  R3 := NewFreeModule(R,3);
/**/  V := ModuleElem(R3, [3*x^2+y, x-5*z^3, x+2*y]);
/**/  ConcatLists([coefficients(V[i]) | i in 1..NumCompts(V)]);
[3, 1, -5, 1, 1, 2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Coefficient Rings(\ref{Coefficient Rings} pg.\pageref{Coefficient Rings}), 
    CoefficientsWRT(\ref{CoefficientsWRT} pg.\pageref{CoefficientsWRT}), 
    CoeffListWRT(\ref{CoeffListWRT} pg.\pageref{CoeffListWRT}), 
    LC(\ref{LC} pg.\pageref{LC}), 
    monomials(\ref{monomials} pg.\pageref{monomials}), 
    support(\ref{support} pg.\pageref{support})
\end{command} % -- end command --------------------------------

\section{CoefficientsWRT}
\label{CoefficientsWRT}
\begin{command} % -- COMMAND: CoefficientsWRT ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CoefficientsWRT(F: RINGELEM, X: RINGELEM): LIST of RECORD
CoefficientsWRT(F: RINGELEM, S: LIST of RINGELEM): LIST of RECORD
\end{Verbatim}


\subsection*{Description}

The first function returns the list of the coefficients and power-products
of ``\verb&F&'' seen as a polynomial in ``\verb&X&'' (with respect to (WRT) ``\verb&X&'');
the second function does the same but viewing ``\verb&F&''
as a polynomial in all the indeterminates in the set ``\verb&S&''.

NOTE: coefficients in the result are RINGELEM belonging to ``\verb&RingOf(F)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  f := x^3*z+x*y+x*z+y+2*z;
/**/  Cx :=  CoefficientsWRT(f, x);  -- same as...
/**/  Cx :=  CoefficientsWRT(f, [x]);
/**/ indent(Cx);
[
  record[PP := x^3, coeff := z],
  record[PP := x, coeff := y +z],
  record[PP := 1, coeff := y +2*z]
]
/**/  f = sum([M.coeff * M.PP | M in Cx]);
true
/**/ Foreach M in Cx Do Print "  +(", M.coeff, ")*", M.PP; EndForeach;
  +(y +2*z)*1  +(y +z)*x  +(z)*x^3

/**/  Cxz :=  CoefficientsWRT(f, [x,z]);
/**/  indent(Cxz);
[
  record[PP := x^3*z, coeff := 1],
  record[PP := x*z, coeff := 1],
  record[PP := x, coeff := y],
  record[PP := z, coeff := 2],
  record[PP := 1, coeff := y]
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Coefficient Rings(\ref{Coefficient Rings} pg.\pageref{Coefficient Rings}), 
    CoeffListWRT(\ref{CoeffListWRT} pg.\pageref{CoeffListWRT}), 
    coefficients(\ref{coefficients} pg.\pageref{coefficients}), 
    CoeffOfTerm(\ref{CoeffOfTerm} pg.\pageref{CoeffOfTerm}), 
    ContentWRT(\ref{ContentWRT} pg.\pageref{ContentWRT}), 
    LC(\ref{LC} pg.\pageref{LC}), 
    monomials(\ref{monomials} pg.\pageref{monomials}), 
    support(\ref{support} pg.\pageref{support})
\end{command} % -- end command --------------------------------

\section{CoeffListWRT}
\label{CoeffListWRT}
\begin{command} % -- COMMAND: CoeffListWRT ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CoeffListWRT(F: RINGELEM, X: RINGELEM): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the list of the coefficients of ``\verb&F&'' seen as a univariate
polynomial in ``\verb&X&'', an indeterminate or a list of indeterminates
(with respect to (WRT) ``\verb&X&'').
All entries in the returned list are RingElems belonging to ``\verb&RingOf(F)&''.
\par 
NOTE: the returned list is \textbf{reversed} from the CoCoA-4 analogue
``\verb&Coefficients(F,X)&'' thus to re-use old code you should call
``\verb&reversed(CoeffListWRT(F,X))&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  F := 5*y^2 + (3*x^2-x)*y;
/**/  L := CoeffListWRT(F, y);  Print L;
[0, 3*x^2 -x, 5]
/**/  F = sum([L[d+1]*y^d | d in 0..(len(L)-1)]);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  coefficients(\ref{coefficients} pg.\pageref{coefficients}), 
    CoefficientsWRT(\ref{CoefficientsWRT} pg.\pageref{CoefficientsWRT})
\end{command} % -- end command --------------------------------

\section{CoeffListWRTSupport}
\label{CoeffListWRTSupport}
\begin{command} % -- COMMAND: CoeffListWRTSupport ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CoeffListWRTSupport(f: RINGELEM, basis: RINGELEM): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the list of the coefficients of ``\verb&f&'' relative to
the basis of power-products given by the support of ``\verb&basis&''.  The
elements of the list belong to the coefficient ring of the ring of ``\verb&f&''.
\par 
NOTE: the returned list is \textbf{reversed} with respect to the order of
the power-products in ``\verb&basis&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  f := 5*y^2 + (3*x-1)*y;
/**/  basis := (1+x+y)^2;
/**/  CoeffListWRTSupport(f, basis);
[0,  -1,  0,  5,  3,  0]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  coefficients(\ref{coefficients} pg.\pageref{coefficients}), 
    CoeffListWRT(\ref{CoeffListWRT} pg.\pageref{CoeffListWRT}), 
    support(\ref{support} pg.\pageref{support})
\end{command} % -- end command --------------------------------

\section{CoeffOfTerm}
\label{CoeffOfTerm}
\begin{command} % -- COMMAND: CoeffOfTerm ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CoeffOfTerm(F: RINGELEM, T: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the coefficient of the term ``\verb&T&'' occurring in ``\verb&F&''.
\par 
NOTE: in CoCoA 4 the order of the arguments was different.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  F := 5*x*y^2 - 3*z^3;
/**/  CoeffOfTerm(F, x*y^2);
5
/**/  CoeffOfTerm(F, x^3);
0
/**/  CoeffOfTerm(F, z^3);
-3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  coefficients(\ref{coefficients} pg.\pageref{coefficients}), 
    CoefficientsWRT(\ref{CoefficientsWRT} pg.\pageref{CoefficientsWRT}), 
    CoeffListWRT(\ref{CoeffListWRT} pg.\pageref{CoeffListWRT}), 
    LC(\ref{LC} pg.\pageref{LC}), 
    exponents(\ref{exponents} pg.\pageref{exponents}), 
    MakeTerm(\ref{MakeTerm} pg.\pageref{MakeTerm}), 
    monomials(\ref{monomials} pg.\pageref{monomials}), 
    support(\ref{support} pg.\pageref{support})
\end{command} % -- end command --------------------------------

\section{CoeffRing}
\label{CoeffRing}
\begin{command} % -- COMMAND: CoeffRing ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CoeffRing(R: RING): RING
\end{Verbatim}


\subsection*{Description}

This function returns the ring of coefficients of a polynomial ring.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  S ::= ZZ/(2)[a,b,c];
/**/  CoeffRing(R);
QQ

/**/  CoeffRing(S);
FFp(2)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  characteristic(\ref{characteristic} pg.\pageref{characteristic}), 
    coefficients(\ref{coefficients} pg.\pageref{coefficients}), 
    CurrentRing(\ref{CurrentRing} pg.\pageref{CurrentRing}), 
    indets(\ref{indets} pg.\pageref{indets})
\end{command} % -- end command --------------------------------

\section{ColMat}
\label{ColMat}
\begin{command} % -- COMMAND: ColMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ColMat(L: LIST): MAT
ColMat(R: RING, L: LIST): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the matrix whose only column consists of the
elements of the list ``\verb&L&''.
\par 
The first form produces a matrix over ``\verb&QQ&'' if all entries in
``\verb&L&'' are of type INT or RAT.  If ``\verb&L&'' contains any entries
of type RINGELEM then the matrix is over the ring these elements
belong to.
\par 
The second form produces a matrix over ``\verb&R&'', and requires that
the elements of ``\verb&L&'' be INT, RAT or RINGELEM belonging to ``\verb&R&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  ColMat([3,4,5]);
matrix(QQ,
 [[3],
  [4],
  [5]])

/**/  RingOf(It);  -- default ring is QQ
QQ

/**/  ColMat(ZZ, [3,4,5]);
matrix(ZZ,
 [[3],
  [4],
  [5]])
/**/  RingOf(It);
ZZ
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  matrix(\ref{matrix} pg.\pageref{matrix}), 
    BlockMat(\ref{BlockMat} pg.\pageref{BlockMat}), 
    DiagMat(\ref{DiagMat} pg.\pageref{DiagMat}), 
    RowMat(\ref{RowMat} pg.\pageref{RowMat}), 
    GensAsCols, GensAsRows(\ref{GensAsCols, GensAsRows} pg.\pageref{GensAsCols, GensAsRows})
\end{command} % -- end command --------------------------------

\section{colon}
\label{colon}
\begin{command} % -- COMMAND: colon ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
colon(M: IDEAL, N: IDEAL): IDEAL
colon(M: MODULE, N: MODULE): IDEAL
\end{Verbatim}


\subsection*{Description}

This function returns the colon of M by N: the ideal of all
polynomials F such that F*G is in M for all G in N.
The command ``\verb&M : N&'' is a shortcut for ``\verb&colon(M, N)&''.
\par 
See also  ``\verb&HColon&'' (\ref{HColon} pg.\pageref{HColon}) for non-homogeneous input.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  ideal(x*y, x^2) : ideal(x);
ideal(y, x)

/**/  colon(ideal(x^2, x*y), ideal(x, x-y^2));
ideal(x)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  saturate(\ref{saturate} pg.\pageref{saturate}), 
    HSaturation(\ref{HSaturation} pg.\pageref{HSaturation}), 
    HColon(\ref{HColon} pg.\pageref{HColon})
\end{command} % -- end command --------------------------------

\section{ColumnVectors [OBSOLETE]}
\label{ColumnVectors [OBSOLETE]}
\begin{command} % -- COMMAND: ColumnVectors [OBSOLETE] ------------



\subsection*{Description}

Essentially replaced by ``\verb&GensAsCols, GensAsRows&'' (\ref{GensAsCols, GensAsRows} pg.\pageref{GensAsCols, GensAsRows})
and ``\verb&SubmoduleCols, SubmoduleRows&'' (\ref{SubmoduleCols, SubmoduleRows} pg.\pageref{SubmoduleCols, SubmoduleRows})

\end{command} % -- end command --------------------------------

\section{CommonDenom}
\label{CommonDenom}
\begin{command} % -- COMMAND: CommonDenom ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CommonDenom(f: RINGELEM): RINGELEM
CommonDenom(L: LIST of RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns a common denominator for the polynomial ``\verb&f&''.
The coefficient ring of the polynomial ring to which ``\verb&f&'' belongs
must be a fraction field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y];
/**/  f := (1/4)*x+(1/6)*y;
/**/ CommonDenom(f);
12
/**/ CommonDenom(2*x);
1
/**/ CommonDenom([2*x, y/3]);
3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ClearDenom(\ref{ClearDenom} pg.\pageref{ClearDenom}), 
    content(\ref{content} pg.\pageref{content}), 
    ContentWRT(\ref{ContentWRT} pg.\pageref{ContentWRT}), 
    prim(\ref{prim} pg.\pageref{prim})
\end{command} % -- end command --------------------------------

\section{Comp [OBSOLETE]}
\label{Comp [OBSOLETE]}
\begin{command} % -- COMMAND: Comp [OBSOLETE] ------------



\subsection*{Description}

Please use the indexing operator ``\verb&[...]&'' for accessing
entries in a list by index, or to select fields from a record.

\SeeAlso %---- SEE ALSO ----
  operators, shortcuts(\ref{operators, shortcuts} pg.\pageref{operators, shortcuts}), 
    record field selector(\ref{record field selector} pg.\pageref{record field selector})
\end{command} % -- end command --------------------------------

\section{CompleteToOrd [OBSOLETE]}
\label{CompleteToOrd [OBSOLETE]}
\begin{command} % -- COMMAND: CompleteToOrd [OBSOLETE] ------------



\subsection*{Description}

Renamed ``\verb&MakeTermOrdMat&'' (\ref{MakeTermOrdMat} pg.\pageref{MakeTermOrdMat}).

\end{command} % -- end command --------------------------------

\section{compts}
\label{compts}
\begin{command} % -- COMMAND: compts ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
compts(V: MODULEELEM): LIST
Comps(V: MODULEELEM): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the list of components of the ModuleElem ``\verb&V&''.
It is like converting the ``\verb&ModuleElem&'' into a generic list.
\par 
NOTE: a ``\verb&ModuleElem&'' is a more structured object than a generic list.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  R3 := NewFreeModule(R,3);
/**/  V := ModuleElem(R3, [3*x^2+4*y, 2*x-5*z^3, 2*x+2*y]);  V;
[3*x^2 +4*y, -5*z^3 +2*x, 2*x +2*y]
/**/  type(V);
MODULEELEM

/**/  compts(V);
[3*x^2 +4*y, -5*z^3 +2*x, 2*x +2*y]
/**/ type(compts(V));
LIST
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NumCompts(\ref{NumCompts} pg.\pageref{NumCompts})
\end{command} % -- end command --------------------------------

\section{ComputeElimFirst}
\label{ComputeElimFirst}
\begin{command} % -- COMMAND: ComputeElimFirst ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ComputeElimFirst(X: RINGELEM, I: IDEAL): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function is experimental and dangerous! No guarantees.
\par 
Manual is intentionally cryptic.
If you think this function is useful for you, write email to Anna M. Bigatti.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use ZZ/(32003)[x,y,t];
/**/  ComputeElimFirst(t, ideal(x^2-t^2, y^3-t^3));
x^6 -y^6

/**/  Use ZZ/(32003)[x,y,t,h];
/**/  ComputeElimFirst(t, ideal(x*h-t^2, y*h^2-t^3));
x^3*h^2 -y^2*h^3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  elim(\ref{elim} pg.\pageref{elim})
\end{command} % -- end command --------------------------------

\section{concat}
\label{concat}
\begin{command} % -- COMMAND: concat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
concat(L_1: LIST,...,L_n: LIST): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the list obtained by concatenating the lists
``\verb&L_1,...,L_n&''.
\par 
NOTE: to concatenate strings use ``\verb&ConcatStrings&'' (\ref{ConcatStrings} pg.\pageref{ConcatStrings}) or ``\verb&str1+str2&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  concat([1,2,3],[4,5],[],[6]);
[1, 2, 3, 4, 5, 6]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  append(\ref{append} pg.\pageref{append}), 
    ConcatLists(\ref{ConcatLists} pg.\pageref{ConcatLists}), 
    ConcatStrings(\ref{ConcatStrings} pg.\pageref{ConcatStrings}), 
    String Operations(\ref{String Operations} pg.\pageref{String Operations})
\end{command} % -- end command --------------------------------

\section{ConcatAntiDiag}
\label{ConcatAntiDiag}
\begin{command} % -- COMMAND: ConcatAntiDiag ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ConcatAntiDiag(A: MAT, B: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function creates a simple block matrix.  The two entries are
matrices.
ConcatAntiDiag(A, B) will return a matrix of the form
\begin{verbatim}
                | 0 A |
                | B 0 |
\end{verbatim}
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  A := mat([[1,2,3],   [4,5,6]]);
/**/  B := mat([[101,102], [103,104]]);
/**/  ConcatAntiDiag(A, B);
matrix(QQ,
 [[0, 0, 1, 2, 3],
  [0, 0, 4, 5, 6],
  [101, 102, 0, 0, 0],
  [103, 104, 0, 0, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BlockMat(\ref{BlockMat} pg.\pageref{BlockMat}), 
    ConcatDiag(\ref{ConcatDiag} pg.\pageref{ConcatDiag}), 
    ConcatHor(\ref{ConcatHor} pg.\pageref{ConcatHor}), 
    ConcatVer(\ref{ConcatVer} pg.\pageref{ConcatVer})
\end{command} % -- end command --------------------------------

\section{ConcatDiag}
\label{ConcatDiag}
\begin{command} % -- COMMAND: ConcatDiag ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ConcatDiag(A: MAT, B: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function creates a simple block matrix.  The two entries are
matrices.
ConcatDiag(A, B) will return a matrix of the form
\begin{verbatim}
                | A 0 |
                | 0 B |
\end{verbatim}
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  A := mat([[1,2,3],   [4,5,6]]);
/**/  B := mat([[101,102], [103,104]]);
/**/  ConcatDiag(A, B);
matrix(QQ,
 [[1, 2, 3, 0, 0],
  [4, 5, 6, 0, 0],
  [0, 0, 0, 101, 102],
  [0, 0, 0, 103, 104]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BlockMat(\ref{BlockMat} pg.\pageref{BlockMat}), 
    ConcatAntiDiag(\ref{ConcatAntiDiag} pg.\pageref{ConcatAntiDiag}), 
    ConcatHor(\ref{ConcatHor} pg.\pageref{ConcatHor}), 
    ConcatVer(\ref{ConcatVer} pg.\pageref{ConcatVer}), 
    DiagMat(\ref{DiagMat} pg.\pageref{DiagMat})
\end{command} % -- end command --------------------------------

\section{ConcatHor}
\label{ConcatHor}
\begin{command} % -- COMMAND: ConcatHor ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ConcatHor(A: MAT, B: MAT): MAT

where A and B have the same number of rows
\end{Verbatim}


\subsection*{Description}

This function creates a horizontally stacked block matrix.  The
two entries are matrices with the same number of rows.
``\verb&ConcatHor(A, B)&'' will return a matrix of the form
\begin{verbatim}
                | A B |
\end{verbatim}
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  A := mat([[1,2,3],   [4,5,6]]);
/**/  B := mat([[101,102], [103,104]]);
/**/  ConcatHor(A, B);
matrix(QQ,
 [[1, 2, 3, 101, 102],
  [4, 5, 6, 103, 104]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BlockMat(\ref{BlockMat} pg.\pageref{BlockMat}), 
    MakeMatByRows, MakeMatByCols(\ref{MakeMatByRows, MakeMatByCols} pg.\pageref{MakeMatByRows, MakeMatByCols}), 
    ConcatAntiDiag(\ref{ConcatAntiDiag} pg.\pageref{ConcatAntiDiag}), 
    ConcatDiag(\ref{ConcatDiag} pg.\pageref{ConcatDiag}), 
    ConcatHorList(\ref{ConcatHorList} pg.\pageref{ConcatHorList}), 
    ConcatVer(\ref{ConcatVer} pg.\pageref{ConcatVer}), 
    RowMat(\ref{RowMat} pg.\pageref{RowMat})
\end{command} % -- end command --------------------------------

\section{ConcatHorList}
\label{ConcatHorList}
\begin{command} % -- COMMAND: ConcatHorList ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ConcatHorList(L: LIST of MAT): MAT

where the matrices in L have the same number of rows
\end{Verbatim}


\subsection*{Description}

This function creates a horizontally stacked block matrix.  The
entries in the list are matrices with the same number of rows.
``\verb&ConcatHorList(L)&'' will return a matrix of the form
\begin{verbatim}
                | L[1] L[2] .. L[N] |
\end{verbatim}
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [ mat([[1,2,3], [4,5,6]]), mat([[101,102], [103,104]]) ];
/**/  ConcatHorList(L);
matrix(QQ,
 [[1, 2, 3, 101, 102],
  [4, 5, 6, 103, 104]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BlockMat(\ref{BlockMat} pg.\pageref{BlockMat}), 
    MakeMatByRows, MakeMatByCols(\ref{MakeMatByRows, MakeMatByCols} pg.\pageref{MakeMatByRows, MakeMatByCols}), 
    ConcatAntiDiag(\ref{ConcatAntiDiag} pg.\pageref{ConcatAntiDiag}), 
    ConcatDiag(\ref{ConcatDiag} pg.\pageref{ConcatDiag}), 
    ConcatHor(\ref{ConcatHor} pg.\pageref{ConcatHor}), 
    ConcatVerList(\ref{ConcatVerList} pg.\pageref{ConcatVerList}), 
    RowMat(\ref{RowMat} pg.\pageref{RowMat})
\end{command} % -- end command --------------------------------

\section{ConcatLists}
\label{ConcatLists}
\begin{command} % -- COMMAND: ConcatLists ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ConcatLists(L: LIST of LISTs): LIST
\end{Verbatim}


\subsection*{Description}

This function takes one argument, a list whose entries are lists, and
returns the concatenation of its entries.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [[1,2],["abc","def"],[3,4]];
/**/  ConcatLists(L);
[1, 2, "abc", "def", 3, 4]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  append(\ref{append} pg.\pageref{append}), 
    concat(\ref{concat} pg.\pageref{concat}), 
    flatten(\ref{flatten} pg.\pageref{flatten})
\end{command} % -- end command --------------------------------

\section{ConcatStrings}
\label{ConcatStrings}
\begin{command} % -- COMMAND: ConcatStrings ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ConcatStrings(L: LIST of STRING): STRING
\end{Verbatim}


\subsection*{Description}

This function returns the string obtained by concatenating the strings
in ``\verb&L&''.  This function is faster than ``\verb&concat&'' (\ref{concat} pg.\pageref{concat}).
\par 
NOTE: to concatenate 2 strings  use ``\verb&str1 + str2&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  concat(["abc", "def", "ghi"]);
abcdefghi
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  concat(\ref{concat} pg.\pageref{concat}), 
    FoldToListInput(\ref{FoldToListInput} pg.\pageref{FoldToListInput}), 
    String Operations(\ref{String Operations} pg.\pageref{String Operations})
\end{command} % -- end command --------------------------------

\section{ConcatVer}
\label{ConcatVer}
\begin{command} % -- COMMAND: ConcatVer ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ConcatVer(A: MAT, B: MAT): MAT

where A and B have the same number of columns
\end{Verbatim}


\subsection*{Description}

This function creates a vertically stacked block matrix.  The
two entries are matrices with the same number of columns.
``\verb&ConcatVer(A, B)&'' will return a matrix of the form
\begin{verbatim}
                | A |
                | B |
\end{verbatim}
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  A := mat([[1,2,3], [4,5,6]]);
/**/  B := mat([[11,12,13]]);
/**/  ConcatVer(A, B);
matrix(QQ,
 [[1, 2, 3],
  [4, 5, 6],
  [11,12,13]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BlockMat(\ref{BlockMat} pg.\pageref{BlockMat}), 
    ColMat(\ref{ColMat} pg.\pageref{ColMat}), 
    MakeMatByRows, MakeMatByCols(\ref{MakeMatByRows, MakeMatByCols} pg.\pageref{MakeMatByRows, MakeMatByCols}), 
    ConcatAntiDiag(\ref{ConcatAntiDiag} pg.\pageref{ConcatAntiDiag}), 
    ConcatDiag(\ref{ConcatDiag} pg.\pageref{ConcatDiag}), 
    ConcatHor(\ref{ConcatHor} pg.\pageref{ConcatHor}), 
    ConcatVerList(\ref{ConcatVerList} pg.\pageref{ConcatVerList})
\end{command} % -- end command --------------------------------

\section{ConcatVerList}
\label{ConcatVerList}
\begin{command} % -- COMMAND: ConcatVerList ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ConcatVerList(L: LIST of MAT): MAT

where the matrices in L have the same number of columns
\end{Verbatim}


\subsection*{Description}

This function creates a vertically stacked block matrix.  The
entries in the list are matrices with the same number of columns.
``\verb&ConcatVerList(L)&'' will return a matrix of the form
\begin{verbatim}
                | L[1] |
                | L[2] |
                |  ..  |
\end{verbatim}
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [ mat([[1,2,3], [4,5,6]]), mat([[11,12,13]]) ];
/**/  ConcatVerList(L);
matrix(QQ,
 [[1, 2, 3],
  [4, 5, 6],
  [11, 12, 13]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BlockMat(\ref{BlockMat} pg.\pageref{BlockMat}), 
    ColMat(\ref{ColMat} pg.\pageref{ColMat}), 
    MakeMatByRows, MakeMatByCols(\ref{MakeMatByRows, MakeMatByCols} pg.\pageref{MakeMatByRows, MakeMatByCols}), 
    ConcatAntiDiag(\ref{ConcatAntiDiag} pg.\pageref{ConcatAntiDiag}), 
    ConcatDiag(\ref{ConcatDiag} pg.\pageref{ConcatDiag}), 
    ConcatVer(\ref{ConcatVer} pg.\pageref{ConcatVer}), 
    ConcatHorList(\ref{ConcatHorList} pg.\pageref{ConcatHorList})
\end{command} % -- end command --------------------------------

\section{ConstantCoeff}
\label{ConstantCoeff}
\begin{command} % -- COMMAND: ConstantCoeff ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ConstantCoeff(F: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the constant coefficient of a polynomial.
The result is in the coefficient ring, and may be zero.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y];
/**/  f := x^3+3*x*y-4*y+5;
/**/  ConstantCoeff(f);
5
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CoeffEmbeddingHom(\ref{CoeffEmbeddingHom} pg.\pageref{CoeffEmbeddingHom}), 
    coefficients(\ref{coefficients} pg.\pageref{coefficients}), 
    CoefficientsWRT(\ref{CoefficientsWRT} pg.\pageref{CoefficientsWRT}), 
    CoeffListWRT(\ref{CoeffListWRT} pg.\pageref{CoeffListWRT}), 
    LC(\ref{LC} pg.\pageref{LC})
\end{command} % -- end command --------------------------------

\section{content}
\label{content}
\begin{command} % -- COMMAND: content ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
content(F: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the content of ``\verb&F&''.
The returned value is a RingElem in ``\verb&CoeffRing(RingOf(F))&''.
\par 
If the coefficient ring is a (true) GCD domain, the result is the standard
content (\textit{i.e.} a gcd of its coefficients).
\par 
If the coefficient ring is a fraction field of a (true) GCD domain ``\verb&R&''
then the result is a fraction ``\verb&c&'' such that ``\verb&f/c&''
is a primitive polynomial with coefficients in ``\verb&R&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use P ::= QQ[x,y,z];
/**/ F := 1234*x^3*z + 3456*x*y*z^3 + 5678*y^2*z;
/**/ content(F);
2
/**/ RingOf(It);
QQ
/**/ content(4*x/5 + 2);
2/5
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ContentWRT(\ref{ContentWRT} pg.\pageref{ContentWRT}), 
    coefficients(\ref{coefficients} pg.\pageref{coefficients}), 
    IsTrueGCDDomain(\ref{IsTrueGCDDomain} pg.\pageref{IsTrueGCDDomain}), 
    prim(\ref{prim} pg.\pageref{prim})
\end{command} % -- end command --------------------------------

\section{ContentFreeFactor}
\label{ContentFreeFactor}
\begin{command} % -- COMMAND: ContentFreeFactor ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ContentFreeFactor(F: RINGELEM): RECORD
\end{Verbatim}


\subsection*{Description}

This function returns a factorization of the multivariate polynomial ``\verb&F&''
into (polynomial) content-free factors; it works by calling ``\verb&ContentWRT&''
repeatedly.  The multiplicities will always be 1.
\par 
A polynomial which is (polynomial) content-free means that all its irreducible
factors involve all indeterminates appearing in the polynomial itself.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use P ::= QQ[x,y,z];
/**/ f := 2*(x+1)*(y+2)*(x+y)^2*(x-y);
/**/ indent(ContentFreeFactor(f));
record[
  RemainingFactor := 2,
  factors := [y +2, x +1, x^3 +x^2*y -x*y^2 -y^3],
  multiplicities := [1, 1, 1]
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ContentWRT(\ref{ContentWRT} pg.\pageref{ContentWRT}), 
    factor(\ref{factor} pg.\pageref{factor}), 
    SqFreeFactor(\ref{SqFreeFactor} pg.\pageref{SqFreeFactor})
\end{command} % -- end command --------------------------------

\section{ContentWRT}
\label{ContentWRT}
\begin{command} % -- COMMAND: ContentWRT ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ContentWRT(F: RINGELEM, X: RINGELEM): RINGELEM
ContentWRT(F: RINGELEM, L: LIST of RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the (polynomial) content of ``\verb&F&'' (\textit{i.e.} a gcd of its
coefficients) seen as a polynomial in the indeterminate ``\verb&X&'', or as a
polynomial in all the indeterminates in ``\verb&L&''.
\par 
The returned value is a RingElem in RingOf(F).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use P ::= QQ[x,y,z];
/**/ f := x^3*z + x*y*z^3 + 2*z;
/**/ Cx :=  CoefficientsWRT(f, x);
/**/ indent(Cx);
[
  record[PP := 1, coeff := 2*z],
  record[PP := x, coeff := y*z^3],
  record[PP := x^3, coeff := z]
]
/**/ ContentWRT(f, x);
z
/**/ ContentWRT(f, [x]);
z
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CoefficientsWRT(\ref{CoefficientsWRT} pg.\pageref{CoefficientsWRT}), 
    content(\ref{content} pg.\pageref{content}), 
    monomials(\ref{monomials} pg.\pageref{monomials})
\end{command} % -- end command --------------------------------

\section{ContFrac}
\label{ContFrac}
\begin{command} % -- COMMAND: ContFrac ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ContFrac(X: RAT): LIST of INT
\end{Verbatim}


\subsection*{Description}

``\verb&ContFrac&'' returns a list of the continued fraction \textbf{quotients}
for the given rational number ``\verb&X&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  ContFrac(1.414213);
[1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4, 1, 1, 1, 1, 1, 2, 1, 6]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CFApprox(\ref{CFApprox} pg.\pageref{CFApprox}), 
    CFApproximants(\ref{CFApproximants} pg.\pageref{CFApproximants}), 
    ContFracToRat(\ref{ContFracToRat} pg.\pageref{ContFracToRat})
\end{command} % -- end command --------------------------------

\section{ContFracToRat}
\label{ContFracToRat}
\begin{command} % -- COMMAND: ContFracToRat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ContFracToRat(L: LIST of INT): RAT
\end{Verbatim}


\subsection*{Description}

``\verb&ContFracToRat&'' returns the rational number equal to the continued
fraction whose quotients are given as input.  The quotients must all be
integers, only the very first may be non-positive.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  ContFracToRat([1, 2, 2, 2, 2, 2, 2, 2]);
577/408
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ContFrac(\ref{ContFrac} pg.\pageref{ContFrac}), 
    CFApprox(\ref{CFApprox} pg.\pageref{CFApprox}), 
    CFApproximants(\ref{CFApproximants} pg.\pageref{CFApproximants})
\end{command} % -- end command --------------------------------

\section{continue}
\label{continue}
\begin{command} % -- COMMAND: continue ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
continue
\end{Verbatim}


\subsection*{Description}

This command must be used inside a loop statement (``\verb&for&'', ``\verb&foreach&'',
``\verb&repeat&'', or ``\verb&while&'').
When executed, the current loop iteration is terminated, and the control
passes directly to the next iteration.
\par 
In the case of nested loops ``\verb&continue&'' refers only to iterations of
the innermost loop in which it appears; to affect loops outside the
innermost one, you must use ``\verb&break&'' (\ref{break} pg.\pageref{break}) to break out of the
current loop command.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  for i := 5 to 1 step -1 do
/**/    for j := 1 to 4 do
/**/      if i = j then continue; endif;
/**/      print j, " ";
/**/    endfor;
/**/    println;
/**/  endfor;
1 2 3 4 
1 2 3 
1 2 4 
1 3 4 
2 3 4 
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  break(\ref{break} pg.\pageref{break}), 
    return(\ref{return} pg.\pageref{return}), 
    All CoCoA commands(\ref{All CoCoA commands} pg.\pageref{All CoCoA commands})
\end{command} % -- end command --------------------------------

\section{CoprimeFactorBasis}
\label{CoprimeFactorBasis}
\begin{command} % -- COMMAND: CoprimeFactorBasis ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CoprimeFactorBasis(L: LIST of INT): LIST of INT
CoprimeFactorBasis(L: LIST of RINGELEM): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns a coprime factor base for a set of integers
or ring elements from a (true) GCD domain.
\par 
Given a set of values $N = [ N_1,...N_k ]$ we seek a factor base
$G = [ G_1,...,G_s ]$ of pairwise coprime values such that each
$N_i$ is a product of powers of the $G_j$.
\par 
In general there are many different such sets $G$ for a given set $N$.
Such sets are sometimes called "GCD-free bases" for $N$.
\par 
The factor base produced by these functions may not be of least cardinality.
A least cardinality base can be obtained by performing all possible GCD and
exact division operations iteratively.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  CoprimeFactorBasis([factorial(20), factorial(10)]);
[46189, 4, 14175]
/**/  use QQ[x,y];
/**/  CoprimeFactorBasis([x^2*y^4, x^3*y^6]);
[x*y^2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  gcd(\ref{gcd} pg.\pageref{gcd})
\end{command} % -- end command --------------------------------

\section{count}
\label{count}
\begin{command} % -- COMMAND: count ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
count(L: LIST, E: OBJECT): INT
\end{Verbatim}


\subsection*{Description}

This function counts the number of occurrences of the object ``\verb&E&'' in the
list ``\verb&L&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [1,2,3,2,[2,3]];
/**/  count(L,2);
2

/**/  count(L,[2,3]);
1

/**/  count(L,"a");
0
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  distrib(\ref{distrib} pg.\pageref{distrib}), 
    len(\ref{len} pg.\pageref{len})
\end{command} % -- end command --------------------------------

\section{covers}
\label{covers}
\begin{command} % -- COMMAND: covers ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
covers(relP: LIST): LIST  of LIST
\end{Verbatim}


\subsection*{Description}

This function print a poset description from the list relP of the strict relations in a poset.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
// POSET:
//         3   4
//          \ /
//           2
//           |
//           1
/**/ relP := [[1,2],  [2,3],  [2,4]];
/**/ covers(relP);
[[],  [1],  [1,  2],  [1,  2]]

/**/ indent(covers(relP));
[
  [],      // elems < 1
  [1],     // elems < 2
  [1,  2], // elems < 3
  [1,  2]  // elems < 4
]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{CpuTime}
\label{CpuTime}
\begin{command} % -- COMMAND: CpuTime ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CpuTime(): RAT
\end{Verbatim}


\subsection*{Description}

This function returns a RAT whose value is the user CPU usage in
seconds since the start of the program: this is the amount of time the
processor has dedicated to your computation, and may be rather less than
the real elapsed time if the computer is also busy with other tasks.
\par 
The most common usage is with ``\verb&TimeFrom&'' (\ref{TimeFrom} pg.\pageref{TimeFrom}) as shown in the example;
it automatically computes the time difference and returns it as decimal
string.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ StartTime := CpuTime(); -- time in seconds since the start (a RAT)
/**/ --
/**/ -- .... long computation ....
/**/ --
/**/ PrintLn "Computation time: ", TimeFrom(StartTime);

/**/ -- Alternative use: compute TimeTaken as a RAT
/**/ StartTime := CpuTime();
/**/ --
/**/ -- .... long computation ....
/**/ --
/**/ EndTime := CpuTime();
/**/ TimeTaken := EndTime - StartTime;  --> ugly if printed directly
/**/ PrintLn "Computation time: ", DecimalStr(TimeTaken);
\end{Verbatim}

You can use ``\verb&DecimalStr&'' (\ref{DecimalStr} pg.\pageref{DecimalStr}) to see the value of ``\verb&CpuTime&'' in a more easily
comprehensible form.

\SeeAlso %---- SEE ALSO ----
  TimeFrom(\ref{TimeFrom} pg.\pageref{TimeFrom}), 
    ElapsedTime(\ref{ElapsedTime} pg.\pageref{ElapsedTime}), 
    DecimalStr(\ref{DecimalStr} pg.\pageref{DecimalStr})
\end{command} % -- end command --------------------------------

\section{CRT}
\label{CRT}
\begin{command} % -- COMMAND: CRT ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CRT(R1: INT, M1: INT, R2: INT, M2: INT): RECORD
\end{Verbatim}


\subsection*{Description}

This function combines two residue-modulus pairs ``\verb&(R1,M1)&'' and ``\verb&(R2,M2)&''
using the Chinese Remainder Theorem to produce a single residue-modulus
pair ``\verb&(R,M)&'' such that ``\verb&R = R1 mod M1&'' and ``\verb&R = R2 mod M2&'', and ``\verb&|R| < M&''.
The moduli ``\verb&M1&'' and ``\verb&M2&'' must be coprime (hence ``\verb&M = M1*M2&'').
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  CRT(2,3, 4,5);
record[modulus := 15, residue := -1]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CRTPoly(\ref{CRTPoly} pg.\pageref{CRTPoly}), 
    RatReconstructByContFrac(\ref{RatReconstructByContFrac} pg.\pageref{RatReconstructByContFrac}), 
    RatReconstructByLattice(\ref{RatReconstructByLattice} pg.\pageref{RatReconstructByLattice})
\end{command} % -- end command --------------------------------

\section{CRTPoly}
\label{CRTPoly}
\begin{command} % -- COMMAND: CRTPoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CRTPoly(f1: RINGELEM, M1: INT, f2: RINGELEM, M2: INT): RECORD
\end{Verbatim}


\subsection*{Description}

This function combines residue-modulus pairs ``\verb&(f1,M1)&'' and ``\verb&(f2,M2)&''
using the Chinese Remainder Theorem to produce a single
residue-modulus pair ``\verb&(f,M)&'' such that 
``\verb&f&'' is a polynomial (with coefficients in ``\verb&QQ&''),
``\verb&f = f1 mod M1&'' and ``\verb&f = f2 mod M2&'',
and all coefficients of ``\verb&f&'' are smaller than ``\verb&M&''.
The moduli ``\verb&M1&'' and ``\verb&M2&'' must be coprime (hence ``\verb&M = M1*M2&'').
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];
/**/  CRTPoly(x-y, 331, x+y, 10093);
record[modulus := 3340783, residue := x +676232*y]
/**/ mod(676232, 331);
330
/**/ mod(676232, 10093);
1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CRT(\ref{CRT} pg.\pageref{CRT}), 
    RatReconstructPoly(\ref{RatReconstructPoly} pg.\pageref{RatReconstructPoly})
\end{command} % -- end command --------------------------------

\section{CurrentRing}
\label{CurrentRing}
\begin{command} % -- COMMAND: CurrentRing ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CurrentRing: RING
\end{Verbatim}


\subsection*{Description}

This is a top-level \textbf{system variable} containing the current ring.
\par 
NOTE: we advise against using it inside functions (see ``\verb&TopLevel&'' (\ref{TopLevel} pg.\pageref{TopLevel})).
Previously, in CoCoA-4 it was a function (namely ``\verb&CurrentRing()&'')
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  use S ::= ZZ/(3)[t];
/**/  CurrentRing;
RingWithID(5, "ZZ/(3)[t]")

/**/  use R;
/**/  CurrentRing;
RingWithID(3, "QQ[x,y]")
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  RingOf(\ref{RingOf} pg.\pageref{RingOf}), 
    TopLevel(\ref{TopLevel} pg.\pageref{TopLevel})
\end{command} % -- end command --------------------------------

\section{CurrentTypes}
\label{CurrentTypes}
\begin{command} % -- COMMAND: CurrentTypes ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
CurrentTypes(): LIST of TYPE
\end{Verbatim}


\subsection*{Description}

This function lists all CoCoA data types.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  CurrentTypes();
[BOOL, ERROR, FUNCTION, ...]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{cyclotomic}
\label{cyclotomic}
\begin{command} % -- COMMAND: cyclotomic ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
cyclotomic(n: INT, x: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function computes the ``\verb&n&''-th cyclotomic polynomial (in the
indeterminate ``\verb&x&'').
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[z];
/**/  cyclotomic(4,z);
z^2 + 1
\end{Verbatim}


\end{command} % -- end command --------------------------------

\chapter{D}  %----=== CHAPTER LETTER ===----
\label{D}

\section{dashes}
\label{dashes}
\begin{command} % -- COMMAND: dashes ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
dashes()
\end{Verbatim}


\subsection*{Description}

This function returns a string of dashes:
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  dashes(); 1+1;
-------------------------------
2
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{date}
\label{date}
\begin{command} % -- COMMAND: date ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
date() : INT
\end{Verbatim}


\subsection*{Description}

This function returns the date.
\par 
NOTE: from CoCoA version 5.0.4 the result is an INT and the date is in
the form YYYYMMDD (in decimal).
See also ``\verb&TimeOfDay&'' (\ref{TimeOfDay} pg.\pageref{TimeOfDay}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  date();
20130530
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  TimeOfDay(\ref{TimeOfDay} pg.\pageref{TimeOfDay})
\end{command} % -- end command --------------------------------

\section{DecimalStr}
\label{DecimalStr}
\begin{command} % -- COMMAND: DecimalStr ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
DecimalStr(X: INT|RAT|RINGELEM): STRING
DecimalStr(X: INT|RAT|RINGELEM, NumDigits: INT): STRING
\end{Verbatim}


\subsection*{Description}

This function produces a decimal string representation of the rational
number ``\verb&X&'' with up to ``\verb&NumDigits&'' digits after the decimal point.  If
not specified, the default number of digits is 3.
\par 
If ``\verb&X&'' is a RINGELEM, it is automatically converted to a RAT.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  DecimalStr(1/3);
0.333

/**/  DecimalStr(1/3, 50);
0.33333333333333333333333333333333333333333333333333

/**/  DecimalStr(123.456789);
123.457
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  FloatStr(\ref{FloatStr} pg.\pageref{FloatStr}), 
    ScientificStr(\ref{ScientificStr} pg.\pageref{ScientificStr}), 
    MantissaAndExponent10(\ref{MantissaAndExponent10} pg.\pageref{MantissaAndExponent10})
\end{command} % -- end command --------------------------------

\section{define}
\label{define}
\begin{command} % -- COMMAND: define ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
Define F(X_1, .., X_n)   C   EndDefine
Define F(X_1, .., opt X_n)   C   EndDefine
Define F(...)   C   EndDefine
  return FUNCTION
\end{Verbatim}


\subsection*{Description}

These commands introduce a user-defined function.  ``\verb&F&'' is the name
comprising letters, digits or underscore, but must start with a letter.
``\verb&X_1&'' and so on are the parameters (much like local variables).
``\verb&C&'' is the function body.
\par 
(1) INTRODUCTION.
These commands assign a user-defined function to the variable ``\verb&F&'';
any previous value ``\verb&F&'' held will be lost!  The function ``\verb&F&'' can be
called in the following obvious way:
\begin{verbatim}
    F(E_1,...,E_n)
\end{verbatim}
where the arguments ``\verb&E_i&'''s are expressions.
\par 
The result of the evaluation of each expression ``\verb&E_i&'' is assigned
to the respective formal parameter ``\verb&X_i&'', and the command sequence
``\verb&C&'' is executed.
\par 
If, during the execution of ``\verb&C&'', a statement ``\verb&Return E&'' is executed,
then the result of the evaluation of ``\verb&E&'' is the return-value of the
function ``\verb&F&''.  If no ``\verb&Return&'' command is executed, or ``\verb&Return&'' is
executed without argument, then the return-value is ``\verb&Null&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  define square(X) --> simple fn with 1 parameter
/**/    return X^2;
/**/  enddefine;

/**/  square(5);
25
\end{Verbatim}


(2) SCOPE OF VARIABLES.
Every parameter and every variable used in the function body ``\verb&C&'' is
local to the function \textbf{unless} the variable is a ``\verb&ref&'' (\ref{ref} pg.\pageref{ref}) parameter, or
the variable was declared global by ``\verb&TopLevel&'' (\ref{TopLevel} pg.\pageref{TopLevel}).
\par 
See ``\verb&ref&'' (\ref{ref} pg.\pageref{ref}) to learn about passing function arguments \textbf{by reference},
\textit{i.e.} so that the function can change the value of an existing variable.
\par 
See ``\verb&TopLevel&'' (\ref{TopLevel} pg.\pageref{TopLevel}) for the use of global variables.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Define Add5(N)  // use helpful name for fn
/**/    N := N + 5;
/**/    Return N;
/**/  EndDefine;

/**/  N := 0;
/**/  Add5(N);
5
/**/  N;  --> N is unchanged despite the function call.
0
\end{Verbatim}


(3) VARIABLE NUMBER OF PARAMETERS.
It is also possible to have some optional parameters or a variable
number of parameters.  For optional parameters see also ``\verb&IsDefined&'' (\ref{IsDefined} pg.\pageref{IsDefined}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
-- (3a) OPTIONAL ARGUMENTS
--      These must be in the last position(s).

/**/  define deg0(f, opt x)
/**/    if f=0 then return 0; endif;
/**/    if IsDefined(x) then return deg(f,x); endif;
/**/    return deg(f);
/**/  enddefine;

/**/  use P ::= QQ[x,y,z];
/**/  deg0(zero(P));
0
/**/  deg0(x^2+y);
2
/**/  deg0(x^2+y, y);
1

--------------------------------------
-- (3b) VARIABLE NUMBER OF PARAMETERS

/**/   Define MySum(...)  -->  arguments are in the LIST "ARGV"
/**/     If len(ARGV) = 0 Then Return 12345; EndIf;
/**/     ans := 0;
/**/     Foreach N In ARGV Do ans := ans+N; EndForeach;
/**/     Return ans;
/**/   EndDefine;

/**/  MySum(1,2,3,4,5);
15
/**/  MySum();
12345
\end{Verbatim}

The CoCoA-4 statement, ``\verb&Help S;&'' is now OBSOLETE!

\SeeAlso %---- SEE ALSO ----
  return(\ref{return} pg.\pageref{return}), 
    TopLevel(\ref{TopLevel} pg.\pageref{TopLevel}), 
    ref(\ref{ref} pg.\pageref{ref}), 
    All CoCoA commands(\ref{All CoCoA commands} pg.\pageref{All CoCoA commands})
\end{command} % -- end command --------------------------------

\section{DefiningIdeal}
\label{DefiningIdeal}
\begin{command} % -- COMMAND: DefiningIdeal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
DefiningIdeal(S: RING): IDEAL
\end{Verbatim}


\subsection*{Description}

When ``\verb&S&'' is a quotient ring, say ``\verb&S = R/I&'', this function returns
``\verb&I&'', the ideal which defines ``\verb&S&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  S := R/ideal(x);
/**/  DefiningIdeal(S);
ideal(x)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CanonicalRepr(\ref{CanonicalRepr} pg.\pageref{CanonicalRepr}), 
    InducedHom(\ref{InducedHom} pg.\pageref{InducedHom}), 
    NewQuotientRing(\ref{NewQuotientRing} pg.\pageref{NewQuotientRing}), 
    BaseRing(\ref{BaseRing} pg.\pageref{BaseRing})
\end{command} % -- end command --------------------------------

\section{deg}
\label{deg}
\begin{command} % -- COMMAND: deg ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
deg(F: RINGELEM): INT
deg(F: RINGELEM, X: RINGELEM): INT
\end{Verbatim}


\subsection*{Description}

The first form of this function returns the \textbf{standard degree} of ``\verb&F&''
(see ``\verb&wdeg&'' (\ref{wdeg} pg.\pageref{wdeg}) for the \textbf{weighted degree}).
The second form returns the exponent of the indeterminate ``\verb&X&'' in ``\verb&F&''.
\par 
For the degree of a ring or quotient, see ``\verb&multiplicity&'' (\ref{multiplicity} pg.\pageref{multiplicity}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  deg(x*y^2+y);
3
/**/  deg(x*y^2+y, x);
1
/**/  Ws := RowMat([2,3,1]);
/**/  P := NewPolyRing(QQ, "x,y,z", MakeTermOrdMat(Ws), 1);
/**/  use P;
/**/  deg(x*y^2+y);
3
/**/  wdeg(x*y^2+y);
[8]
/**/  deg(x*y^2+y, x);
1
/**/  deg(x*y^2+y, y);
2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  wdeg(\ref{wdeg} pg.\pageref{wdeg}), 
    exponents(\ref{exponents} pg.\pageref{exponents}), 
    NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing}), 
    multiplicity(\ref{multiplicity} pg.\pageref{multiplicity})
\end{command} % -- end command --------------------------------

\section{den}
\label{den}
\begin{command} % -- COMMAND: den ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
den(X: INT|RAT): INT
den(X: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

These function returns the denominator of the argument ``\verb&X&''.
If ``\verb&X&'' is a RINGELEM in ``\verb&FractionField(R)&'',
then ``\verb&den(X)&'' is a RINGELEM in ``\verb&R&''.
\par 
NOTE: In CoCoA 4 the numerator and denominator could also be found
using the suffixes ``\verb&.Num&'' and ``\verb&.Den&''; this fragile syntax is
now obsolete.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  den(3);
1

/**/  P ::= QQ[x,y];
/**/  F := NewFractionField(P);
/**/  use F;
/**/  den(x/(x+y));
x +y
/**/  RingOf(It);
RingWithID(4, "QQ[x,y]")
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  num(\ref{num} pg.\pageref{num})
\end{command} % -- end command --------------------------------

\section{DensePoly}
\label{DensePoly}
\begin{command} % -- COMMAND: DensePoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
DensePoly(R: RING, N: INT): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the sum of all power-products of (standard) degree ``\verb&N&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  DensePoly(R,3);
x^3 + x^2*y + x*y^2 + y^3

/**/  Weights := RowMat([2,3]);
/**/  P := NewPolyRing(QQ, "x,y", MakeTermOrdMat(Weights), 1);
/**/  use P;
/**/  DensePoly(P,1);  // NOTE: standard degree!!
y +x
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{DenSigma}
\label{DenSigma}
\begin{command} % -- COMMAND: DenSigma ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
DenSigma(I: IDEAL): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the sigma-denominator of the ideal ``\verb&I&'',
that is the common denominator of all polynomials in the sigma-reduced
GBasis.
\par 
See article Abbott, Bigatti, Robbiano
"Ideals modulo p"
(``\verb&https://arxiv.org/abs/1801.06112&'')
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y,z];
/**/ I := ideal(2*x*y^2 -1, 3*x^3*y -1);
/**/ ReducedGBasis(I);
[x*y^2 -1/2,  x^2 +(-2/3)*y,  y^3 +(-3/4)*x]
/**/ DenSigma(I);
12
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CommonDenom(\ref{CommonDenom} pg.\pageref{CommonDenom}), 
    IsSigmaGoodPrime(\ref{IsSigmaGoodPrime} pg.\pageref{IsSigmaGoodPrime})
\end{command} % -- end command --------------------------------

\section{depth}
\label{depth}
\begin{command} % -- COMMAND: depth ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
depth(I: IDEAL, M: TAGGED("Quotient")): INT
depth(RmodI: Quotient RING): INT
\end{Verbatim}


\subsection*{Description}

This function calculates the depth of M in the ideal I, \textit{i.e.} the
length of a maximal I-regular sequence in M.  In the second form,
where the ideal ``\verb&I&'' is not specified, it assumes that ``\verb&I&'' is the maximal ideal
generated by the indeterminates, \textit{i.e.} ``\verb&ideal(Indets())&''.
\par 
NOTE: if ``\verb&M&'' is homogeneous and ``\verb&I&'' is the maximal ideal, then it uses
the Auslander-Buchsbaum formula ``\verb&depth_I(M) = N - pd(M)&''
where ``\verb&N&'' is the number of indeterminates and ``\verb&pd&'' is the projective
dimension, otherwise (***** NOT YET IMPLEMENTED *****) it
returns ``\verb&min{N | Ext^N(R/I, M)<>0}&''
using the function ``\verb&Ext&'' (\ref{Ext} pg.\pageref{Ext}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  depth(P); -- the (x,y,z)-depth of the entire ring is 3
3

/**/  I := ideal(x^5,y^3,z^2);
/**/  depth(P/I);
0

//----- ***** NOT YET IMPLEMENTED ***** ----->>
  N := Module([x^2,y], [x+z,0]);
  depth(I, P^2/N);  --- a max reg sequence would be (z^2,y^3)
2
-------------------------------
  use P ::= QQ[x,y,z,t,u,v];
  -- Cauchy-Riemann system in three complex vars!
  N := Module([x,y], [-y,x], [z,t], [-t,z], [u,v], [-v,u]);
  --- is it CM?
  depth(P^2/N);
3
-------------------------------
  dim(P^2/N);
3
-------------------------------
  --- yes!

  M := Module([x,y,z],[t,v,u]);
  res(P^3/M);
0 --> P^2(-1) --> P^3
-------------------------------
  depth(P^3/M); -- using Auslander Buchsbaum 6-1=5
5
-------------------------------
  dim(P^3/M);  -- not CM
6
-------------------------------
  depth(ideal(x,y,z,t), P^2/N);
2
-------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  res(\ref{res} pg.\pageref{res}), 
    Ext(\ref{Ext} pg.\pageref{Ext})
\end{command} % -- end command --------------------------------

\section{deriv}
\label{deriv}
\begin{command} % -- COMMAND: deriv ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
deriv(F: RINGELEM, X: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the derivative of F with respect to the
indeterminate X.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  deriv(x*y^2, x);
y^2

/**/  FrF := NewFractionField(R);
/**/  use FrF;
/**/  deriv((x*y^2)/(x-1), x);
(-y^2)/(x^2 -2*x +1)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  JacobianMat(\ref{JacobianMat} pg.\pageref{JacobianMat})
\end{command} % -- end command --------------------------------

\section{DerivationAction}
\label{DerivationAction}
\begin{command} % -- COMMAND: DerivationAction ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
DerivationAction(D: RINGELEM, P: RINGELEM)
\end{Verbatim}


\subsection*{Description}

Thanks to Enrico Carlini.
\par 
Given the polynomial ``\verb&P&'' and the derivation ``\verb&D&'', this function
computes the action of ``\verb&D&'' on ``\verb&P&''.
\par 
For the sake of simplicity Forms/Polynomials and Derivations live in
the same ring, the distinction between them is purely formal.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  DerivationAction(x*y*z, x^3+x*y*z);
1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  InverseSystem(\ref{InverseSystem} pg.\pageref{InverseSystem}), 
    PerpIdealOfForm(\ref{PerpIdealOfForm} pg.\pageref{PerpIdealOfForm})
\end{command} % -- end command --------------------------------

\section{describe}
\label{describe}
\begin{command} % -- COMMAND: describe ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
describe X: OBJECT
\end{Verbatim}


\subsection*{Description}

This command prints some descriptive information about the object ``\verb&X&''.  For
instance, if ``\verb&X&'' is a package name (prefixed with a ``\verb&$&''), it prints out the exported names.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  describe $latex;
The package $latex exports the following names:
* LaTeX
* latex

The package $latex also has the following non-exported members:
... 
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PackageOf(\ref{PackageOf} pg.\pageref{PackageOf}), 
    starting(\ref{starting} pg.\pageref{starting})
\end{command} % -- end command --------------------------------

\section{det}
\label{det}
\begin{command} % -- COMMAND: det ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
det(M: MAT): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the determinant of the matrix ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  M := mat(R,[[x,x^2], [x,x^3]]);
/**/  det(M);
x^4 -x^3

/**/ det(mat(QQ,[[1,2], [0,5]]));
5
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  minors(\ref{minors} pg.\pageref{minors})
\end{command} % -- end command --------------------------------

\section{DF}
\label{DF}
\begin{command} % -- COMMAND: DF ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
DF(F: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

Same as ``\verb&LF&'' (\ref{LF} pg.\pageref{LF}), but does not throw an error if the argument
is zero or if the ``\verb&GradingDim&'' (\ref{GradingDim} pg.\pageref{GradingDim}) of the polynomial ring is 0.
As defined in Kreuzer-Robbiano book II (Definition 4.2.8).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  DF(x^2 -x*y +2*x -1);
x^2 -x*y

/**/  use R ::= QQ[x,y], Lex;  -- GradingDim is 0: everything is homogeneous
/**/  DF(x^2 -x*y +2*x -1);
x^2 -x*y +2*x -1

/**/  P := NewPolyRing(QQ, IndetSymbols(R), mat([[1,4],[1,0]]), 1);
/**/  use P;
/**/  DF(x^2 -x*y);
-x*y
/**/  DF(x^4 +x^2 -y);
 x^4 -y
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LF(\ref{LF} pg.\pageref{LF})
\end{command} % -- end command --------------------------------

\section{DiagMat}
\label{DiagMat}
\begin{command} % -- COMMAND: DiagMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
DiagMat(L: LIST): MAT
DiagMat(R: RING, L: LIST): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the diagonal matrix whose diagonal are the
elements of the list ``\verb&L&''.  By default the matrix is over ``\verb&QQ&'' (\ref{QQ} pg.\pageref{QQ}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  DiagMat([3,4,5]);
matrix(QQ,
[
  [3, 0, 0],
  [0, 4, 0],
  [0, 0, 5]
])

/**/ DiagMat(ZZ,[5,6,7]);
matrix(ZZ,
[
  [5, 0, 0],
  [0, 6, 0],
  [0, 0, 7]
])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BlockMat(\ref{BlockMat} pg.\pageref{BlockMat}), 
    IsDiagonal(\ref{IsDiagonal} pg.\pageref{IsDiagonal}), 
    ColMat(\ref{ColMat} pg.\pageref{ColMat}), 
    RowMat(\ref{RowMat} pg.\pageref{RowMat})
\end{command} % -- end command --------------------------------

\section{DicksonPoly}
\label{DicksonPoly}
\begin{command} % -- COMMAND: DicksonPoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
DicksonPoly(X: RINGELEM, N: INT, ALPHA: RINGELEM): RINGELEM
DicksonPoly2(X: RINGELEM, N: INT, ALPHA: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

These functions return the Dickson polynomials (of 1st and 2nd type
respectively) of degree ``\verb&N&'' in ``\verb&X&'' with parameter ``\verb&ALPHA&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x, alpha];
/**/  DicksonPoly(x, 3, alpha);
x^3 -3*x*alpha
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{diff}
\label{diff}
\begin{command} % -- COMMAND: diff ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
diff(L: LIST, M: LIST): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the list obtained by removing all the elements
of ``\verb&M&'' from ``\verb&L&''.  See ``\verb&deriv&'' (\ref{deriv} pg.\pageref{deriv}) for the derivative.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [1,2,3,2,[2,3]];
/**/  M := [1,2];
/**/  diff(L, M);
[3, [2, 3]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  remove(\ref{remove} pg.\pageref{remove})
\end{command} % -- end command --------------------------------

\section{dim}
\label{dim}
\begin{command} % -- COMMAND: dim ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
dim(R: RING): INT
\end{Verbatim}


\subsection*{Description}

This function computes the dimension of the ring ``\verb&R&'', where ``\verb&R&'' is a
quotient of a polynomial ring.  NB: the coefficient ring must be a field.
\par 
If ``\verb&I&'' is a zero-dimensional ideal in the polynomial ring ``\verb&P&'', and
you want the compute the vector-space dimension of ``\verb&P/I&'' then use the
function ``\verb&multiplicity&'' (\ref{multiplicity} pg.\pageref{multiplicity}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  dim(R/ideal(x));
2

/**/  dim(R/ideal(y^2-x, x*z-y^3));
1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  multiplicity(\ref{multiplicity} pg.\pageref{multiplicity})
\end{command} % -- end command --------------------------------

\section{discriminant}
\label{discriminant}
\begin{command} % -- COMMAND: discriminant ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
discriminant(F: RINGELEM): RINGELEM
discriminant(F: RINGELEM, X: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

These functions compute the discriminant of a non-constant polynomial ``F``
with respect to the indeterminate ``X``; in the first form ``F`` must be
univariate, and ``X`` is taken to be its indeterminate.
\par 
The discriminant is defined as
\begin{verbatim}
(-1)^(N*(N-1)/2)*det(M)/M[1,1]
\end{verbatim}
where ``\verb&M := SylvesterMat(F, deriv(F,X), X)&''
and  ``\verb&N := deg(F, X)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Use R ::= QQ[x,y];
/**/  discriminant(x^2+3*y^2, x);
-12*y^2

/**/  discriminant(x^2+3*y^2, y);
-12*x^2

/**/  discriminant((x+1)^20+2);
54975581388800000000000000000000
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  resultant(\ref{resultant} pg.\pageref{resultant})
\end{command} % -- end command --------------------------------

\section{distrib}
\label{distrib}
\begin{command} % -- COMMAND: distrib ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
distrib(L: LIST): LIST
\end{Verbatim}


\subsection*{Description}

For each object ``\verb&E&'' of a list ``\verb&L&'',
let N(E) be the number of times ``\verb&E&'' occurs as a component of ``\verb&L&''.
Then ``\verb&Distrib(L)&'' returns the list whose components are ``\verb&[E, N(E)]&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  distrib(["b","a","b",4,4,[1,2]]);
[["b", 2], ["a", 1], [4, 2], [[1, 2], 1]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  count(\ref{count} pg.\pageref{count})
\end{command} % -- end command --------------------------------

\section{div}
\label{div}
\begin{command} % -- COMMAND: div ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
div(N: INT, D: INT): INT
\end{Verbatim}


\subsection*{Description}

This function computes the integer quotient of ``\verb&N&'' divided by ``\verb&D&'';
it is equal to ``\verb&N/D&'' \textbf{rounded towards zero}.
The companion function ``\verb&mod&'' (\ref{mod} pg.\pageref{mod}) computes the corresponding remainder.
\par 
If we set ``\verb&Q = div(N,D)&'' and ``\verb&R = mod(N,D)&'' then $N = Q*D + R$.
\par 
NOTE: for polynomials use ``\verb&NR&'' (\ref{NR} pg.\pageref{NR}) (remainder),  ``\verb&DivAlg&'' (\ref{DivAlg} pg.\pageref{DivAlg}) (quotients and remainder),
``\verb&IsIn&'' (\ref{IsIn} pg.\pageref{IsIn}) (ideal membership).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ div(10,3);
3
/**/ div(10,-3);
-3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  mod(\ref{mod} pg.\pageref{mod}), 
    DivAlg(\ref{DivAlg} pg.\pageref{DivAlg}), 
    IsIn(\ref{IsIn} pg.\pageref{IsIn}), 
    NR(\ref{NR} pg.\pageref{NR}), 
    ceil(\ref{ceil} pg.\pageref{ceil}), 
    floor(\ref{floor} pg.\pageref{floor})
\end{command} % -- end command --------------------------------

\section{DivAlg}
\label{DivAlg}
\begin{command} % -- COMMAND: DivAlg ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
DivAlg(X: RINGELEM, L: LIST of RINGELEM): RECORD
DivAlg(X: MODULEELEM, L: LIST of MODULEELEM): RECORD
\end{Verbatim}


\subsection*{Description}

This function performs the division algorithm on X with respect to L.
It returns a record with two fields: ``\verb&quotients&'' holding a list of
polynomials, and ``\verb&remainder&'' holding the remainder of X upon division
by L.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  F := x^2*y +x*y^2 +y^2;
/**/  L := [x*y-1, y^2-1];
/**/  DivAlg(F, L);
record[quotients := [x +y, 1], remainder := x +y +1]

/**/  D := It;
/**/  D.quotients;
[x +y, 1]
/**/  D.remainder;
x +y + 1
/**/  ScalarProduct(D.quotients, L) + D.remainder = F;
true

/**/  R2 := NewFreeModule(R,2);
/**/  V := ModuleElem(R2, [x^2+y^2+z^2, x*y*z]);
/**/  L := gens(SubmoduleRows(R2, mat([[x,y], [y,z], [z,x]])));
/**/  D := DivAlg(V, L);
/**/  indent(D);
record[
  quotients := [x, -z^2 +y +z, y*z -y],
  remainder := [z^2, z^3 -y*z -z^2]
]
/**/ sum([D.quotients[i]*L[i] | i in 1..len(L)]) + D.remainder;
[x^2 +y^2 +z^2, x*y*z]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  div(\ref{div} pg.\pageref{div}), 
    mod(\ref{mod} pg.\pageref{mod}), 
    GenRepr(\ref{GenRepr} pg.\pageref{GenRepr}), 
    NF(\ref{NF} pg.\pageref{NF}), 
    NR(\ref{NR} pg.\pageref{NR})
\end{command} % -- end command --------------------------------

\section{domain}
\label{domain}
\begin{command} % -- COMMAND: domain ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
domain(phi: RINGHOM): RING
\end{Verbatim}


\subsection*{Description}

This function returns the domain of the homomorphism ``\verb&phi&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  P := NewPolyRing(RingQQ(), "alpha,beta");
/**/  phi := CanonicalHom(RingZZ(), P);
/**/  domain(phi);
ZZ
/**/  psi := CoeffEmbeddingHom(P);
/**/  domain(psi);
QQ
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  codomain(\ref{codomain} pg.\pageref{codomain}), 
    Commands and Functions for RINGHOM(\ref{Commands and Functions for RINGHOM} pg.\pageref{Commands and Functions for RINGHOM}), 
    Commands and Functions returning RINGHOM(\ref{Commands and Functions returning RINGHOM} pg.\pageref{Commands and Functions returning RINGHOM})
\end{command} % -- end command --------------------------------

\chapter{E}  %----=== CHAPTER LETTER ===----
\label{E}

\section{E\_ [OBSOLETE]}
\label{E [OBSOLETE]}
\begin{command} % -- COMMAND: E\_ [OBSOLETE] ------------



\subsection*{Description}

[OBSOLETE] replaced by ``\verb&CanonicalBasis&'' (\ref{CanonicalBasis} pg.\pageref{CanonicalBasis}) of a FreeModule.

\end{command} % -- end command --------------------------------

\section{eigenfactors}
\label{eigenfactors}
\begin{command} % -- COMMAND: eigenfactors ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
eigenfactors(M: MAT, X: RINGELEM): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

``\verb&M&'' must be a square matrix, and ``\verb&X&'' an indeterminate.
\par 
This function determines the eigenfactors of ``\verb&M&'', \textit{i.e.} the
irreducible factors of ``\verb&CharPoly&'' (\ref{CharPoly} pg.\pageref{CharPoly}) of ``\verb&M&'' as polynomials in ``\verb&X&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  M := mat([[0,2,0,0],[1,0,0,0],[0,0,0,2],[0,0,1,1]]);
/**/  eigenfactors(M, x);
[x+1,  x-2,  x^2-2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  eigenvectors(\ref{eigenvectors} pg.\pageref{eigenvectors})
\end{command} % -- end command --------------------------------

\section{eigenvectors}
\label{eigenvectors}
\begin{command} % -- COMMAND: eigenvectors ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
eigenvectors(M: MAT, X: RINGELEM): LIST of RECORD
\end{Verbatim}


\subsection*{Description}

``\verb&M&'' must be a matrix of numbers, and ``\verb&X&'' an indeterminate.
\par 
This function determines the eigenvalues of ``\verb&M&'', and for each eigenvalue
gives a basis of the corresponding eigenspace -- note that the basis is
probably not orthogonal.  For irrational eigenvalues, the minimal
polynomial of the eigenvalue is given (as a polynomial in ``\verb&X&''), along with
the eigenvectors expressed in terms of a root of the minimal polynomial
(represented as ``\verb&X&'').
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  M := mat([[1,2,3],[4,5,6],[7,8,9]]);
/**/  eigenvectors(M, x);
[record[MinPoly := x, eigenspace := matrix(QQ,
 [[-1],
  [2],
  [-1]])],
record[MinPoly := x^2 -15*x -18,
eigenspace := [[1, (1/8)*x +1/4, (1/4)*x -1/2]]]
]

/**/  M := mat([[0,2,0,0],[1,0,0,0],[0,0,0,2],[0,0,1,0]]);
  eigenvectors(M, x); -- two irrational eigenvalues, each with eigenspace of dimension 2
[record[MinPoly := x^2 -2, eigenspace := [[1, (1/2)*x, 0, 0], [0, 0, 1, (1/2)*x]]]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  eigenfactors(\ref{eigenfactors} pg.\pageref{eigenfactors})
\end{command} % -- end command --------------------------------

\section{ElapsedTime}
\label{ElapsedTime}
\begin{command} % -- COMMAND: ElapsedTime ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ElapsedTime(): RAT
\end{Verbatim}


\subsection*{Description}

This function returns a RAT whose value is the elapsed time in
seconds since the start of the program.  We recommend using ``\verb&FloatStr&'' (\ref{FloatStr} pg.\pageref{FloatStr})
to print out the value in a way which is convenient to comprehend.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ println "Before sleep: ", FloatStr(ElapsedTime());
/**/ SleepFor(5);
/**/ println "After sleep: ", FloatStr(ElapsedTime());
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CpuTime(\ref{CpuTime} pg.\pageref{CpuTime}), 
    DecimalStr(\ref{DecimalStr} pg.\pageref{DecimalStr})
\end{command} % -- end command --------------------------------

\section{elim}
\label{elim}
\begin{command} % -- COMMAND: elim ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
elim(X: RINGELEM, M: IDEAL): IDEAL
elim(L: LIST, M: IDEAL): IDEAL
elim(X: RINGELEM, M: MODULE): MODULE
elim(L: LIST, M: MODULE): MODULE
\end{Verbatim}


\subsection*{Description}

This function returns the ideal or module obtained by eliminating the
indeterminate ``\verb&X&'', or all indeterminates in ``\verb&L&'', from ``\verb&M&''.  The coefficient
ring needs to be a field.
\par 
As opposed to this function, there is also the \textbf{modifier}, ``\verb&elim&'',
used when constructing a ring (see ``Term Orderings'' (\ref{Term Orderings} pg.\pageref{Term Orderings})).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use R ::= QQ[t,x,y,z];
/**/ E := elim(t, ideal(t^15+t^6+t-x, t^5-y, t^3-z));
/**/ indent(E);
ideal(
  z^5 -y^3,
  y^4 +y*z^2 -x*y +z^2,
  x*y^3*z +y^2*z^3 +x*z^3 -x^2*z +y^2 +y,
  y^2*z^4 +x^2*y^3 +x*y^2*z^2 +y*z^4 +x^2*z^2 -x^3 +y^2*z +2*y*z +z,
  y^3*z^3 -x*z^3 +y^3 +y^2
)

/**/ use R ::= QQ[t,s,x,y,z,w];
/**/ t..x;
[t, s, x]

/**/ elim(t..x, ideal(t-x^2*z*w, x^2-t, y^2*t-w)); -- Note the use of t..x.
ideal(z*w^2 -w)

/**/ use R ::= QQ[t[1..2], x[1..4]];
/**/ I := ideal(x[1]-t[1]^4, x[2]-t[1]^2*t[2], x[3]-t[1]*t[2]^3, x[4]-t[2]^4);
/**/ elim(indets(R,"t"), I);
ideal(x[2]^4 -x[1]^2*x[4],  x[3]^4 -x[1]*x[4]^3)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Term Orderings(\ref{Term Orderings} pg.\pageref{Term Orderings})
\end{command} % -- end command --------------------------------

\section{ElimHomogMat}
\label{ElimHomogMat}
\begin{command} % -- COMMAND: ElimHomogMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ElimHomogMat(ElimInd: LIST, W: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns a matrix for a term ordering eliminating the
indeterminates with indices in ``\verb&ElimInd&'' for inputs which are
homogeneous wrt the weights in the matrix ``\verb&W&''.
If you are unsure what this means, just use ``\verb&ElimMat&'' (\ref{ElimMat} pg.\pageref{ElimMat}) ;-)
\par 
NOTE: this function used to be called ``\verb&HomogElimMat&'' up to version 5.1.4,
and had swapped arguments.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  ElimHomogMat([2,3], mat([[1,5,2]]));
matrix(ZZ,
 [[1, 5, 2],
  [0, 1, 1],
  [0, 0, -1]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  elim(\ref{elim} pg.\pageref{elim}), 
    ElimMat(\ref{ElimMat} pg.\pageref{ElimMat})
\end{command} % -- end command --------------------------------

\section{ElimMat}
\label{ElimMat}
\begin{command} % -- COMMAND: ElimMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ElimMat(ElimInd: LIST of INT, N: INT): MAT
ElimMat(ElimInd: LIST of INT, W: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns an ``\verb&NxN&'' matrix representing a term ordering
for eliminating the indeterminates with indices in ``\verb&ElimInd&''.
\par 
In the second form, a weight matrix ``\verb&W&'' is given; these weights are
placed immediately below the first elimination row.
\par 
NOTE: This function used to have swapped arguments up to version
5.1.4. (\textit{e.g.} ``\verb&ElimMat(3, [2,3])&'')
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  ElimMat([2,3], 3);
matrix(ZZ,
 [[0, 1, 1],
  [1, 1, 1],
  [0, 0, -1]])

/**/  ElimMat([2,3], mat([[1,5,2]]));
matrix(ZZ,
 [[0, 1, 1],
  [1, 5, 2],
  [0, 0, -1]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  elim(\ref{elim} pg.\pageref{elim}), 
    ElimHomogMat(\ref{ElimHomogMat} pg.\pageref{ElimHomogMat}), 
    NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing})
\end{command} % -- end command --------------------------------

\section{EmbeddingHom}
\label{EmbeddingHom}
\begin{command} % -- COMMAND: EmbeddingHom ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
EmbeddingHom(K: RING): RINGHOM
\end{Verbatim}


\subsection*{Description}

This function returns the embedding homomorphism of the
fraction field ``\verb&K&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y];
/**/  K := NewFractionField(P);
/**/  phi := EmbeddingHom(K);  -- phi: P -> K
/**/  f := 2*x+3*y;
/**/  phi(f);
2*x +3*y
/**/  RingOf(phi(f));
RingWithID(5, "FractionField(RingWithID(4))")
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CanonicalHom(\ref{CanonicalHom} pg.\pageref{CanonicalHom})
\end{command} % -- end command --------------------------------

\section{EqSet}
\label{EqSet}
\begin{command} % -- COMMAND: EqSet ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
EqSet(L: LIST, M: LIST): BOOL
\end{Verbatim}


\subsection*{Description}

This function returns true if ``\verb&L&'' equals ``\verb&M&'' as sets,
otherwise it returns false.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [1,2,2];
/**/  M := [2,1];
/**/  EqSet(L, M);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  intersection(\ref{intersection} pg.\pageref{intersection}), 
    IntersectionList(\ref{IntersectionList} pg.\pageref{IntersectionList}), 
    IsSubset(\ref{IsSubset} pg.\pageref{IsSubset})
\end{command} % -- end command --------------------------------

\section{Equality Operator}
\label{Equality Operator}
\begin{command} % -- COMMAND: Equality Operator ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
A = B
A <> B
  return BOOL
\end{Verbatim}


\subsection*{Description}

These operators test for equality or not-equality.  The first form
returns ``\verb&true&'' if ``\verb&A&'' is equal to ``\verb&B&'', otherwise it returns ``\verb&false&''.
The second form is the same as ``\verb&not(A=B)&''.  These operators signal an
error if the types of ``\verb&A&'' and ``\verb&B&'' differ, or if they are ring elements
belonging to different rings.
\par 
To compare two values using an ordering see ``\verb&Order Comparison Operators&'' (\ref{Order Comparison Operators} pg.\pageref{Order Comparison Operators})
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ 1=2;
false
/**/ 1<>2;
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Order Comparison Operators(\ref{Order Comparison Operators} pg.\pageref{Order Comparison Operators}), 
    operators, shortcuts(\ref{operators, shortcuts} pg.\pageref{operators, shortcuts})
\end{command} % -- end command --------------------------------

\section{EquiIsoDec}
\label{EquiIsoDec}
\begin{command} % -- COMMAND: EquiIsoDec ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
EquiIsoDec(I: IDEAL): LIST of IDEAL
\end{Verbatim}


\subsection*{Description}

This function computes an equidimensional isoradical decomposition of
I, \textit{i.e.} a list of unmixed ideals $I_1,...,I_k$ such that the radical of I
is the intersection of the radicals of $I_1,...,I_k$. Redundancies are
possible.
\par 
NOTE: at the moment, this implementation works only if the coefficient
ring is the rationals or has large enough characteristic.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use R ::= QQ[x,y,z];
/**/ I := IntersectionList([ideal(x-1,y-1,z-1), ideal(x-2,y-2)^2, ideal(x)^3]);
/**/ H := $radical.EquiIsoDec(I);  H;
[ideal(x),  ideal(y -2,  x^2 -4*x +4),  ideal(z -1,  x*y -y^2 -2*x +2*y,  x^2 -y^2 -4*x +4*y,  y^3 -5*y^2 +8*y -4)]
/**/ T := [radical(J) | J in H];
/**/ S := IntersectionList(T);
/**/ radical(I) = S;
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PrimaryDecomposition(\ref{PrimaryDecomposition} pg.\pageref{PrimaryDecomposition}), 
    radical(\ref{radical} pg.\pageref{radical}), 
    RadicalOfUnmixed(\ref{RadicalOfUnmixed} pg.\pageref{RadicalOfUnmixed})
\end{command} % -- end command --------------------------------

\section{error}
\label{error}
\begin{command} % -- COMMAND: error ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
error(S: STRING): ERROR
\end{Verbatim}


\subsection*{Description}

This function throws an error containing the given message.
For backward compatibility the function may also be called using
the name ``\verb&Error&''
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ Define T(N)
/**/   If type(N) <> INT Then error("Argument must be an integer."); EndIf;
/**/   Return mod(N,5);
/**/ EndDefine;

/**/  T(7);
2

-- /**/ T(1/3); --> !!! ERROR !!! as expected:  "Argument must be an integer."
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  try(\ref{try} pg.\pageref{try}), 
    GetErrMesg(\ref{GetErrMesg} pg.\pageref{GetErrMesg})
\end{command} % -- end command --------------------------------

\section{EulerTotient}
\label{EulerTotient}
\begin{command} % -- COMMAND: EulerTotient ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
EulerTotient(N: INT): INT
\end{Verbatim}


\subsection*{Description}

This function computes the Euler "totient" function (also sometimes
called Euler "phi" function).  The value is the number of
integers from 1 to ``\verb&N&'' which are coprime to ``\verb&N&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  EulerTotient(100);
40  
/**/  EulerTotient(30030);
5760
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PrimitiveRoot(\ref{PrimitiveRoot} pg.\pageref{PrimitiveRoot})
\end{command} % -- end command --------------------------------

\section{eval}
\label{eval}
\begin{command} % -- COMMAND: eval ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
eval(E: RINGELEM|MODULEELEM|LIST|MAT, L: LIST): OBJECT
\end{Verbatim}


\subsection*{Description}

This function substitutes ``\verb&L[I]&'' for ``\verb&indet(I)&'' in the
expression ``\verb&E&'' which must be of type POLY, MODULEELEM, LIST, or MAT.
The evaluation takes place in the ring of ``\verb&E&''.
\par 
If ``\verb&len(L)&'' is different from ``\verb&NumIndets()&'' then only
the first N substitutions are performed, where N is the minumum of the
two values.
\par 
For more general substitutions use ``\verb&subst&'' (\ref{subst} pg.\pageref{subst}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y];
/**/  eval(x^2+y, [2, 3]);
7
/**/  eval(x^2+y, [2]);
y +4

/**/  F := x*(x-1)*(x-2)*y*(y-1)*(y-2)/36;
/**/  P := [1/2, -2/3];
/**/  eval(F, P);
-5/162
/**/  eval([x+y,x-y], [2,1]);
[3, 1]
/**/  eval([x+y,x-y], [x^2,y^2]);
[x^2 + y^2, x^2 - y^2]
/**/  eval([x+y,x-y], [y]);
[2*y, 0]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Evaluation of Polynomials(\ref{Evaluation of Polynomials} pg.\pageref{Evaluation of Polynomials}), 
    PolyAlgebraHom(\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}), 
    subst(\ref{subst} pg.\pageref{subst})
\end{command} % -- end command --------------------------------

\section{EvalHilbertFn}
\label{EvalHilbertFn}
\begin{command} % -- COMMAND: EvalHilbertFn ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
EvalHilbertFn(H:TAGGED("$hp.Hilbert"), N: INT): INT
\end{Verbatim}


\subsection*{Description}

This function evaluates the Hilbert function ``\verb&H&'' at ``\verb&N&''.  If ``\verb&H&'' is the
Hilbert function of a quotient ``\verb&R/I&'', then the value returned is the
same as that returned by ``\verb&HilbertFn(R/I, N)&'' but time is saved
since the Hilbert function does not need to be recalculated at each call.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[w,x,y,z];
/**/  I := ideal(z^2-x*y, x*z^2+w^3);
/**/  H := HilbertFn(R/I);
/**/  H;
H(0) = 1
H(1) = 4
H(t) = 6t - 3   for t >= 2

/**/  EvalHilbertFn(H,1);
4
/**/  EvalHilbertFn(H,2);
9
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  HilbertFn(\ref{HilbertFn} pg.\pageref{HilbertFn}), 
    HilbertPoly(\ref{HilbertPoly} pg.\pageref{HilbertPoly})
\end{command} % -- end command --------------------------------

\section{EvalQuasiPoly}
\label{EvalQuasiPoly}
\begin{command} % -- COMMAND: EvalQuasiPoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
EvalQuasiPoly(QP: LIST of RINGELEM, N: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ M := mat(ZZ, [ [0,  2,  1], [0, -2,  3], [2, -2,  3] ]);
/**/ Cinput := record[integral_closure := M, grading := mat([[1,1,1]]) ];
/**/ C := NmzComputation(Cinput, ["HilbertSeries"]);
/**/ CHQ := C.HilbertQuasiPolynomial;   indent(CHQ);
[
  (8/9)*t^2 +2*t +1,
  (8/9)*t^2 +(14/9)*t +5/9,
  (8/9)*t^2 +(16/9)*t +8/9
]
/**/ EvalQuasiPoly(CHQ,151);
20503
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NmzComputation(\ref{NmzComputation} pg.\pageref{NmzComputation}), 
    NmzHilbertBasis(\ref{NmzHilbertBasis} pg.\pageref{NmzHilbertBasis}), 
    NmzNormalToricRing(\ref{NmzNormalToricRing} pg.\pageref{NmzNormalToricRing}), 
    NmzIntClosureMonIdeal(\ref{NmzIntClosureMonIdeal} pg.\pageref{NmzIntClosureMonIdeal}), 
    NmzSetVerbosityLevel(\ref{NmzSetVerbosityLevel} pg.\pageref{NmzSetVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{exit}
\label{exit}
\begin{command} % -- COMMAND: exit ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
exit
\end{Verbatim}


\subsection*{Description}

This command is used to quit CoCoA.  It may be used only at top level.

\SeeAlso %---- SEE ALSO ----
  ciao(\ref{ciao} pg.\pageref{ciao}), 
    quit(\ref{quit} pg.\pageref{quit})
\end{command} % -- end command --------------------------------

\section{exponents}
\label{exponents}
\begin{command} % -- COMMAND: exponents ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
exponents(F: RINGELEM): LIST of INT
\end{Verbatim}


\subsection*{Description}

This function returns the list of exponents of the \textbf{leading term} of ``\verb&F&''.
The inverse function is ``\verb&MakeTerm&'' (\ref{MakeTerm} pg.\pageref{MakeTerm}).
\par 
This function was called ``\verb&log&'' up to version CoCoA-5.1.2.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  F := x^3*y^2*z^5 + x^2*y + x*z^4;
/**/  exponents(F);
[3, 2, 5]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LPP(\ref{LPP} pg.\pageref{LPP}), 
    LT(\ref{LT} pg.\pageref{LT}), 
    MakeTerm(\ref{MakeTerm} pg.\pageref{MakeTerm})
\end{command} % -- end command --------------------------------

\section{export}
\label{export}
\begin{command} % -- COMMAND: export ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
export FunctionName
\end{Verbatim}


\subsection*{Description}

This command makes a function defined in a package visible at top-level
(without having to use the package prefix).  See the manual entry for
``First Example of a Package'' (\ref{First Example of a Package} pg.\pageref{First Example of a Package}) for an example.
\par 
The ``\verb&export&'' command exports \textbf{just a single name;} you must call
it separately for each exported function.  All calls to ``\verb&export&''
must be at the start of the package (\textit{i.e.} before the first function
definition).
\par 
If you do not want to export any names from your package then you
should export the keyword ``\verb&skip&'' (to avoid a warning that no ``\verb&export&''
commands were found).

\SeeAlso %---- SEE ALSO ----
  define(\ref{define} pg.\pageref{define}), 
    Package essentials(\ref{Package essentials} pg.\pageref{Package essentials}), 
    protect(\ref{protect} pg.\pageref{protect})
\end{command} % -- end command --------------------------------

\section{Ext}
\label{Ext}
\begin{command} % -- COMMAND: Ext ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
Ext(I: INT, M:TAGGED("Quotient"), Q:TAGGED("Quotient")): TAGGED("Quotient")
Ext(I: LIST, M:TAGGED("Quotient"), Q:TAGGED("Quotient")): TAGGED("$ext.ExtList")
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
In the first form the function computes the ``\verb&I&''-th Ext module of ``\verb&M&'' and ``\verb&N&''.
It returns a presentation of $Ext^I_R(M, N)$ as a quotient of a free module.
\par 
IMPORTANT: the only exception to the type of ``\verb&M&'' or ``\verb&N&'' (or even of the
output) is when they are either a zero module or a free module.
In these cases their type is indeed MOD.
\par 
It computes Ext via a presentation of the quotient of the two modules
$Ker(Phi*_I)$
and
$Im(Phi*_{I-1})$, where
\par 
  -   $Phi_I$   is the ``\verb&I&''-th map in the free resolution of ``\verb&M&''
  \par 
  -   $Phi*_I$   is the map $Hom(Phi_I, N)$
  in the dual of the free resolution.
\par 
The main differences with the previous version include:
\par 
- SHIFTS have been removed, consequently only standard homogeneous
  modules and quotients are supported
\par 
- as a consequence of 1), the type ``\verb&Tagged("Shifted")&'' has been
  removed. Ext will just be a ``\verb&Tagged("Quotient")&''
\par 
- The former functions Presentation(), HomPresentation() and
  KerPresentation() have been removed
\par 
- The algorithm uses Res() to compute the maps needed, and not
  SyzOfGens anylonger, believed to cause troubles
\par 
- The function ``\verb&Ext&'' always has THREE variables, see syntax...
\par 

In the second form the variable ``\verb&I&'' is a LIST of nonnegative
integers. In this case the function Ext prints all the Ext modules
corresponding to the integers in ``\verb&I&''.
The output is of special type ``\verb&Tagged("$ext.ExtList")&'' which is basically
just the list of pairs  ${(J, Ext^J(M, N)) | J in I}$ in
which the first element is an integer of ``\verb&I&'' and the second element is
the correpsonding Ext module.
\par 
VERY IMPORTANT: CoCoA cannot accept  the ring ``\verb&R&'' as one of the inputs,
so if you want to calculate the module $Ext^I_R(M, R)$
you need to type something like
\par 
``\verb&Ext(I, M, ideal(1));&''
\par 
or
\par 
``\verb&Ext(I, M, R^1);&''
\par 
or
\par 
``\verb&Ext(I, M, R/ideal(0));&''
\par 
NOTE: The input is pretty flexible in terms of what you can use for ``\verb&M&''
and ``\verb&N&''.  For example, they can be zero modules or free modules.See some  examples below.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x^5, y^3, z^2);
/**/  ideal(R, []) : (I);
ideal(0)
-------------------------------
***** NOT YET IMPLEMENTED *****
  $hom.Hom(R^1/Module(I), R^1);   -- from Hom package
Module([[0]])
-------------------------------
  Ext(0, R/I, R^1);   --- all those things should be isomorphic
Module([[0]])
-------------------------------
  Ext(0..4, R/I, R/ideal(0)); -- another way to define the ring R as a quotient
Ext^0 = Module([[0]])

Ext^1 = Module([[0]])

Ext^2 = Module([[0]])

Ext^3 = R^1/Module([[x^5], [y^3], [z^2]])

Ext^4 = Module([[0]])

-------------------------------
  N := Module([x^2,y], [x+z,0]);
  Ext(0..4, R/I, R^2/N);
Ext^0 = Module([[0]])

Ext^1 = Module([[0]])

Ext^2 = R^2/Module([[0, x + z], [y, 0], [0, z^2], [z^2, 0], [0, y^3], [x^5, 0]])

Ext^3 = R^2/Module([[x + z, 0], [0, z^2], [z^2, 0], [y^3, 0], [0, x^5], [0, y]])

Ext^4 = Module([[0]])

-------------------------------
\end{Verbatim}

Since version 4.7.3 the output modules are presented minimally.

\SeeAlso %---- SEE ALSO ----
  res(\ref{res} pg.\pageref{res}), 
    depth(\ref{depth} pg.\pageref{depth}), 
    MinimalPresentation(\ref{MinimalPresentation} pg.\pageref{MinimalPresentation})
\end{command} % -- end command --------------------------------

\section{ExternalLibs}
\label{ExternalLibs}
\begin{command} % -- COMMAND: ExternalLibs ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ExternalLibs(): LIST of STRING
\end{Verbatim}


\subsection*{Description}

This function returns the list of the names of the linked libraries.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ ExternalLibs();
["GMP",  "Normaliz",  "Frobby",  "Gfan",  "CDD",  "MathSAT"]
/**/ indent(VersionInfo().ExternalLibs);
[
  record[name := "GMP", version := "60102"],
  record[name := "Normaliz", version := "30102"],
  (...)
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  VersionInfo(\ref{VersionInfo} pg.\pageref{VersionInfo})
\end{command} % -- end command --------------------------------

\chapter{F}  %----=== CHAPTER LETTER ===----
\label{F}

\section{factor}
\label{factor}
\begin{command} % -- COMMAND: factor ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
factor(F: RINGELEM): RECORD
\end{Verbatim}


\subsection*{Description}

This function factorizes a polynomial into irreducibles in its ring of
definition.  Multivariate factorization is not yet supported over finite
fields (but you can use ``\verb&SqFreeFactor&'' (\ref{SqFreeFactor} pg.\pageref{SqFreeFactor}) and then ``\verb&ContentFreeFactor&'' (\ref{ContentFreeFactor} pg.\pageref{ContentFreeFactor})
to obtain a partial factorization).
\par 
(For information about the algorithm, consult John Abbott's papers,
for univariate polynomials with coefficients in an algebraic extension,
from version 5.2.3, consult E.Palezzato's PhD thesis)
\par 
To factorize an integer use ``\verb&FactorINT&'' (\ref{FactorINT} pg.\pageref{FactorINT}).
\par 
NOTE: in older versions of CoCoA-5 the field names were ``\verb&Factors&''
and ``\verb&Exponents&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  F := 4*x^8 + 4*x^6 + x^4 + 4*x^2 + 4;
/**/  FacInfo := factor(F);
/**/  indent(FacInfo);
record[
  RemainingFactor := 1,
  factors := [2*x^4-4*x^3+5*x^2-4*x+2, 2*x^4+4*x^3+5*x^2+4*x+2],
  multiplicities := [1, 1]
]
/**/  G := product([FacInfo.factors[i]^FacInfo.multiplicities[i]
/**/                        | i in 1..len(FacInfo.factors)]);
/**/  F = G * FacInfo.RemainingFactor;
true

/**/  factor((8*x^2 +16*x +8)/27);
record[factors := [x +1], multiplicities := [2], RemainingFactor := 8/27]

/**/  factor(2*x^2-4); -- over a finite field the factors are monic
record[factors := [x^2 -2], multiplicities := [1], RemainingFactor := 2]

/**/ use QQab ::= QQ[a,b];
/**/ L := QQab/ideal(a^2-2, b^2-3);
/**/ use L[x,y];
/**/ indent(factor(x^2-2));
record[
  RemainingFactor := (1),
  factors := [x +(a), x +(-a)],
  multiplicities := [1, 1]
]

/**/ indent(factor(x^2-6));
record[
  RemainingFactor := (1),
  factors := [x +(-a*b), x +(a*b)],
  multiplicities := [1, 1]
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  FactorINT(\ref{FactorINT} pg.\pageref{FactorINT}), 
    SqFreeFactor(\ref{SqFreeFactor} pg.\pageref{SqFreeFactor}), 
    ContentFreeFactor(\ref{ContentFreeFactor} pg.\pageref{ContentFreeFactor}), 
    IsDivisible(\ref{IsDivisible} pg.\pageref{IsDivisible})
\end{command} % -- end command --------------------------------

\section{FactorAlgExt [OBSOLESCENT]}
\label{FactorAlgExt [OBSOLESCENT]}
\begin{command} % -- COMMAND: FactorAlgExt [OBSOLESCENT] ------------



\subsection*{Description}

Now directly handled by ``\verb&factor&'' (\ref{factor} pg.\pageref{factor}).

\end{command} % -- end command --------------------------------

\section{factorial}
\label{factorial}
\begin{command} % -- COMMAND: factorial ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
factorial(N: INT): INT
    \end{Verbatim}


\subsection*{Description}

This function returns the factorial of ``\verb&N&'', the product
of all integers up to and including ``\verb&N&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  factorial(5);
120

/**/  factorial(25);
15511210043330985984000000
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  binomial(\ref{binomial} pg.\pageref{binomial}), 
    primorial(\ref{primorial} pg.\pageref{primorial})
\end{command} % -- end command --------------------------------

\section{FactorINT}
\label{FactorINT}
\begin{command} % -- COMMAND: FactorINT ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FactorINT(N: INT): RECORD
FactorINT_TrialDiv(N: INT, MaxPrime: INT): RECORD
FactorINT_PollardRho(N: INT, Niters: INT): RECORD
\end{Verbatim}


\subsection*{Description}

These functions find the (small) prime factors of an integer.  ``\verb&FactorINT&'' 
tries to find all factors (usually prime); it may take a very long time!
``\verb&FactorINT_TrialDiv&'' does trial division by all primes up to ``\verb&MaxPrime&'';
be wary of giving large values for ``\verb&MaxPrime&''.
``\verb&FactorINT_PollardRho&'' performs ``\verb&Niters&'' of the Pollard-Rho algorithm;
if no factor was found, the result is an empty factorization.  The factor
found may not be prime!  Be wary of specifying large values for ``\verb&Niters&''.
\par 
From version 5.0.4, to comply with the naming conventions, the fields are
called ``\verb&factors&'' and ``\verb&multiplicities&'' instead of ``\verb&Factors&''
and ``\verb&Exponents&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  FactorINT_TrialDiv(100,3);
record[factors := [2], multiplicities := [2], RemainingFactor := 25]

/**/  FactorINT(123456789);
record[factors := [3, 3607, 3803], multiplicities := [2, 1, 1], RemainingFactor := 1]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsPrime(\ref{IsPrime} pg.\pageref{IsPrime}), 
    IsProbPrime(\ref{IsProbPrime} pg.\pageref{IsProbPrime}), 
    CoprimeFactorBasis(\ref{CoprimeFactorBasis} pg.\pageref{CoprimeFactorBasis})
\end{command} % -- end command --------------------------------

\section{FactorMultiplicity}
\label{FactorMultiplicity}
\begin{command} % -- COMMAND: FactorMultiplicity ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FactorMultiplicity(b: INT, N: INT): INT
\end{Verbatim}


\subsection*{Description}

This function counts how many times the integer base ``\verb&b&'' 
divides the integer ``\verb&N&''.
\par 
NOTE: ``\verb&N&'' must be non-zero, and ``\verb&b > 1&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  FactorMultiplicity(2, 20); // largest k s.t. 2^k divides 20
2
/**/  FactorMultiplicity(5, 20); // largest k s.t. 5^k divides 20
1
/**/  FactorMultiplicity(7, 20); // largest k s.t. 7^k divides 20
0
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsDivisible(\ref{IsDivisible} pg.\pageref{IsDivisible}), 
    FactorINT(\ref{FactorINT} pg.\pageref{FactorINT})
\end{command} % -- end command --------------------------------

\section{FGLM5}
\label{FGLM5}
\begin{command} % -- COMMAND: FGLM5 ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FGLM5(GBOld: LIST, M: MAT): LIST
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function is implemented in ApCoCoALib by Stefan Kaspar.
\par 
The function ``\verb&FGLM5&'' calls the CoCoAServer to perform a
FGLM Groebner Basis conversion.  Please note that the ideal generated
by the given Groebner Basis must be zero-dimensional.  The Groebner
Basis contained in list ``\verb&GBOld&'' will be converted into a Groebner Basis
with respect to term ordering ``\verb&Ord(M)&'', \textit{i.e.} M must be a matrix
specifying a term ordering.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  use QQ[x, y, z], DegRevLex;
  GBOld := *** [z^4 -3z^3 - 4yz + 2z^2 - y + 2z - 2, yz^2 + 2yz - 2z^2
  + 1, y^2 - 2yz + z^2 - z, x + y - z] ***;
  M := LexMat(3);
  GBNew := FGLM5(GBOld, M);
  use QQ[x, y, z], Ord(M);
  -- New basis (Lex)
  BringIn(GBNew);
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{fibonacci}
\label{fibonacci}
\begin{command} % -- COMMAND: fibonacci ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
fibonacci(N: INT): INT
\end{Verbatim}


\subsection*{Description}

This function returns the ``\verb&N&''-th fibonacci number.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  fibonacci(0);
0
/**/  fibonacci(10);
55
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{fields}
\label{fields}
\begin{command} % -- COMMAND: fields ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
fields(R: RECORD): LIST
\end{Verbatim}


\subsection*{Description}

This function returns a list of all of the fields of the record ``\verb&R&''.
It is particularly useful when you want to know if a record field
has been defined.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  rec := record[name := "David", number := 3728852, data := ["X","Y"] ];
/**/  fields(rec);
["data", "name", "number"]

/**/  rec.data;
["X", "Y"]

/**/  "surname" IsIn fields(rec);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  record(\ref{record} pg.\pageref{record}), 
    record field selector(\ref{record field selector} pg.\pageref{record field selector})
\end{command} % -- end command --------------------------------

\section{first}
\label{first}
\begin{command} % -- COMMAND: first ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
first(L: LIST): OBJECT
first(L: LIST, N: INT): OBJECT
\end{Verbatim}


\subsection*{Description}

In the first form the function returns the first element of the list
``\verb&L&'', same as ``\verb&L[1]&''.
In the second form, it returns the list of the first ``\verb&N&'' elements of ``\verb&L&'',
same as ``\verb&[ L[i] | i in 1..N ]&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [1,2,3,4,5];
/**/  first(L);
1

/**/  first(L,3);
[1, 2, 3]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  last(\ref{last} pg.\pageref{last}), 
    tail(\ref{tail} pg.\pageref{tail})
\end{command} % -- end command --------------------------------

\section{FirstNonZero}
\label{FirstNonZero}
\begin{command} % -- COMMAND: FirstNonZero ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FirstNonZero(V: MODULEELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the first non-zero entry of V.  If it
is handed a zero MODULEELEM then an error is signalled.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  R5 := NewFreeModule(R,5);
/**/  V := ModuleElem(R5, [0, 0, x^2+y*z, 0, z^2]);

/**/  FirstNonZero(V);
x^2 +y*z

/**/  FirstNonZeroPosn(V);
3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  FirstNonZeroPosn(\ref{FirstNonZeroPosn} pg.\pageref{FirstNonZeroPosn}), 
    IsZero(\ref{IsZero} pg.\pageref{IsZero}), 
    NonZero(\ref{NonZero} pg.\pageref{NonZero})
\end{command} % -- end command --------------------------------

\section{FirstNonZeroPosn}
\label{FirstNonZeroPosn}
\begin{command} % -- COMMAND: FirstNonZeroPosn ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FirstNonZeroPosn(V: MODULEELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the index of the first non-zero entry of V.  If it
is handed a zero MODULEELEM then an error is signalled.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  R5 := NewFreeModule(R,5);
/**/  V := ModuleElem(R5, [0, 0, x^2+y*z, 0, z^2]);

/**/  FirstNonZero(V);
x^2 +y*z

/**/  FirstNonZeroPosn(V);
3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  FirstNonZero(\ref{FirstNonZero} pg.\pageref{FirstNonZero}), 
    IsZero(\ref{IsZero} pg.\pageref{IsZero}), 
    NonZero(\ref{NonZero} pg.\pageref{NonZero})
\end{command} % -- end command --------------------------------

\section{FixedDivisor}
\label{FixedDivisor}
\begin{command} % -- COMMAND: FixedDivisor ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FixedDivisor(F: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the integer fixed divisor of the polynomial ``\verb&F&'';
that is the gcd of all ``\verb&F(n)&'' as ``\verb&n&'' runs through all integers.
\par 
The polynomial ``\verb&F&'' must have rational coefficients, and all values
``\verb&F(n)&'' must be integers.  Current bug: ``\verb&F&'' must be univariate.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  f := (x-1)*(x-2)*(x-3);
/**/  FixedDivisor(f);
3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  content(\ref{content} pg.\pageref{content})
\end{command} % -- end command --------------------------------

\section{flatten}
\label{flatten}
\begin{command} % -- COMMAND: flatten ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
flatten(L: LIST): LIST
flatten(L: LIST, N: INT): LIST
\end{Verbatim}


\subsection*{Description}

Components of lists may be lists themselves, \textit{i.e.}, lists may be
nested.  With one argument this function returns the list obtained
from the list ``\verb&L&'' by removing all nesting, bringing all elements \textbf{to
the top level}.  With the optional second argument, ``\verb&N&'', nesting is
removed down ``\verb&N&'' levels.
\par 
Thus, the elements of ``\verb&M := flatten(L,1)&'' are formed as follows:
go through the elements of ``\verb&L&'' one at a time; if an element is
not a list, add it to ``\verb&M&''; if an element is a list, add all of its
elements to ``\verb&M&''.
\par 
Higher levels are recursive: ``\verb&flatten(L, N) = flatten(flatten(L, N-1),1)&''.
For ``\verb&N&'' large enough ``\verb&flatten(L, N)&'' gives the same result as ``\verb&flatten(L)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  flatten([1,["a","b",[2,3,4],"c","d"],5,6]);
[1, "a", "b", 2, 3, 4, "c", "d", 5, 6]

/**/  L := [1,2, [3,4], [5, [6,7,[8,9]]]];
/**/  flatten(L,1);
[1, 2, 3, 4, 5, [6, 7, [8, 9]]]

/**/  flatten(It,1);
[1, 2, 3, 4, 5, 6, 7, [8, 9]]

/**/  flatten(L,2);  -- same as flatten(flatten(L,1),1)
[1, 2, 3, 4, 5, 6, 7, [8, 9]]

/**/  flatten(L,3);  -- same as flatten(L)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ConcatLists(\ref{ConcatLists} pg.\pageref{ConcatLists})
\end{command} % -- end command --------------------------------

\section{FloatApprox}
\label{FloatApprox}
\begin{command} % -- COMMAND: FloatApprox ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FloatApprox(X: INT|RAT|RINGELEM, PrecBits: INT): RAT
  \end{Verbatim}


\subsection*{Description}

This function computes an approximation of the form $M*2^E$ to a rational number
``\verb&X&'' where the mantissa satisfies $2^(PrecBits-1) \le  |M| < 2^PrecBits-1$ where
$PrecBits$ is the specified bit precision.  It gives 0 when applied to 0.
\par 
The updated version of this function is not backward compatible with the
old one; you must replace the 2nd arg by the number of bits you want in
the mantissa (see ``\verb&FloorLog2, FloorLog10, FloorLogBase&'' (\ref{FloorLog2, FloorLog10, FloorLogBase} pg.\pageref{FloorLog2, FloorLog10, FloorLogBase})).
The old fn is obsolescent and is now called ``\verb&FloatApprox10&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  FloatApprox(1/3, 10);
683/2048

/**/  FloatApprox(1/3, 20);
699051/2097152

/**/  FloatApprox(123456789,8);
123207680
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CFApprox(\ref{CFApprox} pg.\pageref{CFApprox}), 
    FloatStr(\ref{FloatStr} pg.\pageref{FloatStr}), 
    MantissaAndExponent2(\ref{MantissaAndExponent2} pg.\pageref{MantissaAndExponent2})
\end{command} % -- end command --------------------------------

\section{FloatStr}
\label{FloatStr}
\begin{command} % -- COMMAND: FloatStr ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FloatStr(X: INT|RAT|RINGELEM): STRING
FloatStr(X: INT|RAT|RINGELEM, Prec: INT): STRING
\end{Verbatim}


\subsection*{Description}

This function produces a decimal string representation of the rational
number ``\verb&X&''.  The optional second argument ``\verb&Prec&'' says how many
significant decimal digits to produce; the default number of digits is 5.

The aim is to produce an easily readable result.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  FloatStr(2/3);      -- last printed digit is rounded
0.66667

/**/  FloatStr(7^510);    -- no arbitrary limit on exponent range
1.0000*10^431

/**/  FloatStr(1/81, 35);    -- specify number of digits
0.012345679012345679012345679012345679
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  DecimalStr(\ref{DecimalStr} pg.\pageref{DecimalStr}), 
    ScientificStr(\ref{ScientificStr} pg.\pageref{ScientificStr}), 
    FloatApprox(\ref{FloatApprox} pg.\pageref{FloatApprox}), 
    MantissaAndExponent10(\ref{MantissaAndExponent10} pg.\pageref{MantissaAndExponent10})
\end{command} % -- end command --------------------------------

\section{floor}
\label{floor}
\begin{command} % -- COMMAND: floor ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
floor(X: RAT): INT
\end{Verbatim}


\subsection*{Description}

This function returns the greatest integer less than or equal to ``\verb&X&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  floor(0.99);
0

/**/  floor(1.01);
1

/**/  floor(-1);
-1

/**/  floor(-0.01);
-1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ceil(\ref{ceil} pg.\pageref{ceil}), 
    round(\ref{round} pg.\pageref{round}), 
    num(\ref{num} pg.\pageref{num}), 
    den(\ref{den} pg.\pageref{den}), 
    div(\ref{div} pg.\pageref{div}), 
    FloorSqrt(\ref{FloorSqrt} pg.\pageref{FloorSqrt}), 
    FloorRoot(\ref{FloorRoot} pg.\pageref{FloorRoot}), 
    FloorLog2, FloorLog10, FloorLogBase(\ref{FloorLog2, FloorLog10, FloorLogBase} pg.\pageref{FloorLog2, FloorLog10, FloorLogBase})
\end{command} % -- end command --------------------------------

\section{FloorLog2, FloorLog10, FloorLogBase}
\label{FloorLog2, FloorLog10, FloorLogBase}
\begin{command} % -- COMMAND: FloorLog2, FloorLog10, FloorLogBase ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FloorLog2(X: RAT): INT
FloorLog10(X: RAT): INT
FloorLogBase(X: RAT, base: INT): INT
\end{Verbatim}


\subsection*{Description}

These functions compute the integer part (floor) of the logarithm of a
rational number in a given base.  ``\verb&FloorLog2(X)&'' is just shorthand
for ``\verb&FloorLogBase(X,2)&''; similarly for ``\verb&FloorLog10&''.
\par 
NOTE: ``\verb&FloorLog10&'' may be useful for formatted printing as it
gives the number of digits (minus 1) in base 10; the signs of ``\verb&X&'' and
``\verb&base&'' are ignored.
\par 
These functions were called ``\verb&ILogBase&'' up to version CoCoA-5.1.2.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  FloorLog2(128);
7
/**/  FloorLog10(999);  -- number of digits minus 1
2
/**/  FloorLogBase(128,2);
7
/**/  FloorLogBase(81.5,3);
4
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{FloorRoot}
\label{FloorRoot}
\begin{command} % -- COMMAND: FloorRoot ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FloorRoot(N: INT, R: INT): INT
\end{Verbatim}


\subsection*{Description}

This function computes the ``\verb&R&''-th root of the non-negative integer ``\verb&N&''.
If the argument is not a perfect ``\verb&R&''-th power it returns the integer
part of the root (the floor of the real root).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  FloorRoot(25, 2);
5
/**/  FloorRoot(99, 3);
4
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  floor(\ref{floor} pg.\pageref{floor}), 
    FloorSqrt(\ref{FloorSqrt} pg.\pageref{FloorSqrt})
\end{command} % -- end command --------------------------------

\section{FloorSqrt}
\label{FloorSqrt}
\begin{command} % -- COMMAND: FloorSqrt ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FloorSqrt(N: INT): INT
\end{Verbatim}


\subsection*{Description}

This function computes the square root of an integer.  If the argument is
not a perfect square it returns the integer part of the square root.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  FloorSqrt(16);
4
/**/  FloorSqrt(99);
9
-- /**/  FloorSqrt(-1);  --> !!! ERROR !!! as expected: Value must be non-negative
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  floor(\ref{floor} pg.\pageref{floor}), 
    FloorRoot(\ref{FloorRoot} pg.\pageref{FloorRoot})
\end{command} % -- end command --------------------------------

\section{fold}
\label{fold}
\begin{command} % -- COMMAND: fold ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
fold(S: STRING, W: INT): STRING
\end{Verbatim}


\subsection*{Description}

This function copies a string inserting a newline every ``\verb&W&''
characters.  Together with ``\verb&sprint&'' (\ref{sprint} pg.\pageref{sprint}) it can be helpful for
displaying a long result more comprehensibly.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  n := factorial(100);
/**/  fold(sprint(n), 60);
933262154439441526816992388562667004907159682643816214685929
638952175999932299156089414639761565182862536979208272237582
51185210916864000000000000000000000000
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  FoldToListInput(\ref{FoldToListInput} pg.\pageref{FoldToListInput}), 
    sprint(\ref{sprint} pg.\pageref{sprint})
\end{command} % -- end command --------------------------------

\section{FoldToListInput}
\label{FoldToListInput}
\begin{command} % -- COMMAND: FoldToListInput ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FoldToListInput(S: STRING, W: INT): STRING
\end{Verbatim}


\subsection*{Description}

This function transforms a string so that it looks like a list
of short strings (length at most ``\verb&W&'').  Similar to ``\verb&fold&''
but the result is ready to be read by CoCoA.
\par 
WARNING: does not handle "funny" characters cleverly.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  n := factorial(100);
/**/  FoldToListInput(sprint(n), 60);
["933262154439441526816992388562667004907159682643816214685929",
"638952175999932299156089414639761565182862536979208272237582",
"51185210916864000000000000000000000000"]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ConcatStrings(\ref{ConcatStrings} pg.\pageref{ConcatStrings}), 
    fold(\ref{fold} pg.\pageref{fold}), 
    sprint(\ref{sprint} pg.\pageref{sprint})
\end{command} % -- end command --------------------------------

\section{for}
\label{for}
\begin{command} % -- COMMAND: for ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
For I := N_1 To N_2 Do C EndFor
For I := N_1 To N_2 Step D Do C EndFor

where I is the loop variable, N_1, N_2, and D are integer expressions,
and C is a sequence of commands.
\end{Verbatim}


\subsection*{Description}

In the first form, the loop variable ``\verb&I&'' is assigned the values
``\verb&N_1, N_1+1, ...,N_2&'' in succession.  After each assignment,
the command sequence ``\verb&C&'' is executed.  If ``\verb&N_2 < N_1&'', then
the command sequence ``\verb&C&'' is not executed.
\par 
The second form is almost the same, except that ``\verb&I&'' is assigned the
values ``\verb&N_1, N_1+D, N_1+2D&'', and so on, until the limit ``\verb&N_2&'' is
passed.  If ``\verb&N_2 - N_1&'' has opposite sign to ``\verb&D&'', then the command
sequence ``\verb&C&'' is not executed.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  for N := 1 to 5 do print 2^N, " "; endfor;
2 4 8 16 32

/**/  for n := 1 to 20 step 3 do print n, " "; endfor;
1 4 7 10 13 16 19

/**/  for N := 10 to 1 step -2 do print N, " "; endfor;
10 8 6 4 2

/**/  for N := 5 to 3 do print N, " "; endfor;  -- no output
\end{Verbatim}

Loops can be nested.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/   define MySort(ref L)
/**/     for i := 1 to len(L)-1 do
/**/       MaxPos := i;
/**/       for j := i+1 to len(L) do
/**/         if L[j] < L[MaxPos] then MaxPos := j; endif;
/**/       endfor;
/**/       if MaxPos <> i then
/**/         swap(ref L[i], ref L[MaxPos]);
/**/       endif;
/**/     endfor;
/**/   enddefine;

/**/  M := [5,3,1,4,2];
/**/  MySort(ref M);
/**/  M;
[1, 2, 3, 4, 5]
\end{Verbatim}

NOTE: we used ``\verb&ref L&'' so that the function can change the value
of the variable referenced by ``\verb&L&''.  See ``\verb&ref&'' (\ref{ref} pg.\pageref{ref}).

\SeeAlso %---- SEE ALSO ----
  foreach(\ref{foreach} pg.\pageref{foreach}), 
    repeat(\ref{repeat} pg.\pageref{repeat}), 
    All CoCoA commands(\ref{All CoCoA commands} pg.\pageref{All CoCoA commands}), 
    while(\ref{while} pg.\pageref{while})
\end{command} % -- end command --------------------------------

\section{foreach}
\label{foreach}
\begin{command} % -- COMMAND: foreach ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
foreach  X  in  L  do  CMDS  endforeach
where ``\verb&X&'' is a loop variable, ``\verb&L&'' is a LIST
\end{Verbatim}


\subsection*{Description}

The loop variable ``\verb&X&'' is assigned the value of each component
of ``\verb&L&'' in turn.  After each assignment the command sequence
``\verb&CMDS&'' is executed.
\par 
NOTE: the variable ``\verb&X&'' contains a \textbf{copy of the value} in the list;
changing ``\verb&X&'' will not change the list ``\verb&L&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  foreach N in 1..10 do  -- recall that 1..10 gives the list [1,2,...,10].
/**/    print N^2, " ";
/**/  endforeach;
1 4 9 16 25 36 49 64 81 100

/**/  use P ::= QQ[x,y,z];
/**/  f := x^2*y + 3*y^2*z - z^3;
/**/  J := [deriv(f, x) | x in indets(P)];
/**/  J;
[2*x*y, x^2 +6*y*z, 3*y^2 -3*z^2]

/**/  foreach g in J do
/**/    println g^2;
/**/  endforeach;
4*x^2*y^2
x^4 +12*x^2*y*z +36*y^2*z^2
9*y^4 -18*y^2*z^2 +9*z^4
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  for(\ref{for} pg.\pageref{for}), 
    List Constructors(\ref{List Constructors} pg.\pageref{List Constructors}), 
    repeat(\ref{repeat} pg.\pageref{repeat}), 
    All CoCoA commands(\ref{All CoCoA commands} pg.\pageref{All CoCoA commands}), 
    while(\ref{while} pg.\pageref{while})
\end{command} % -- end command --------------------------------

\section{format}
\label{format}
\begin{command} % -- COMMAND: format ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
format(E: OBJECT, N: INT): STRING
\end{Verbatim}


\subsection*{Description}

Like Sprint, this function converts the value of E into a string.  If
the string has fewer than N characters, then spaces are added to the
front to make the length N.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [5^n | n in 0..7];
/**/  foreach F in L do print format(F,8); endforeach;
       1       5      25     125     625    3125   15625   78125
/**/  M := format(L,20);
/**/  M;  -- "format" does not truncate
[1, 5, 25, 125, 625, 3125, 15625, 78125]
/**/  type(L);
LIST
/**/  type(M);
STRING
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  SprintTrunc(\ref{SprintTrunc} pg.\pageref{SprintTrunc}), 
    latex(\ref{latex} pg.\pageref{latex}), 
    sprint(\ref{sprint} pg.\pageref{sprint})
\end{command} % -- end command --------------------------------

\section{FrbAlexanderDual}
\label{FrbAlexanderDual}
\begin{command} % -- COMMAND: FrbAlexanderDual ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FrbAlexanderDual(I: IDEAL): LIST
FrbAlexanderDual(I: IDEAL, T: RINGELEM): LIST
\end{Verbatim}


\subsection*{Description}

Using the ``\verb&Frobby&'' (\ref{Frobby} pg.\pageref{Frobby}) library linked with CoCoALib.
Thanks to Bjarke Roune.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  I := ideal(x^2, x*y, y^2, z^2);
/**/  FrbAlexanderDual(I);
ideal(x^2*y*z, x*y^2*z)

/**/  FrbAlexanderDual(I, x^2*y^2*z^5);
ideal(x^2*y*z^4, x*y^2*z^4)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Frobby(\ref{Frobby} pg.\pageref{Frobby}), 
    FrbPrimaryDecomposition(\ref{FrbPrimaryDecomposition} pg.\pageref{FrbPrimaryDecomposition}), 
    PrimaryDecomposition(\ref{PrimaryDecomposition} pg.\pageref{PrimaryDecomposition})
\end{command} % -- end command --------------------------------

\section{FrbAssociatedPrimes}
\label{FrbAssociatedPrimes}
\begin{command} % -- COMMAND: FrbAssociatedPrimes ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FrbAssociatedPrimes(I: IDEAL): LIST
\end{Verbatim}


\subsection*{Description}

Using the ``\verb&Frobby&'' (\ref{Frobby} pg.\pageref{Frobby}) C++ library by Bjarke Roune.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x^2, x*y, y^2, z^2);
/**/  FrbAssociatedPrimes(I);
[ideal(x, y, z)]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Frobby(\ref{Frobby} pg.\pageref{Frobby}), 
    FrbIrreducibleDecomposition(\ref{FrbIrreducibleDecomposition} pg.\pageref{FrbIrreducibleDecomposition}), 
    FrbPrimaryDecomposition(\ref{FrbPrimaryDecomposition} pg.\pageref{FrbPrimaryDecomposition})
\end{command} % -- end command --------------------------------

\section{FrbIrreducibleDecomposition}
\label{FrbIrreducibleDecomposition}
\begin{command} % -- COMMAND: FrbIrreducibleDecomposition ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FrbIrreducibleDecomposition(I: IDEAL): LIST
\end{Verbatim}


\subsection*{Description}

Using the ``\verb&Frobby&'' (\ref{Frobby} pg.\pageref{Frobby}) C++ library by Bjarke Roune.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x^2, x*y, y^2, z^2);
/**/  FrbIrreducibleDecomposition(I);
[ideal(x, y^2, z^2), ideal(x^2, y, z^2)];

-- *** missing manual for these function: volunteers? ;-) ***
FrbDimension
FrbMultigradedHilbertPoincareNumerator
FrbTotalDegreeHilbertPoincareNumerator
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Frobby(\ref{Frobby} pg.\pageref{Frobby}), 
    FrbAssociatedPrimes(\ref{FrbAssociatedPrimes} pg.\pageref{FrbAssociatedPrimes}), 
    FrbIrreducibleDecomposition(\ref{FrbIrreducibleDecomposition} pg.\pageref{FrbIrreducibleDecomposition})
\end{command} % -- end command --------------------------------

\section{FrbMaximalStandardMonomials}
\label{FrbMaximalStandardMonomials}
\begin{command} % -- COMMAND: FrbMaximalStandardMonomials ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FrbMaximalStandardMonomials(I: IDEAL): LIST
\end{Verbatim}


\subsection*{Description}

Using the ``\verb&Frobby&'' (\ref{Frobby} pg.\pageref{Frobby}) library linked with CoCoALib.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  I := ideal(x^2, x*y, y^2, z^2);
/**/  FrbMaximalStandardMonomials(I);
ideal(y*z, x*z)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Frobby(\ref{Frobby} pg.\pageref{Frobby})
\end{command} % -- end command --------------------------------

\section{FrbPrimaryDecomposition}
\label{FrbPrimaryDecomposition}
\begin{command} % -- COMMAND: FrbPrimaryDecomposition ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FrbPrimaryDecomposition(I: IDEAL): LIST
\end{Verbatim}


\subsection*{Description}

Using the ``\verb&Frobby&'' (\ref{Frobby} pg.\pageref{Frobby}) C++ library by Bjarke Roune.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x^2, x*y^2, z^2);
/**/  FrbPrimaryDecomposition(I);
[ideal(x^2, y^2, z^2), ideal(x, z^2)]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Frobby(\ref{Frobby} pg.\pageref{Frobby}), 
    FrbAssociatedPrimes(\ref{FrbAssociatedPrimes} pg.\pageref{FrbAssociatedPrimes}), 
    FrbIrreducibleDecomposition(\ref{FrbIrreducibleDecomposition} pg.\pageref{FrbIrreducibleDecomposition}), 
    PrimaryDecomposition(\ref{PrimaryDecomposition} pg.\pageref{PrimaryDecomposition})
\end{command} % -- end command --------------------------------

\section{FrobeniusMat}
\label{FrobeniusMat}
\begin{command} % -- COMMAND: FrobeniusMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FrobeniusMat(I: IDEAL): MAT
FrobeniusMat(I: IDEAL, QB: LIST): MAT
\end{Verbatim}


\subsection*{Description}

The Frobenius map on ``\verb&R/I&'' sends ``\verb&f --> f^q&''.
This function computes the matrix of the Frobenius Map in ``\verb&R/I&'' where
``\verb&I&'' is a zero-dimensional ideal.  The second uses the given quotient
basis, otherwise the Macaulay basis is used.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= ZZ/(5)[x,y,z], Lex;
/**/  I := ideal(y^2-x*z, z^2-x^2*y, x+y+z-1);

/**/  FrobeniusMat(I);
matrix( /*RingWithID(3, "FFp(5)")*/
 [[1, 0, 0, 0, 0, 0],
  [0, -2, 2, -2, -1, 0],
  [0, 1, 2, -1, 2, 0],
  [0, 2, 2, -1, -1, 0],
  [0, 1, 1, -1, -2, 1],
  [0, 0, 0, 0, 0, 0]])

/**/  FrobeniusMat(I, [z^4, z^3, z^2, z, y, 1]);
matrix( /*RingWithID(3, "FFp(5)")*/
 [[-2, -1, 1, 1, 1, 0],
  [-1, -1, 2, 2, 0, 0],
  [2, -1, 2, 1, 0, 0],
  [-1, -2, 2, -2, 0, 0],
  [0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsIn(\ref{IsIn} pg.\pageref{IsIn}), 
    IsSubset(\ref{IsSubset} pg.\pageref{IsSubset})
\end{command} % -- end command --------------------------------

\section{FrobeniusNormSq}
\label{FrobeniusNormSq}
\begin{command} % -- COMMAND: FrobeniusNormSq ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FrobeniusNormSq(M: MAT): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function computes the \textbf{square of} the Frobenius norm of ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,2],[3,4]]);
/**/  FrobeniusNormSq(M);
30
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  HadamardBoundSq(\ref{HadamardBoundSq} pg.\pageref{HadamardBoundSq})
\end{command} % -- end command --------------------------------

\section{func}
\label{func}
\begin{command} % -- COMMAND: func ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
Func(ARGS) BODY EndFunc
  returns FUNCTION
\end{Verbatim}


\subsection*{Description}

This syntatic structure defines an anonymous function, \textit{i.e.} a function
without a name.  Anonymous functions can be passed as parameters,
assigned to variables, and returned as values.
\par 
To access variables outside the anonymous function use the commands
``\verb&ImportByRef, ImportByValue&'' (\ref{ImportByRef, ImportByValue} pg.\pageref{ImportByRef, ImportByValue}) or ``\verb&TopLevel&'' (\ref{TopLevel} pg.\pageref{TopLevel}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  square := Func(x) Return x^2; EndFunc;
/**/  square(3);
9

/**/  strings := ["x", "zzz", "yy"];
/**/  SortedBy(strings, Func(x,y) return len(x)>len(y); EndFunc);
["zzz", "yy", "x"]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  define(\ref{define} pg.\pageref{define}), 
    TopLevel(\ref{TopLevel} pg.\pageref{TopLevel}), 
    ImportByRef, ImportByValue(\ref{ImportByRef, ImportByValue} pg.\pageref{ImportByRef, ImportByValue})
\end{command} % -- end command --------------------------------

\section{Function [OBSOLETE]}
\label{Function [OBSOLETE]}
\begin{command} % -- COMMAND: Function [OBSOLETE] ------------



\subsection*{Description}

In CoCoA-5 functions are "first class objects", and so may be passed
like any other value -- the operator ``\verb&Function&'' serves no purpose.
\par 
In CoCoA-4 it was possible to have a variable and a function with the
same name; the operator ``\verb&Function&'' was used to instruct CoCoA-4
to search for the function of the given name, \textit{e.g.} to pass it as
an argument to another function.

\SeeAlso %---- SEE ALSO ----
  FUNCTIONs are first class objects(\ref{FUNCTIONs are first class objects} pg.\pageref{FUNCTIONs are first class objects}), 
    SortBy(\ref{SortBy} pg.\pageref{SortBy}), 
    SortedBy(\ref{SortedBy} pg.\pageref{SortedBy})
\end{command} % -- end command --------------------------------

\section{functions [OBSOLETE]}
\label{functions [OBSOLETE]}
\begin{command} % -- COMMAND: functions [OBSOLETE] ------------



\subsection*{Description}

Use ``\verb&describe&'' (\ref{describe} pg.\pageref{describe}).

\end{command} % -- end command --------------------------------

\section{FVector}
\label{FVector}
\begin{command} % -- COMMAND: FVector ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
FVector(A: LIST): RECORD
\end{Verbatim}


\subsection*{Description}

This function computes the f-Vector of a simplicial complex described by
a list of top faces.
\par 
Package ``\verb&GeomModelling&'', by Elisa Palezzato.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x[1..5]], DegLex;
/**/  L := [x[1]*x[2]*x[3], x[2]*x[3]*x[4], x[3]*x[4]*x[5]]; -- list top faces
/**/  FVector(L);
[1, 5, 7, 3]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  SimplexInfo(\ref{SimplexInfo} pg.\pageref{SimplexInfo})
\end{command} % -- end command --------------------------------

\chapter{G}  %----=== CHAPTER LETTER ===----
\label{G}

\section{GBasis}
\label{GBasis}
\begin{command} % -- COMMAND: GBasis ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GBasis(I: IDEAL|MODULE): LIST
\end{Verbatim}


\subsection*{Description}

This function returns a list whose components form a Groebner basis for
the ideal (or module) ``\verb&I&'' with respect to the term-ordering of the
polynomial ring of ``\verb&I&''.
\par 
If ``\verb&I&'' is a variable then the result is stored in ``\verb&I&'' for later use.
\par 
For the reduced Groebner basis, use the command ``ReducedGBasis'' (\ref{ReducedGBasis} pg.\pageref{ReducedGBasis}).
\par 
The coefficient ring must be a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use R ::= QQ[x,y];
/**/ I := ideal(x^4-x^2, x^3-y);
/**/ GBasis(I);
[x*y -y^2,  x^2 -y^2,  y^3 -y]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GBasisTimeout(\ref{GBasisTimeout} pg.\pageref{GBasisTimeout})
\end{command} % -- end command --------------------------------

\section{GBasisByHomog}
\label{GBasisByHomog}
\begin{command} % -- COMMAND: GBasisByHomog ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GBasisByHomog(I: IDEAL): LIST
\end{Verbatim}


\subsection*{Description}

Same as ``\verb&GBasis&'' (\ref{GBasis} pg.\pageref{GBasis}), but it is computed by homogenizing the
input generators, and then dehomogenizing the output.
\par 
Currently only for ``\verb&StdDegRevLex&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  I := ideal(x^4-x^2, x^3-y);
/**/  GBasisByHomog(I);
[-x^2 +x*y, -x*y +y^2, y^3 -y]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GBasis(\ref{GBasis} pg.\pageref{GBasis})
\end{command} % -- end command --------------------------------

\section{GBasisTimeout}
\label{GBasisTimeout}
\begin{command} % -- COMMAND: GBasisTimeout ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GBasisTimeout(I: IDEAL, TimeLimit: INT): LIST
GBasisTimeout(M: MODULE, TimeLimit: INT): LIST
\end{Verbatim}


\subsection*{Description}

Same as ``\verb&GBasis&'' (\ref{GBasis} pg.\pageref{GBasis}), but it will stop with an error if the
computation is not completed within the specified time limit (in seconds).
\par 
ONLY PARTIALLY IMPLEMENTED: only for ideals.  It is not yet possible to
resume the computation; you must restart it from the beginning.
\par 
For dealing with errors see ``\verb&try&'' (\ref{try} pg.\pageref{try}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[t,x,y,z];
/**/  I := ideal(t^3-x, t^4-y, t^5-z);
/**/  J := I^5;
-- /**/ G := GBasisTimeout(J, 0.1);
--> !!! ERROR !!! as expected: Computation exceeded given time limit

/**/  J := I^5;  G := GBasisTimeout(J, 10); --> OK
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GBasis(\ref{GBasis} pg.\pageref{GBasis}), 
    try(\ref{try} pg.\pageref{try})
\end{command} % -- end command --------------------------------

\section{GBM}
\label{GBM}
\begin{command} % -- COMMAND: GBM ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GBM(L: LIST): IDEAL
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function computes the intersection of ideals corresponding to
zero-dimensional schemes: GBM is for affine schemes, and ``\verb&HGBM&'' (\ref{HGBM} pg.\pageref{HGBM}) for
projective schemes.  The list L must be a list of ideals.  The function
``\verb&IntersectionList&'' (\ref{IntersectionList} pg.\pageref{IntersectionList}) should be used for computing the intersection of a
collection of general ideals.
\par 
The name GBM comes from the name of the algorithm used: Generalized
Buchberger-Moeller.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  I1 := IdealOfPoints(P, mat([[1,2,1], [0,1,0]])); -- a simple affine scheme
/**/  I2 := IdealOfPoints(P, mat([[1,1,1], [2,0,1]]))^2;-- another affine scheme

***** NOT YET IMPLEMENTED *****
  GBM([I1, I2]);                                  -- intersect the ideals
ideal(xz + yz - z^2 - x - y + 1,
 z^3 - 2z^2 + z,
 yz^2 - 2yz - z^2 + y + 2z - 1,
 y^2z - y^2 - yz + y,
 xy^2 + y^3 - 2x^2 - 5xy - 5y^2 + 2z^2 + 8x + 10y - 4z - 6,
 x^2y - y^3 + 2x^2 + 2xy + 4y^2 - 3z^2 - 8x - 8y + 6z + 5,
 x^3 + y^3 - 7x^2 - 5xy - 4y^2 + 5z^2 + 16x + 10y - 10z - 7,
 y^4 - 2y^3 - 4x^2 - 8xy - 3y^2 + 4z^2 + 16x + 16y - 8z - 12)
-------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IdealAndSeparatorsOfPoints(\ref{IdealAndSeparatorsOfPoints} pg.\pageref{IdealAndSeparatorsOfPoints}), 
    IdealAndSeparatorsOfProjectivePoints(\ref{IdealAndSeparatorsOfProjectivePoints} pg.\pageref{IdealAndSeparatorsOfProjectivePoints}), 
    IdealOfPoints(\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}), 
    IdealOfProjectivePoints(\ref{IdealOfProjectivePoints} pg.\pageref{IdealOfProjectivePoints}), 
    HGBM(\ref{HGBM} pg.\pageref{HGBM})
\end{command} % -- end command --------------------------------

\section{gcd}
\label{gcd}
\begin{command} % -- COMMAND: gcd ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
gcd(M: INT, N: INT): INT
gcd(L: LIST of INT): INT

gcd(F: RINGELEM, G: RINGELEM): RINGELEM
gcd(L: LIST of RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the greatest common divisor of its arguments
or of the elements in the list ``\verb&L&''.
For the calculation of the GCDs and LCMs of polynomials, the
coefficient ring must be a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  F := x^2-y^2;
/**/  G := (x+y)^3;
/**/  gcd(F, G);
x +y

/**/  gcd([3*4,3*8,6*16]);
12
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  div(\ref{div} pg.\pageref{div}), 
    mod(\ref{mod} pg.\pageref{mod}), 
    lcm(\ref{lcm} pg.\pageref{lcm}), 
    IsCoprime(\ref{IsCoprime} pg.\pageref{IsCoprime})
\end{command} % -- end command --------------------------------

\section{GenericPoints}
\label{GenericPoints}
\begin{command} % -- COMMAND: GenericPoints ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GenericPoints(R: RING, NumPoints: INT): LIST
GenericPoints(R: RING, NumPoints: INT, RandomRange: INT): LIST
\end{Verbatim}


\subsection*{Description}

``\verb&GenericPoints&'' returns a list of NumPoints generic projective points
with integer coordinates; it is not guaranteed that these points are
distinct.  RandomRange specifies the largest value any coordinate may
take.  If the second argument is omitted, the largest value possible
is 100 (or P-1 where P is the characteristic of the coefficient ring).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];  GenericPoints(R,7);
[[1, 0], [0, 1], [1, 1], [12, 59], [6, 63], [12, 80], [17, 63]]

/**/  GenericPoints(R,7,500);
[[1, 0], [0, 1], [1, 1], [220, 162], [206, 452], [98, 106], [403, 449]]

/**/  use R ::= ZZ/(5)[x,y,z];
/**/  GenericPoints(R,7);
[[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1], [2, 1, 1], [2, 2, 4], [3, 1, 3]]

/**/  GenericPoints(R,7,500);
[[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1], [1, 4, 2], [1, 3, 2], [2, 3, 3]]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{GenRepr}
\label{GenRepr}
\begin{command} % -- COMMAND: GenRepr ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GenRepr(X: RINGELEM, I: IDEAL): LIST of RINGELEM
GenRepr(X: MODULEELEM, I: MODULE): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns a list giving a representation of ``\verb&X&'' in terms of
``\verb&gens(I)&'': if ``\verb&X&'' is in ``\verb&I&'', then ``\verb&GenRepr&'' returns
a list ``\verb&[F_1,...,F_t]&'' such that (``\verb&[G_1,...,G_t] = gens(I)&'')
\begin{verbatim}
             X = F_1*G_1 + ... + F_t*G_t.
\end{verbatim}
If X is not in I, then ``\verb&GenRepr&'' returns the empty list, [].
\par 
NOTE: for a representation in terms of ``\verb&GBasis(I)&'' call ``\verb&DivAlg(X, GBasis(I))&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  I := ideal(x*y -2, x^2 -x*y);
/**/  GenRepr(x -y, I);
[(-1/2)*x +(1/2)*y, (1/2)*y]
/**/  ScalarProduct(It, gens(I));
x -y
/**/ ReducedGBasisRepr(x -y, I);
[1, 0]
/**/  ScalarProduct(It, ReducedGBasis(I));
x -y

/**/  K := NewFractionField(NewPolyRing(QQ, "a"));
/**/  use R ::= K[x,y];
/**/  L := [x+y^2, x^2-x*y];
/**/  GenRepr((a-2)*L[1] - (x-a)*L[2], ideal(L));
[a -2, -x +a]

/**/  R3 := NewFreeModule(R,3);
/**/  V1 := ModuleElem(R3, [x, y, y^2]);
/**/  V2 := ModuleElem(R3, [x-y, 0, x^2]);
/**/  V  := x^2*V1 - y^2*V2;
/**/  M := submodule(R3, [V1, V2]);
--/**/  GenRepr(V, M); -- ***** NOT YET IMPLEMENTED *****
--[x^2, -y^2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  DivAlg(\ref{DivAlg} pg.\pageref{DivAlg}), 
    IsIn(\ref{IsIn} pg.\pageref{IsIn}), 
    NF(\ref{NF} pg.\pageref{NF}), 
    syz(\ref{syz} pg.\pageref{syz}), 
    SyzOfGens(\ref{SyzOfGens} pg.\pageref{SyzOfGens})
\end{command} % -- end command --------------------------------

\section{gens}
\label{gens}
\begin{command} % -- COMMAND: gens ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
gens(I: IDEAL): LIST
gens(M: MODULE): LIST
\end{Verbatim}


\subsection*{Description}

This function returns a list of polynomials which generate the ideal
I or the module M.  The list is not necessarily minimal.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(y^2-x^3, x*y);
/**/  gens(I);
[-x^3 +y^2, x*y]

/**/  gens(I^2);
[x^6 -2x^3*y^2 +y^4, -x^4*y +x*y^3, x^2*y^2]

/**/  R3 := NewFreeModule(R, 3);
/**/  e := gens(R3);  // canonical basis
/**/  e[2];
[0, 1, 0]

/**/  M := SubmoduleRows(R3, mat([[x,y,z], [x-1,0,z]]));
/**/  gens(M);
[[x, y, z], [x -1, 0, z]]
/**/  shape(It);
[MODULEELEM, MODULEELEM]
/**/  GensAsRows(M);
matrix( /*RingDistrMPolyClean(QQ, 3)*/
 [[x, y, z],
  [x -1, 0, z]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GensAsCols, GensAsRows(\ref{GensAsCols, GensAsRows} pg.\pageref{GensAsCols, GensAsRows}), 
    IdealOfMinGens(\ref{IdealOfMinGens} pg.\pageref{IdealOfMinGens}), 
    SubmoduleOfMinGens(\ref{SubmoduleOfMinGens} pg.\pageref{SubmoduleOfMinGens})
\end{command} % -- end command --------------------------------

\section{GensAsCols, GensAsRows}
\label{GensAsCols, GensAsRows}
\begin{command} % -- COMMAND: GensAsCols, GensAsRows ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GensAsRows(M: MODULE): MAT
GensAsCols(M: MODULE): MAT
\end{Verbatim}


\subsection*{Description}

These functions returns a matrix which generate the module M
with the components as row (or colums) of a matrix.
\par 
The generators are not necessarily minimal.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  R3 := NewFreeModule(R, 3);
/**/  L := [[x,y,z], [x-1,0,z]];
/**/  M := SubmoduleRows(R3, mat(L));
/**/  gens(M);
[[x, y, z], [x -1, 0, z]]
/**/ shape(It);
[MODULEELEM, MODULEELEM]

/**/ GensAsRows(M);
matrix( /*RingDistrMPolyClean(QQ, 3)*/
 [[x, y, z],
  [x -1, 0, z]])

/**/ GensAsCols(M);
matrix( /*RingDistrMPolyClean(QQ, 3)*/
 [[x, x -1],
  [y, 0],
  [z, z]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  gens(\ref{gens} pg.\pageref{gens}), 
    SubmoduleCols, SubmoduleRows(\ref{SubmoduleCols, SubmoduleRows} pg.\pageref{SubmoduleCols, SubmoduleRows})
\end{command} % -- end command --------------------------------

\section{GensJacobian}
\label{GensJacobian}
\begin{command} % -- COMMAND: GensJacobian ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GensJacobian(Q: RINGELEM): LIST 
\end{Verbatim}


\subsection*{Description}

This function returns the list of generators of the Jacobian ideal of a polynomial Q.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ Q := x^3+2*x*y+3;
/**/ GensJacobian(Q);
[3*x^2 +2*y,  2*x,  x^3 +2*x*y +3]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{Get [OBSOLETE]}
\label{Get [OBSOLETE]}
\begin{command} % -- COMMAND: Get [OBSOLETE] ------------



\subsection*{Description}

Essentially replaced by ``\verb&GetLine&'' (\ref{GetLine} pg.\pageref{GetLine}).

\end{command} % -- end command --------------------------------

\section{GetCol}
\label{GetCol}
\begin{command} % -- COMMAND: GetCol ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GetCol(M: MAT, K: INT): LIST
\end{Verbatim}


\subsection*{Description}

This function makes a list containing the entries of the ``\verb&K&''-th column of ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,2], [3,4]]);
/**/  GetCol(M,2);
[2, 4]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GetRow(\ref{GetRow} pg.\pageref{GetRow}), 
    GetCols(\ref{GetCols} pg.\pageref{GetCols})
\end{command} % -- end command --------------------------------

\section{GetCols}
\label{GetCols}
\begin{command} % -- COMMAND: GetCols ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GetCols(M: MAT): LIST of LIST
\end{Verbatim}


\subsection*{Description}

This function produces a list of lists containing the columns of ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,2], [3,4]]);
/**/  GetCols(M);
[[1, 3], [2, 4]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GetCol(\ref{GetCol} pg.\pageref{GetCol}), 
    GetRows(\ref{GetRows} pg.\pageref{GetRows})
\end{command} % -- end command --------------------------------

\section{GetEnv}
\label{GetEnv}
\begin{command} % -- COMMAND: GetEnv ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GetEnv(S: STRING): STRING
\end{Verbatim}


\subsection*{Description}

This function returns the value of system shell variable whose name
is ``\verb&S&''.
\par 
CoCoA is normally started by its own shell script; so we recommend
using "export" to make your shell variables visible to CoCoA.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  GetEnv("HOME");
/Users/bigatti

/**/  GetEnv("SHELL");
/bin/bash
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  VersionInfo(\ref{VersionInfo} pg.\pageref{VersionInfo}), 
    SystemCommand(\ref{SystemCommand} pg.\pageref{SystemCommand})
\end{command} % -- end command --------------------------------

\section{GetErrMesg}
\label{GetErrMesg}
\begin{command} % -- COMMAND: GetErrMesg ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GetErrMesg(E: ERROR): STRING
\end{Verbatim}


\subsection*{Description}

This function returns the string containing the error message
associated with an error.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  ErrMsg := "";

  Try
    F := 1/0;
  UponError E Do
    ErrMsg := GetErrMesg(E);
  EndTry;  -- no error is thrown with Try .. UponError .. EndTry

/**/ ErrMsg;
Division by zero or by a zero-divisor
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  try(\ref{try} pg.\pageref{try}), 
    error(\ref{error} pg.\pageref{error})
\end{command} % -- end command --------------------------------

\section{GetLine}
\label{GetLine}
\begin{command} % -- COMMAND: GetLine ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GetLine(IN: ISTREAM): STRING
\end{Verbatim}


\subsection*{Description}

This function reads a line of input from the in-stream ``\verb&IN&'', and returns
the result as a string.  The string does not contain the end-of-line
character.  The function ``\verb&IsAtEOF&'' (\ref{IsAtEOF} pg.\pageref{IsAtEOF}) says whether the end of input has
been reached.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Istring := OpenIString("one\ntwo");
/**/  GetLine(Istring);  -- get the first line
one
/**/  GetLine(Istring);  -- get next line
two
/**/  IsAtEOF(Istring);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsAtEOF(\ref{IsAtEOF} pg.\pageref{IsAtEOF}), 
    OpenIFile(\ref{OpenIFile} pg.\pageref{OpenIFile}), 
    OpenIString(\ref{OpenIString} pg.\pageref{OpenIString}), 
    StandardInput(\ref{StandardInput} pg.\pageref{StandardInput})
\end{command} % -- end command --------------------------------

\section{GetRow}
\label{GetRow}
\begin{command} % -- COMMAND: GetRow ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GetRow(M: MAT, K: INT): LIST
\end{Verbatim}


\subsection*{Description}

This function makes a list containing the entries of the ``\verb&K&''-th row of ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,2], [3,4]]);
/**/  GetRow(M,2);
[3, 4]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GetRows(\ref{GetRows} pg.\pageref{GetRows}), 
    SetRow(\ref{SetRow} pg.\pageref{SetRow})
\end{command} % -- end command --------------------------------

\section{GetRows}
\label{GetRows}
\begin{command} % -- COMMAND: GetRows ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GetRows(M: MAT): LIST of LIST
\end{Verbatim}


\subsection*{Description}

This function produces a list of lists containing the rows of ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,2], [3,4]]);
/**/  GetRows(M);
[[1, 2], [3, 4]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GetRow(\ref{GetRow} pg.\pageref{GetRow})
\end{command} % -- end command --------------------------------

\section{GFanContainsPositiveVector}
\label{GFanContainsPositiveVector}
\begin{command} % -- COMMAND: GFanContainsPositiveVector ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GFanContainsPositiveVector(EqMat: MAT, IneqMat: MAT): INT
\end{Verbatim}


\subsection*{Description}

...to do..

\end{command} % -- end command --------------------------------

\section{GFanGeneratorsOfLinealitySpace}
\label{GFanGeneratorsOfLinealitySpace}
\begin{command} % -- COMMAND: GFanGeneratorsOfLinealitySpace ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GFanGeneratorsOfLinealitySpace(EqMat: MAT, IneqMat: MAT): MAT
\end{Verbatim}


\subsection*{Description}

...to do..

\end{command} % -- end command --------------------------------

\section{GFanGeneratorsOfSpan}
\label{GFanGeneratorsOfSpan}
\begin{command} % -- COMMAND: GFanGeneratorsOfSpan ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GFanGeneratorsOfSpan(EqMat: MAT, IneqMat: MAT): MAT
\end{Verbatim}


\subsection*{Description}

...to do..

\end{command} % -- end command --------------------------------

\section{GFanGetAmbientDimension}
\label{GFanGetAmbientDimension}
\begin{command} % -- COMMAND: GFanGetAmbientDimension ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GFanGetAmbientDimension(EqMat: MAT, IneqMat: MAT): INT
\end{Verbatim}


\subsection*{Description}

...to do..

\end{command} % -- end command --------------------------------

\section{GFanGetCodimension}
\label{GFanGetCodimension}
\begin{command} % -- COMMAND: GFanGetCodimension ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GFanGetCodimension(EqMat: MAT, IneqMat: MAT): INT
\end{Verbatim}


\subsection*{Description}

...to do..

\end{command} % -- end command --------------------------------

\section{GFanGetDimension}
\label{GFanGetDimension}
\begin{command} % -- COMMAND: GFanGetDimension ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GFanGetDimension(EqMat: MAT, IneqMat: MAT): INT
\end{Verbatim}


\subsection*{Description}

...to do..

\end{command} % -- end command --------------------------------

\section{GFanGetDimensionOfLinealitySpace}
\label{GFanGetDimensionOfLinealitySpace}
\begin{command} % -- COMMAND: GFanGetDimensionOfLinealitySpace ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GFanGetDimensionOfLinealitySpace(EqMat: MAT, IneqMat: MAT): INT
\end{Verbatim}


\subsection*{Description}

...to do..

\end{command} % -- end command --------------------------------

\section{GFanGetFacets}
\label{GFanGetFacets}
\begin{command} % -- COMMAND: GFanGetFacets ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GFan(EqMat: MAT, IneqMat: MAT): MAT
\end{Verbatim}


\subsection*{Description}

...to do..

\end{command} % -- end command --------------------------------

\section{GFanGetImpliedEquations}
\label{GFanGetImpliedEquations}
\begin{command} % -- COMMAND: GFanGetImpliedEquations ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GFanGetImpliedEquations(EqMat: MAT, IneqMat: MAT): MAT
\end{Verbatim}


\subsection*{Description}

...to do..

\end{command} % -- end command --------------------------------

\section{GFanGetUniquePoint}
\label{GFanGetUniquePoint}
\begin{command} % -- COMMAND: GFanGetUniquePoint ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GFanGetUniquePoint(EqMat: MAT, IneqMat: MAT): MAT
\end{Verbatim}


\subsection*{Description}

...to do..

\end{command} % -- end command --------------------------------

\section{GFanRelativeInteriorPoint}
\label{GFanRelativeInteriorPoint}
\begin{command} % -- COMMAND: GFanRelativeInteriorPoint ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GFanRelativeInteriorPoint(EqMat: MAT, IneqMat: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns a column matrix whose entries are the coordinates
of a relative interior point of the cone described by ``\verb&IneqMat&''
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ GFanRelativeInteriorPoint(matrix([[1,2,3]]), matrix([[1,0,2],[2,-1,-1]]));
matrix(ZZ,
 [[2],
  [5],
  [-1]])
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{gin}
\label{gin}
\begin{command} % -- COMMAND: gin ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
gin(I: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

These functions return the [probabilistic] gin (generic initial ideal)
of the ideal ``\verb&I&''.
It is obtained by computing twice the leading term ideal of $g(I)$,
where $g$ is a random change of coordinates with
integer coefficients in the range $[-10^6, 10^6]$
using TwinFloats (see ``\verb&NewRingTwinFloat&'' (\ref{NewRingTwinFloat} pg.\pageref{NewRingTwinFloat})) to allow a much
wider range of coefficients than a direct computation over the
rationals (use second argument to see the TwinFloat precision needed).
\par 
See ``\verb&rgin&'' (\ref{rgin} pg.\pageref{rgin}) for computing wrt DegRevLex independently of
the current ring.
\par 
Verbosity:\par 
with verbosity ``\verb&>=50&'' it prints\par 
the two random changes of coordinates used\par 
and the ``\verb&NewRingTwinFloat&'' (\ref{NewRingTwinFloat} pg.\pageref{NewRingTwinFloat}) precision used. 
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  gin(ideal(y^2-x*z, x^2*z-y*z^2));  -- computed twice using TwinFloats
ideal(x^2, x*y^2, y^4)

/**/  SetVerbosityLevel(50); --> get some internal progress information
/**/  gin(ideal(y^7-x^4*z^3, x^5*z-y*z^5));
RandIdeal: g = [
  -439946*x,
  742383*x -909613*y,
  129429*x +49607*y +832207*z
]
TryPrecisions: -- trying with FloatPrecision 64
RandIdeal: g = [
  -187890*x,
  -127769*x +272107*y,
  377492*x +778394*y -547019*z
]
TryPrecisions: -- trying with FloatPrecision 64
ideal(x^6, x^5*y^2, x^4*y^4, x^3*y^6, x^2*y^8, x*y^10, y^12)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewRingTwinFloat(\ref{NewRingTwinFloat} pg.\pageref{NewRingTwinFloat}), 
    rgin(\ref{rgin} pg.\pageref{rgin})
\end{command} % -- end command --------------------------------

\section{GinJacobian}
\label{GinJacobian}
\begin{command} % -- COMMAND: GinJacobian ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GensJacobian(Q: RINGELEM): IDEAL 
\end{Verbatim}


\subsection*{Description}

This function returns the generic initial ideal of the Jacobian ideal of a polynomial Q.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y,z];	
/**/ Q := x^3;
/**/ GinJacobian(Q);
ideal(x^2)
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{GradingDim}
\label{GradingDim}
\begin{command} % -- COMMAND: GradingDim ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GradingDim(P): INT
\end{Verbatim}


\subsection*{Description}

This function returns the grading dimension of a polynomial ring, \textit{i.e.}
how many of the rows of the order matrix of ``\verb&P&'' are to be taken as
specifying the grading.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  OrdM := MakeTermOrdMat(RowMat([2,3]));
/**/  P := NewPolyRing(QQ, "x,y", OrdM, 1);
/**/  GradingDim(P);
1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing}), 
    GradingMat(\ref{GradingMat} pg.\pageref{GradingMat})
\end{command} % -- end command --------------------------------

\section{GradingMat}
\label{GradingMat}
\begin{command} % -- COMMAND: GradingMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GradingMat(R: RING): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the grading matrix (or weights matrix) for the
polynomials ring ``\verb&R&''.
To define a ring with (multi)weights use ``\verb&NewPolyRing&'' (\ref{NewPolyRing} pg.\pageref{NewPolyRing}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  OrdM := MakeTermOrdMat(RowMat([2,3]));  OrdM;
matrix(ZZ,
 [[2, 3],
  [0, -1]])
/**/  P := NewPolyRing(QQ, "x,y", OrdM, 1);  -- GradingDim = 1
/**/  GradingMat(P);
matrix(ZZ,
 [[2, 3]])

/**/  use P;
/**/  deg(x*y);
2
/**/  wdeg(x*y);
[5]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  deg(\ref{deg} pg.\pageref{deg}), 
    wdeg(\ref{wdeg} pg.\pageref{wdeg}), 
    GradingDim(\ref{GradingDim} pg.\pageref{GradingDim}), 
    NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing})
\end{command} % -- end command --------------------------------

\section{graeffe}
\label{graeffe}
\begin{command} % -- COMMAND: graeffe ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
graeffe(R RINGELEM): RINGELEM
graeffe3(R RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

The function ``\verb&graeffe&'' applies the graeffe transformation to the
univariate polynomial ``\verb&F&''.  The result is a univariate polynomial
whose roots are the squares of the roots of ``\verb&F&''.
\par 
The similar function ``\verb&graeffe3&'' produces the polynomial whose roots
are the cubes of the roots of ``\verb&F&''
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x];
/**/  f := x^3-3*x^2+5*x-7;
/**/  graeffe(f);
x^3 +x^2 -17*x -49
/**/  graeffe3(f);
x^3 -3*x^2 -43*x -343
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  RootBound(\ref{RootBound} pg.\pageref{RootBound})
\end{command} % -- end command --------------------------------

\section{GraverBasis}
\label{GraverBasis}
\begin{command} % -- COMMAND: GraverBasis ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GraverBasis(M: MAT): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

These function return the Graver basis, computed with ``\verb&toric&'' (\ref{toric} pg.\pageref{toric}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= ZZ/(2)[x,y,z];
/**/  toric(P, mat([[1,3,2]]));
ideal(-x^2 +z, x^3 -y)
/**/  GraverBasis(P, mat([[1,3,2]]));
[x^2 -z, x*z -y, x^3 -y, x*y -z^2, z^3 -y^2]
/**/  UniversalGBasis(toric(P, mat([[1,3,2]])));
[x*z -y, x*y -z^2, x^2 -z, z^3 -y^2, x^3 -y]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  toric(\ref{toric} pg.\pageref{toric}), 
    HilbertBasisKer(\ref{HilbertBasisKer} pg.\pageref{HilbertBasisKer})
\end{command} % -- end command --------------------------------

\section{GroebnerFanIdeals}
\label{GroebnerFanIdeals}
\begin{command} % -- COMMAND: GroebnerFanIdeals ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GroebnerFanIdeals(I: IDEAL): LIST of IDEAL
\end{Verbatim}


\subsection*{Description}

Returns a LIST of ideals, one for each possible distinct reduced Groebner
basis of ``\verb&I&''; each ideal is in a different ring (one ring for each
term-ordering), and has as its generators the corresponding GBasis.
\par 
See also ``\verb&CallOnGroebnerFanIdeals&'' (\ref{CallOnGroebnerFanIdeals} pg.\pageref{CallOnGroebnerFanIdeals}) for a way of computing with each
ideal in succession (but without storing the whole list).
\par 
Verbosity:\par 
``\verb&*&'' with verbosity ``\verb&>=10&'' (recursive, CallOnRecursive)\par 
``\verb&.&'' with verbosity ``\verb&>=20&'' (GetFlippableInequalities)\par 
``\verb&maxdeg&'' with verbosity ``\verb&>=80&'' (GetFlippableInequalities)
\par 
timings with verbosity ``\verb&>=90&''  (GroebnerFanIdeals, CallOnGroebnerFanIdeals)
\par 
This function used to be called ``\verb&AllReducedGroebnerBases&''
up to version CoCoA-5.1.4, and used to return the ideals encoded with the
same set of generators as ``\verb&I&'' (now generated by GBasis).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[a,b,c];
/**/  I := ideal(b^3+c^2-1, b^2+a^2+c-1, a^2+b^3-1);
/**/  GF := GroebnerFanIdeals(I);
/**/  [ len(GBasis(I)) | I in GF];
[4, 4, 6, 6, 5, 6, 4, 4, 4, 3, 4, 3, 3, 3, 4, 3, 3]
/**/  OrdMat(RingOf(GF[1])); --> matrix of the term-ordering
matrix(ZZ,
 [[1, 1, 1],
  [0, 0, -1],
  [0, -1, 0]])
  
-- The ideal in [Sturmfels, Example 3.9] has 360 marked reduced Groebner bases
/**/  use R ::= QQ[a,b,c];
/**/  I := ideal(a^5+b^3+c^2-1, b^2+a^2+c-1, c^3+a^6+b^5-1);
/**/  GF := GroebnerFanIdeals(I);
/**/  len(GF);
360
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  OrdMat(\ref{OrdMat} pg.\pageref{OrdMat}), 
    RingOf(\ref{RingOf} pg.\pageref{RingOf}), 
    UniversalGBasis(\ref{UniversalGBasis} pg.\pageref{UniversalGBasis})
\end{command} % -- end command --------------------------------

\section{GroebnerFanReducedGBases}
\label{GroebnerFanReducedGBases}
\begin{command} % -- COMMAND: GroebnerFanReducedGBases ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
GroebnerFanReducedGBases(I: IDEAL): LIST of IDEAL
\end{Verbatim}


\subsection*{Description}

This function returns a list of all reduced GBases.  It is good for
\textbf{visualizing} small examples; however, for further computations
with the different bases it is better to use ``\verb&GroebnerFanIdeals&'' (\ref{GroebnerFanIdeals} pg.\pageref{GroebnerFanIdeals})
or ``\verb&CallOnGroebnerFanIdeals&'' (\ref{CallOnGroebnerFanIdeals} pg.\pageref{CallOnGroebnerFanIdeals}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use R ::= QQ[a,b,c];
/**/ I := ideal(b^2-1, a^2+c-1, c^2-b);
/**/ indent(GroebnerFanReducedGBases(I));
[
  [c^2 -b, b^2 -1, a^2 +c -1],
  [b -c^2, a^2 +c -1, c^4 -1],
  [c +a^2 -1, b -a^4 +2*a^2 -1, a^8 -4*a^6 +6*a^4 -4*a^2],
  [c +a^2 -1, b^2 -1, a^4 -b -2*a^2 +1]
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CallOnGroebnerFanIdeals(\ref{CallOnGroebnerFanIdeals} pg.\pageref{CallOnGroebnerFanIdeals}), 
    GroebnerFanIdeals(\ref{GroebnerFanIdeals} pg.\pageref{GroebnerFanIdeals})
\end{command} % -- end command --------------------------------

\chapter{H}  %----=== CHAPTER LETTER ===----
\label{H}

\section{HadamardBoundSq}
\label{HadamardBoundSq}
\begin{command} % -- COMMAND: HadamardBoundSq ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HadamardBoundSq(M: MAT): RECORD
\end{Verbatim}


\subsection*{Description}

This computes \textbf{square of} the Hadamard determinant bound (both for rows
and for columns).  The result is a record with two fields
``\verb&HadamardColBound&'' and ``\verb&HadamardRowBound&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,2],[3,4]]);
/**/  HadamardBoundSq(M);
record[HadamardColBound := 200, HadamardRowBound := 125]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  det(\ref{det} pg.\pageref{det})
\end{command} % -- end command --------------------------------

\section{HasGBasis}
\label{HasGBasis}
\begin{command} % -- COMMAND: HasGBasis ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HasGBasis(I: IDEAL): BOOL
\end{Verbatim}


\subsection*{Description}

After the ``\verb&GBasis&'' (\ref{GBasis} pg.\pageref{GBasis}) of ``\verb&I&'' is (explicitly or implicitly)
computed, it is stored within ``\verb&I&'' for future use.
This function says whether the GBasis of ``\verb&I&'' has been stored.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x^20 -x*y -1, x^10*y^10 -x*z -1,  x^10*z^10 -x*z -1);
/**/  HasGBasis(I);
false
/**/  t0 := CpuTime(); GB := GBasis(I); TimeFrom(t0);
0.948
/**/  HasGBasis(I);
true
/**/  t0 := CpuTime(); GB := GBasis(I); TimeFrom(t0);
0.007
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IdealOfGBasis(\ref{IdealOfGBasis} pg.\pageref{IdealOfGBasis})
\end{command} % -- end command --------------------------------

\section{HColon}
\label{HColon}
\begin{command} % -- COMMAND: HColon ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HColon(M: IDEAL, N: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
The function ``\verb&colon&'' (\ref{colon} pg.\pageref{colon}) returns the quotient of M by N:
the ideal of all polynomials F such that F*G is in M for all G in N.
\par 
This function computes the same ideal using a Hilbert-driven
algorithm. It differs from ``\verb&colon&'' (\ref{colon} pg.\pageref{colon}) only when the input
is non-homogeneous, in which case, ``\verb&HColon&'' may be faster.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/   use R ::= QQ[x,y];
/**/   ideal(x*y, x^2) : ideal(x);
ideal(y,  x)
/**/   colon(ideal(x^2, x*y), ideal(x, x-y^2));
ideal(x)
***** NOT YET IMPLEMENTED *****
  HColon(ideal(x^2, x*y), ideal(x, x-y^2));
ideal(x)
-------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  HSaturation(\ref{HSaturation} pg.\pageref{HSaturation}), 
    saturate(\ref{saturate} pg.\pageref{saturate}), 
    HColon(\ref{HColon} pg.\pageref{HColon}), 
    colon(\ref{colon} pg.\pageref{colon})
\end{command} % -- end command --------------------------------

\section{HermitePoly}
\label{HermitePoly}
\begin{command} % -- COMMAND: HermitePoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HermitePoly(N: INT, X: RINGELEM): RINGELEM
HermitePoly2(N: INT, X: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

The function ``\verb&HermitePoly&'' returns the ``\verb&N&''-th Hermite polynomial (as used
in physics); the function ``\verb&HermitePoly2&'' returns the ``\verb&N&''-th Hermite
polynomial (as used in probability).
\par 
These functions also work if ``\verb&X&'' is not an indeterminate: the result
is then the evaluation of the polynomial at the given value.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  HermitePoly(3,x);
8*x^3 -12*x
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ChebyshevPoly(\ref{ChebyshevPoly} pg.\pageref{ChebyshevPoly}), 
    LaguerrePoly(\ref{LaguerrePoly} pg.\pageref{LaguerrePoly})
\end{command} % -- end command --------------------------------

\section{HGBM}
\label{HGBM}
\begin{command} % -- COMMAND: HGBM ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HGBM(L: LIST): IDEAL
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function computes the intersection of ideals corresponding to
zero-dimensional schemes: ``\verb&GBM&'' (\ref{GBM} pg.\pageref{GBM}) is for affine schemes, and HGBM for
projective schemes.  The list L must be a list of ideals.  The function
``\verb&IntersectionList&'' (\ref{IntersectionList} pg.\pageref{IntersectionList}) should be used for computing the intersection of a
collection of general ideals.
\par 
The name GBM comes from the name of the algorithm used: Generalized
Buchberger-Moeller.  The prefix H comes from Homogeneous since ideals
of projective schemes are necessarily homogeneous.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  use P := QQ[x[0..2]];
  I1 := IdealOfProjectivePoints(P, [[1,2,1], [0,1,0]]);   -- simple projective scheme
  I2 := IdealOfProjectivePoints(P, [[1,1,1], [2,0,1]])^2; -- another projective scheme
  HGBM([I1, I2]);                                      -- intersect the ideals
ideal(x[0]^3 - x[0]x[1]^2 - 5x[0]^2x[2] + x[1]^2x[2] + 8x[0]x[2]^2 - 4x[2]^3,
 x[0]^2x[1] + x[0]x[1]^2 - 3x[0]x[1]x[2] - x[1]^2x[2] + 2x[1]x[2]^2,
 x[0]x[1]^3 - 2x[0]^2x[2]^2 - 5x[0]x[1]x[2]^2 - 4x[1]^2x[2]^2 +
8x[0]x[2]^3 + 10x[1]x[2]^3 - 8x[2]^4,
 x[0]x[1]^2x[2] + x[1]^3x[2] - 2x[0]^2x[2]^2 - 5x[0]x[1]x[2]^2
- 5x[1]^2x[2]^2 + 8x[0]x[2]^3 + 10x[1]x[2]^3 - 8x[2]^4,
 x[1]^4x[2] - 2x[1]^3x[2]^2 - 4x[0]^2x[2]^3 - 8x[0]x[1]x[2]^3
- 3x[1]^2x[2]^3 + 16x[0]x[2]^4 + 16x[1]x[2]^4 - 16x[2]^5)
-------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IdealAndSeparatorsOfPoints(\ref{IdealAndSeparatorsOfPoints} pg.\pageref{IdealAndSeparatorsOfPoints}), 
    IdealAndSeparatorsOfProjectivePoints(\ref{IdealAndSeparatorsOfProjectivePoints} pg.\pageref{IdealAndSeparatorsOfProjectivePoints}), 
    IdealOfPoints(\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}), 
    IdealOfProjectivePoints(\ref{IdealOfProjectivePoints} pg.\pageref{IdealOfProjectivePoints}), 
    GBM(\ref{GBM} pg.\pageref{GBM})
\end{command} % -- end command --------------------------------

\section{hilbert [OBSOLESCENT]}
\label{hilbert [OBSOLESCENT]}
\begin{command} % -- COMMAND: hilbert [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&HilbertFn&'' (\ref{HilbertFn} pg.\pageref{HilbertFn}).

\end{command} % -- end command --------------------------------

\section{HilbertBasisKer}
\label{HilbertBasisKer}
\begin{command} % -- COMMAND: HilbertBasisKer ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HilbertBasisKer(M: MAT): LIST
\end{Verbatim}


\subsection*{Description}

This function returns a list whose components are lists (of
non-negative integers) representing the Hilbert basis for the monoid
of elements with non-negative coordinates in the kernel of ``\verb&M&'',
matrix over ``\verb&ZZ&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,-2,3,4], [1, 0, 0, -1]]);
/**/  HilbertBasisKer(M);
[[0, 3, 2, 0], [1, 4, 1, 1], [2, 5, 0, 2]]

/**/  M * transposed(mat(It));
matrix(QQ,
 [[0, 0, 0],
  [0, 0, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LinKerBasis(\ref{LinKerBasis} pg.\pageref{LinKerBasis}), 
    NmzHilbertBasis(\ref{NmzHilbertBasis} pg.\pageref{NmzHilbertBasis})
\end{command} % -- end command --------------------------------

\section{HilbertFn}
\label{HilbertFn}
\begin{command} % -- COMMAND: HilbertFn ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HilbertFn(R: RING|IDEAL): TAGGED("$hp.Hilbert")
HilbertFn(R: RING|IDEAL, N: INT): INT
\end{Verbatim}


\subsection*{Description}

The first form of this function computes the Hilbert function for R.
The second form computes the N-th value of the Hilbert function.  The
weights of the indeterminates of R must all be 1.  If the input is not
homogeneous, the Hilbert function of the corresponding leading term
(initial) ideal or module is calculated.  For repeated evaluations of
the Hilbert function, use ``\verb&EvalHilbertFn&'' (\ref{EvalHilbertFn} pg.\pageref{EvalHilbertFn}) instead
of ``\verb&HilbertFn(R, N)&'' in order to speed up execution.
\par 
The coefficient ring must be a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[t,x,y,z];
/**/  HilbertFn(R/ideal(z^2-x*y, x*z^2+t^3));
H(0) = 1
H(1) = 4
H(t) = 6*t -3   for t >= 2

/**/  R2 := NewFreeModule(R, 2);
/**/  MGens := matrix(R, [[x^3,y^3], [x*y^2,0], [0,z^3]]);
/**/  M := SubmoduleRows(R2, MGens);
/**/  HilbertFn(M);
H(0) = 0
H(1) = 0
H(2) = 0
H(3) = 3
H(4) = 12
H(t) = (1/3)*t^3 +(3/2)*t^2 +(-101/6)*t +35   for t >= 5

/**/  HilbertFn(M,3);
3
/**/  HilbertFn(M,5);
30
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  EvalHilbertFn(\ref{EvalHilbertFn} pg.\pageref{EvalHilbertFn}), 
    HilbertPoly(\ref{HilbertPoly} pg.\pageref{HilbertPoly}), 
    HVector(\ref{HVector} pg.\pageref{HVector}), 
    HilbertSeries(\ref{HilbertSeries} pg.\pageref{HilbertSeries})
\end{command} % -- end command --------------------------------

\section{HilbertMat}
\label{HilbertMat}
\begin{command} % -- COMMAND: HilbertMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HilbertMat(N: INT): MAT over QQ
\end{Verbatim}


\subsection*{Description}

This function returns the ``\verb&n&''-by-``\verb&n&'' Hilbert matrix over ``\verb&QQ&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  HilbertMat(3);
matrix(QQ,
 [[1, 1/2, 1/3],
  [1/2, 1/3, 1/4],
  [1/3, 1/4, 1/5]])
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{HilbertPoly}
\label{HilbertPoly}
\begin{command} % -- COMMAND: HilbertPoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HilbertPoly(R: (Poly or Quotient)RING): RINGELEM in the ring QQt
\end{Verbatim}


\subsection*{Description}

This function returns the Hilbert polynomial for R as a polynomial in
the standard CoCoA ring ``\verb&QQt&'' (= QQ[t]).
\par 
The weights of the indeterminates of ``\verb&R&'' must all be 1, and the
coefficient ring must be a field.
\par 
If the input is not homogeneous, the Hilbert polynomial of the
corresponding leading term (initial) ideal or module is calculated.
For the Hilbert *function*, see ``\verb&HilbertFn&'' (\ref{HilbertFn} pg.\pageref{HilbertFn}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[w,x,y,z];
/**/  I := ideal(z^2-x*y, x*z^2+w^3);
/**/  HilbertFn(R/I);
H(0) = 1
H(1) = 4
H(t) = 6*t-3   for t >= 2

/**/  F := HilbertPoly(R/I);
/**/  F;  -- a polynomial in the ring Qt
6*t-3

/**/ T := indet(RingOf(F), 1);
/**/ subst(F, T, 3);
15
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  EvalHilbertFn(\ref{EvalHilbertFn} pg.\pageref{EvalHilbertFn}), 
    HilbertFn(\ref{HilbertFn} pg.\pageref{HilbertFn}), 
    HVector(\ref{HVector} pg.\pageref{HVector}), 
    HilbertSeries(\ref{HilbertSeries} pg.\pageref{HilbertSeries}), 
    RingQQt(\ref{RingQQt} pg.\pageref{RingQQt})
\end{command} % -- end command --------------------------------

\section{HilbertSeries}
\label{HilbertSeries}
\begin{command} % -- COMMAND: HilbertSeries ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HilbertSeries(M: MODULE|IDEAL|RING): TAGGED("$hp.PSeries")
\end{Verbatim}


\subsection*{Description}

This function computes the Hilbert-Poincare series of ``\verb&M&''.
The input, ``\verb&M&'', must be homogeneous (with respect to the first row of
the weights matrix).  In the standard case, \textit{i.e.} the weights of all
indeterminates are 1, the result is simplified so that the power
appearing in the denominator is the dimension of ``\verb&M&''.
\par 
NOTE: for the local case see ``\verb&PrimaryHilbertSeries&'' (\ref{PrimaryHilbertSeries} pg.\pageref{PrimaryHilbertSeries}).
\par 
NOTES:
\par 
(i) the coefficient ring must be a field.
\par 
(ii) these functions produce tagged objects: they cannot safely be
     tested for (non-)equality to other values.
\par 
Starting from release 4.7.5 the input may also be an ideal.
\par 
For more information, see the article: A.M. Bigatti, "Computations of
Hilbert-Poincare Series" J. Pure Appl. Algebra, 119/3 (1997),
237--253.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[t,x,y,z]; -- standard weights
/**/  HilbertSeries(R/ideal(R,[]));
(1) / (1-t)^4

/**/  HilbertSeries(R/ideal(t^2, x, y^3));
(1 + 2*t + 2*t^2 + t^3) / (1-t)

/**/  R2 := NewFreeModule(R, 2); -- MODULE
/**/  M := SubmoduleRows(R2, matrix(R, [[x^2,0], [0,z^3]]));
/**/  HilbertSeries(M);
(t^2 + t^3) / (1-t)^4

-- /**/  HilbertSeries(R2/M);  --***WORK IN PROGRESS***

/**/  Ws := RowMat([1,2,3,4]); -- weights and multigradings
/**/  P := NewPolyRing(QQ, "t,x,y,z", MakeTermOrdMat(Ws), 1);
/**/  use P;
/**/  HilbertSeries(P/ideal(t^2, x, y^3));
---  Non-simplified HilbertPoincare Series  ---
(1 - 2*t^2 + t^4 - t^9 + 2*t^11 - t^13) / ( (1-t)*(1-t^2)*(1-t^3)*(1-t^4) )

/**/  HilbertSeries(ideal(t^2, x, y^3));
---  Non-simplified HilbertPoincare Series  ---
(2*t^2 - t^4 + t^9 - 2*t^11 + t^13) / ( (1-t)*(1-t^2)*(1-t^3)*(1-t^4) )

/**/  Ws := mat([[1,2,3,4],[0,0,5,8]]);
/**/  P := NewPolyRing(QQ, "t,x,y,z", MakeTermOrdMat(Ws), 2);
/**/  use P;
/**/  HilbertSeries(P/ideal(t^2, x, y^3));
---  Non Simplified Pseries  ---
(1 - 2*t[1]^2 + t[1]^4 - t[1]^9*t[2]^15 + 2*t[1]^11*t[2]^15 - t[1]^13*t[2]^15) / ( (1-t[1])^1*(1-t[1]^2)*(1-t[1]^3*t[2]^5)*(1-t[1]^4*t[2]^8) )

/**/  Ws := mat([[1,2,3,4],[0,0,5,8]]);
/**/  P := NewPolyRing(QQ, "t,x,y,z", MakeTermOrdMat(Ws), 2);
/**/  use P;
/**/  HilbertSeries(P/ideal(t^2, y^3));
---  Non-simplified HilbertPoincare Series  ---
(1 - t[1]^2 - t[1]^9*t[2]^15 + t[1]^11*t[2]^15) /
    ((1-t[1])^1*(1-t[1]^2)*(1-t[1]^3*t[2]^5)*(1-t[1]^4*t[2]^8) )
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  dim(\ref{dim} pg.\pageref{dim}), 
    multiplicity(\ref{multiplicity} pg.\pageref{multiplicity}), 
    HilbertFn(\ref{HilbertFn} pg.\pageref{HilbertFn}), 
    HVector(\ref{HVector} pg.\pageref{HVector}), 
    HilbertSeriesShifts(\ref{HilbertSeriesShifts} pg.\pageref{HilbertSeriesShifts}), 
    HilbertSeriesMultiDeg(\ref{HilbertSeriesMultiDeg} pg.\pageref{HilbertSeriesMultiDeg}), 
    GradingMat(\ref{GradingMat} pg.\pageref{GradingMat}), 
    PrimaryHilbertSeries(\ref{PrimaryHilbertSeries} pg.\pageref{PrimaryHilbertSeries})
\end{command} % -- end command --------------------------------

\section{HilbertSeriesMultiDeg}
\label{HilbertSeriesMultiDeg}
\begin{command} % -- COMMAND: HilbertSeriesMultiDeg ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HilbertSeriesMultiDeg(RmodI: RING, WM: MAT): TAGGED("$hp.PSeries")
\end{Verbatim}


\subsection*{Description}

This function computes the multigraded Hilbert-Poincare series
of ``\verb&RmodI&'' wrt the multigrading ``\verb&WM&''.
The ``\verb&I&'' must be homogeneous wrt the multigrading ``\verb&WM&''.
\par 
This function is only a handy shortcut to avoid creating the proper
polynomial ring multi-graded with ``\verb&WM&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  HilbertSeriesMultiDeg(R/ideal(Indets(R))^2, mat([[1,1]]));
(1 + 2*t) / (1-t)^0

/**/  HilbertSeriesMultiDeg(R/ideal(Indets(R))^2, mat([[1,0],[0,1]]));
---  Non-simplified HilbertPoincare Series  ---
(1 - t[2]^2 - t[1]*t[2] - t[1]^2 + t[1]*t[2]^2 + t[1]^2*t[2])
/ ( (1-t[1])*(1-t[2]) )
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  HilbertSeries(\ref{HilbertSeries} pg.\pageref{HilbertSeries})
\end{command} % -- end command --------------------------------

\section{HilbertSeriesShifts}
\label{HilbertSeriesShifts}
\begin{command} % -- COMMAND: HilbertSeriesShifts ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HilbertSeriesShifts(M: MODULE, ShiftsList: LIST): TAGGED("$hp.PSeries")
\end{Verbatim}


\subsection*{Description}

This function computes the Hilbert-Poincare series
(single-graded) module ``\verb&M&'' with shifts ``\verb&sh&''.
\par 
This function is only a handy shortcut to avoid creating the proper
free module with shifts ``\verb&sh&''.
\par 
NOTE: tagged objects cannot be usefully compared for equality with
untagged values.
\par 
For more information, see the article: A.M. Bigatti, "Computations of
Hilbert-Poincare Series" J. Pure Appl. Algebra, 119/3 (1997),
237--253.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  F := NewFreeModule(P, ColMat([2,0]));  -- P(-2) (+) P(0)
/**/  M := SubmoduleRows(F, mat([[x,y^3], [x-z,0]]));
/**/  HilbertSeries(M);
(2*t^3) / (1-t)^3
/**/  HilbertSeriesShifts(M, [3,1]);
(2*t^4) / (1-t)^3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  dim(\ref{dim} pg.\pageref{dim}), 
    HilbertFn(\ref{HilbertFn} pg.\pageref{HilbertFn}), 
    HVector(\ref{HVector} pg.\pageref{HVector}), 
    multiplicity(\ref{multiplicity} pg.\pageref{multiplicity}), 
    GradingMat(\ref{GradingMat} pg.\pageref{GradingMat})
\end{command} % -- end command --------------------------------

\section{homog}
\label{homog}
\begin{command} % -- COMMAND: homog ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
homog(V: RINGELEM, X: RINGELEM): RINGELEM
homog(V: MODULEELEM, X: RINGELEM): MODULEELEM
homog(L: LIST, X: RINGELEM): LIST
homog(I: IDEAL, X: RINGELEM): IDEAL
homog(M: MODULE, X: RINGELEM): MODULE
\end{Verbatim}


\subsection*{Description}

This function returns the homogenization of the first arg with respect
to the indeterminate ``\verb&X&'', which must have weight 1.  The elements
of the list ``\verb&L&'' are homogenized separately.
\par 
NOTE: For an ideal/module the result is the ideal/module containing the
homogenizations of all elements (and not simply the homogenizations of
the specific generators).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z,w];
/**/  homog(x^3-y, w);
x^3 -y*w^2

/**/  homog([x^3-y, x^4-z], w);
[x^3 -y*w^2, x^4 -z*w^3]

/**/  I := ideal(x^3-y, x^4-z);
/**/  homog(I, w);    -- not just ideal gen by the homogenizations of
                      -- the generators of I
ideal(x*y -z*w, x^2*z -y^2*w, x^3 -y*w^2, y^3 -x*z^2)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsHomog(\ref{IsHomog} pg.\pageref{IsHomog})
\end{command} % -- end command --------------------------------

\section{HomogCompt}
\label{HomogCompt}
\begin{command} % -- COMMAND: HomogCompt ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HomogCompt(f: RINGELEM, d: INT): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the homogeneous part of weighted degree ``\verb&d&'' of ``\verb&f&''.
\par 
NOTE: currently works only if the weighted degrees are integers (gr.dim is 1).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use P ::= QQ[a,b,c];
/**/ HomogCompt(c^2-a+b+c+1, 1);
-a +b +c
/**/ OrdM := matrix([[2,3,1],[0,0,-1],[0,-1,0]]);
/**/ P := NewPolyRing(QQ, "a,b,c", OrdM, 1); -- 3 indeterminates
/**/ use P;
/**/ HomogCompt(c^2-a+b+c+1, 1);
c
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsHomog(\ref{IsHomog} pg.\pageref{IsHomog}), 
    LF(\ref{LF} pg.\pageref{LF}), 
    DF(\ref{DF} pg.\pageref{DF}), 
    RandomLinearForm(\ref{RandomLinearForm} pg.\pageref{RandomLinearForm})
\end{command} % -- end command --------------------------------

\section{HomogElimMat [OBSOLESCENT]}
\label{HomogElimMat [OBSOLESCENT]}
\begin{command} % -- COMMAND: HomogElimMat [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&ElimHomogMat&'' (\ref{ElimHomogMat} pg.\pageref{ElimHomogMat}).

\end{command} % -- end command --------------------------------

\section{HSaturation}
\label{HSaturation}
\begin{command} % -- COMMAND: HSaturation ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HSaturation(I: IDEAL, J: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This functions returns the saturation of I with respect to J: the
ideal of polynomials F such that F*G is in I for all G in $J^d$
for some positive integer $d$.
\par 
It calculates the saturation using a Hilbert-driven algorithm.
It differs from ``\verb&saturate&'' (\ref{saturate} pg.\pageref{saturate}) only when the
input is inhomogeneous, in which case, ``\verb&HSaturation&'' may be faster.
\par 
The coefficient ring must be a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  I := ideal(x^4-x, y*x-2*x);
/**/  saturate(I, ideal(x));
ideal(y -2, x^3 -1)

  HSaturation(I, ideal(x)); -- ***** NOT YET IMPLEMENTED *****
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  colon(\ref{colon} pg.\pageref{colon}), 
    HColon(\ref{HColon} pg.\pageref{HColon}), 
    saturate(\ref{saturate} pg.\pageref{saturate})
\end{command} % -- end command --------------------------------

\section{HVector}
\label{HVector}
\begin{command} % -- COMMAND: HVector ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HVector(M: (Poly or Quotient)RING): LIST
HVector(M: MODULE): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the h-vector of ``\verb&M&'', \textit{i.e.} the coefficients of the
numerator of the simplified Poincare series for ``\verb&M&''.  ``\verb&M&'' can be a
module or a quotient.
\par 
The weights of the indeterminates of the polynomial ring of ``\verb&M&'' must all
be 1, and the coefficient ring must be a field.
\par 
If the input is not homogeneous, the Hilbert function of the
corresponding leading term (initial) ideal or module is calculated.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[t,x,y,z];
/**/  HVector(R/ideal(x,y,z)^5);
[1, 3, 6, 10, 15]

/**/  HilbertSeries(R/ideal(x,y,z)^5);
(1 + 3t + 6t^2 + 10t^3 + 15t^4) / (1-t)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  HilbertFn(\ref{HilbertFn} pg.\pageref{HilbertFn}), 
    HilbertSeries(\ref{HilbertSeries} pg.\pageref{HilbertSeries})
\end{command} % -- end command --------------------------------

\chapter{I}  %----=== CHAPTER LETTER ===----
\label{I}

\section{ID [OBSOLETE]}
\label{ID [OBSOLETE]}
\begin{command} % -- COMMAND: ID [OBSOLETE] ------------



\subsection*{Description}

Renamed ``\verb&RingID&'' (\ref{RingID} pg.\pageref{RingID}).

\end{command} % -- end command --------------------------------

\section{ideal}
\label{ideal}
\begin{command} % -- COMMAND: ideal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ideal(g1: RINGELEM,...,gn: RINGELEM): IDEAL
ideal(L: LIST): IDEAL
ideal(R: RING, L: LIST): IDEAL
\end{Verbatim}


\subsection*{Description}

The first form returns the ideal generated by ``\verb&g1,...gn&''.
The second form returns the ideal generated by the polynomials in ``\verb&L&''
(a bit more flexible than the first form).
The third is the same as the second but works also if ``\verb&L = []&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x-y^2, x*y-z);
/**/  I;
ideal(-y^2 +x, x*y -z)

/**/  L := [x*y-z, x-y^2];
/**/  J := ideal(L);  -- same as ideal(R, L)
/**/  I = J;
true

/**/  ideal(R, []);
ideal()
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{IdealAndSeparatorsOfPoints}
\label{IdealAndSeparatorsOfPoints}
\begin{command} % -- COMMAND: IdealAndSeparatorsOfPoints ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IdealAndSeparatorsOfPoints(Points: LIST): RECORD

where Points is a list of lists of coefficients representing a set of
\textbf{distinct} points in affine space.
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function computes the results of ``\verb&IdealOfPoints&'' (\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}) and
``\verb&SeparatorsOfPoints&'' (\ref{SeparatorsOfPoints} pg.\pageref{SeparatorsOfPoints}) together at a cost lower than making the two
separate calls.  The result is a record with three fields:
\begin{verbatim}
    points     -- the points given as argument
    ideal      -- the result of IdealOfPoints
    separators -- the result of SeparatorsOfPoints
\end{verbatim}
Thus, if the result is stored in a variable with identifier X, then:
X.points will be the input list of points;
X.ideal will be the ideal of the set of points, with generators
forming the reduced Groebner basis for the ideal;
X.separators will be a list of polynomials whose i-th element will
take the value 1 on the i-th point and 0 on the others.
\par 
NOTE:
\par 
 * the current ring must have at least as many indeterminates as the
   dimension of the space in which the points lie;
\par 
 * the base field for the space in which the points lie is taken to be
   the coefficient ring, which should be a field;
\par 
 * in the polynomials returned, the first coordinate in the space is
   taken to correspond to the first indeterminate, the second to the
   second, and so on;
\par 
 * if the number of points is large, say 100 or more, the returned
   value can be very large.  To avoid possible problems when printing
   such values as a single item we recommend printing out the elements
   one at a time as in this example:
\begin{verbatim}
***** NOT YET IMPLEMENTED *****
     X := IdealAndSeparatorsOfPoints(Pts);
     foreach g in gens(X.ideal) do
       println g;
     endforeach;
\end{verbatim}

For ideals and separators of points in projective space, see
``\verb&IdealAndSeparatorsOfProjectivePoints&'' (\ref{IdealAndSeparatorsOfProjectivePoints} pg.\pageref{IdealAndSeparatorsOfProjectivePoints}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  use R ::= QQ[x,y];
  Points := [[1, 2], [3, 4], [5, 6]];
  X := IdealAndSeparatorsOfPoints(Points);
  X.points;
[[1, 2], [3, 4], [5, 6]]
-------------------------------
  X.ideal;
ideal(x - y + 1, y^3 - 12y^2 + 44y - 48)
-------------------------------
  X.separators;
[1/8y^2 - 5/4y + 3, -1/4y^2 + 2y - 3, 1/8y^2 - 3/4y + 1]
-------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GBM(\ref{GBM} pg.\pageref{GBM}), 
    HGBM(\ref{HGBM} pg.\pageref{HGBM}), 
    GenericPoints(\ref{GenericPoints} pg.\pageref{GenericPoints}), 
    IdealAndSeparatorsOfProjectivePoints(\ref{IdealAndSeparatorsOfProjectivePoints} pg.\pageref{IdealAndSeparatorsOfProjectivePoints}), 
    IdealOfPoints(\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}), 
    IdealOfProjectivePoints(\ref{IdealOfProjectivePoints} pg.\pageref{IdealOfProjectivePoints}), 
    Interpolate(\ref{Interpolate} pg.\pageref{Interpolate}), 
    QuotientBasis(\ref{QuotientBasis} pg.\pageref{QuotientBasis}), 
    SeparatorsOfPoints(\ref{SeparatorsOfPoints} pg.\pageref{SeparatorsOfPoints}), 
    SeparatorsOfProjectivePoints(\ref{SeparatorsOfProjectivePoints} pg.\pageref{SeparatorsOfProjectivePoints})
\end{command} % -- end command --------------------------------

\section{IdealAndSeparatorsOfProjectivePoints}
\label{IdealAndSeparatorsOfProjectivePoints}
\begin{command} % -- COMMAND: IdealAndSeparatorsOfProjectivePoints ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IdealAndSeparatorsOfProjectivePoints(Points: LIST): RECORD

where Points is a list of lists of coefficients representing a set of
\textbf{distinct} points in projective space.
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function computes the results of ``\verb&IdealOfProjectivePoints&'' (\ref{IdealOfProjectivePoints} pg.\pageref{IdealOfProjectivePoints}) and
``\verb&SeparatorsOfProjectivePoints&'' (\ref{SeparatorsOfProjectivePoints} pg.\pageref{SeparatorsOfProjectivePoints}) together at a cost lower than making
the two separate calls.  The result is a record with three fields:
\begin{verbatim}
    points     -- the points given as argument
    ideal      -- the result of IdealOfProjectivePoints
    separators -- the result of SeparatorsOfProjectivePoints
\end{verbatim}
Thus, if the result is stored in a variable with identifier X, then:
X.ideal will be the ideal of the set of points, with generators
forming a reduced Groebner basis for the ideal;
X.separators will be a list of homogeneous polynomials whose i-th
element will be non-zero (actually 1, using the given representatives
for the coordinates of the points) on the i-th point and 0 on the others.
\par 
NOTE:
\par 
 * the current ring must have at least one more indeterminate than the
   dimension of the projective space in which the points lie, \textit{i.e.} at
   least as many indeterminates as the length of an element of
   the input, Points;
\par 
 * the base field for the space in which the points lie is taken to be
   the coefficient ring, which should be a field;
\par 
 * in the polynomials returned, the first coordinate in the space is
   taken to correspond to the first indeterminate, the second to the
   second, and so on;
\par 
 * if the number of points is large, say 100 or more, the returned
   value can be very large.  To avoid possible problems when printing
   such values as a single item we recommend printing out the elements
   one at a time as in this example:
\begin{verbatim}
***** NOT YET IMPLEMENTED *****
     X := IdealAndSeparatorsOfProjectivePoints(Pts);
     foreach g in gens(X.ideal) do
       println g;
     endforeach;
\end{verbatim}

For ideals and separators of points in affine space, see
``\verb&IdealAndSeparatorsOfPoints&'' (\ref{IdealAndSeparatorsOfPoints} pg.\pageref{IdealAndSeparatorsOfPoints}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  use R ::= QQ[x,y,z];
  Points := [[0,0,1],[1/2,1,1],[0,1,0]];
  X := IdealAndSeparatorsOfProjectivePoints(Points);
  X.points;
[[0, 0, 1], [1, 1, 1], [0, 1, 0]]
-------------------------------
  X.ideal;
ideal(x*z - (1/2)*y*z,  x*y - (1/2)*y*z,  x^2 - (1/4)*y*z,  y^2*z - y*z^2)
-------------------------------
  X.separators;
[-2*x + z,  x,  -2*x + y]
-------------------------------

  use R ::= QQ[t,x,y,z];
  Pts := GenericPoints(20);  -- 20 random points in projective 3-space
  X := IdealAndSeparatorsOfProjectivePoints(Pts);
  Len(Gens(X.Ideal));  -- number of generators in the ideal
17
-------------------------------
  HilbertFn(R/X.Ideal);
H(0) = 1
H(1) = 4
H(2) = 10
H(t) = 20   for t >= 3
-------------------------------
  F := X.Separators[3];
  [Eval(F, P) | P in Pts];
[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
-------------------------------
  Res(R/X.Ideal);  -- the resolution of the ideal
0 --> R^10(-6) --> R^24(-5) --> R^15(-4) --> R
-------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  HGBM(\ref{HGBM} pg.\pageref{HGBM}), 
    GBM(\ref{GBM} pg.\pageref{GBM}), 
    GenericPoints(\ref{GenericPoints} pg.\pageref{GenericPoints}), 
    IdealAndSeparatorsOfPoints(\ref{IdealAndSeparatorsOfPoints} pg.\pageref{IdealAndSeparatorsOfPoints}), 
    IdealOfPoints(\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}), 
    IdealOfProjectivePoints(\ref{IdealOfProjectivePoints} pg.\pageref{IdealOfProjectivePoints}), 
    Interpolate(\ref{Interpolate} pg.\pageref{Interpolate}), 
    QuotientBasis(\ref{QuotientBasis} pg.\pageref{QuotientBasis}), 
    SeparatorsOfPoints(\ref{SeparatorsOfPoints} pg.\pageref{SeparatorsOfPoints}), 
    SeparatorsOfProjectivePoints(\ref{SeparatorsOfProjectivePoints} pg.\pageref{SeparatorsOfProjectivePoints})
\end{command} % -- end command --------------------------------

\section{IdealOfGBasis}
\label{IdealOfGBasis}
\begin{command} % -- COMMAND: IdealOfGBasis ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IdealOfGBasis(I: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

After the ``\verb&GBasis&'' (\ref{GBasis} pg.\pageref{GBasis}) of ``\verb&I&'' is (explicitly or implicitly)
computed, it is stored within ``\verb&I&'' for future use.
This function returns the ideal generated by the GBasis of ``\verb&I&'',
and knows it is a GBasis.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x^10 -x*y -1, x^5*y^5 -x*z -1,  x^5*z^5 -x*z -1);
/**/  J1 := ideal(GBasis(I));
/**/  HasGBasis(J1);
false
/**/  J2 := IdealOfGBasis(I);
/**/  HasGBasis(J2);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  HasGBasis(\ref{HasGBasis} pg.\pageref{HasGBasis})
\end{command} % -- end command --------------------------------

\section{IdealOfMinGens}
\label{IdealOfMinGens}
\begin{command} % -- COMMAND: IdealOfMinGens ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IdealOfMinGens(I: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

It works only in the homogeneous case:
for the inhomogeneous case see ``\verb&MinSubsetOfGens&'' (\ref{MinSubsetOfGens} pg.\pageref{MinSubsetOfGens}).
\par 
This function returns the ideal generated by a minimal set of generators
(\textit{i.e.} with minimal cardinality) of ``\verb&I&''.  
The minimal set of generators is not necessarily a subset of the given
generators.
\par 
The coefficient ring must be a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x^2-y^2, z^4-y^4, x^2-z^2);
/**/  IdealOfMinGens(I);
ideal(x^2 -z^2,  y^2 -z^2)
/**/  HasGBasis(I);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  MinGens(\ref{MinGens} pg.\pageref{MinGens}), 
    MinSubsetOfGens(\ref{MinSubsetOfGens} pg.\pageref{MinSubsetOfGens})
\end{command} % -- end command --------------------------------

\section{IdealOfPoints}
\label{IdealOfPoints}
\begin{command} % -- COMMAND: IdealOfPoints ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IdealOfPoints(P: RING, Points: MAT): IDEAL
where Points is a MAT of coefficients whose rows represent a set of
\textbf{distinct} points in affine space.
\end{Verbatim}


\subsection*{Description}

This function computes the reduced Groebner basis for the ideal of all
polynomials which vanish at the given set of points.  It returns the
ideal generated by that Groebner basis.
\par 
NOTE:
\par 
 * the current ring must have at least as many indeterminates as the
   dimension of the space in which the points lie, \textit{i.e.} at
   least as many indeterminates as ``\verb&NumCols(Points)&'';
\par 
 * the base field for the space in which the points lie is taken to be
   the coefficient ring, which should be a field;
\par 
 * in the polynomials returned, the first coordinate in the space is
   taken to correspond to the first indeterminate, the second to the
   second, and so on;











For ideals of points in projective space, see ``\verb&IdealOfProjectivePoints&'' (\ref{IdealOfProjectivePoints} pg.\pageref{IdealOfProjectivePoints}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y];
/**/  Points := mat([[1, 2], [3, 4], [5, 6]]);
/**/  I := IdealOfPoints(P, Points);
/**/  I;
ideal(x -y +1, y^3 -12*y^2 +44*y -48)

/**/  K := NewFractionField(NewPolyRing(QQ, "a"));
/**/  use K;
/**/  Points := mat([[1,2,0], [3,4,a], [5,1,6]]);
/**/  use P ::= K[x,y,z], Lex;
/**/  I := IdealOfPoints(P, Points);
/**/  indent(I);
ideal(
  z^3 +(-a -6)*z^2 +(6*a)*z,
  y +((-a -12)/(6*a^2 -36*a))*z^2 +((a^2 +72)/(6*a^2 -36*a))*z -2,
  x +((2*a -6)/(3*a^2 -18*a))*z^2 +((-2*a^2 +36)/(3*a^2 -18*a))*z -1
)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GBM(\ref{GBM} pg.\pageref{GBM}), 
    HGBM(\ref{HGBM} pg.\pageref{HGBM}), 
    GenericPoints(\ref{GenericPoints} pg.\pageref{GenericPoints}), 
    IdealAndSeparatorsOfPoints(\ref{IdealAndSeparatorsOfPoints} pg.\pageref{IdealAndSeparatorsOfPoints}), 
    IdealAndSeparatorsOfProjectivePoints(\ref{IdealAndSeparatorsOfProjectivePoints} pg.\pageref{IdealAndSeparatorsOfProjectivePoints}), 
    IdealOfProjectivePoints(\ref{IdealOfProjectivePoints} pg.\pageref{IdealOfProjectivePoints}), 
    Interpolate(\ref{Interpolate} pg.\pageref{Interpolate}), 
    QuotientBasis(\ref{QuotientBasis} pg.\pageref{QuotientBasis}), 
    SeparatorsOfPoints(\ref{SeparatorsOfPoints} pg.\pageref{SeparatorsOfPoints}), 
    SeparatorsOfProjectivePoints(\ref{SeparatorsOfProjectivePoints} pg.\pageref{SeparatorsOfProjectivePoints})
\end{command} % -- end command --------------------------------

\section{IdealOfProjectivePoints}
\label{IdealOfProjectivePoints}
\begin{command} % -- COMMAND: IdealOfProjectivePoints ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IdealOfPoints(P: RING, Points: MAT): IDEAL
where Points is a MAT of coefficients whose rows represent a set of
\textbf{distinct} points in projective space.
\end{Verbatim}


\subsection*{Description}

This function computes the reduced Groebner basis for the ideal of
all homogeneous polynomials which vanish at the given set of points.
It returns the ideal generated by that Groebner basis.
\par 
NOTE:
\par 
 * the current ring must have at least one more indeterminate than the
   dimension of the projective space in which the points lie, \textit{i.e.} at
   least as many indeterminates as ``\verb&NumCols(Points)&'';
\par 
 * the base field for the space in which the points lie is taken to be
   the coefficient ring, which should be a field;
\par 
 * in the polynomials returned, the first coordinate in the space is
   taken to correspond to the first indeterminate, the second to the
   second, and so on;
\par 
 * if the number of points is large, say 100 or more, the returned
   value can be very large.  To avoid possible problems when printing
   such values as a single item we recommend printing out the elements
   one at a time as in this example:
\begin{verbatim}
     I := IdealOfProjectivePoints(Pts);
     foreach g in gens(I) do
       println g;
     endforeach;
\end{verbatim}
For ideals of points in affine space, see ``\verb&IdealOfPoints&'' (\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  I := IdealOfProjectivePoints(P, mat([[0,0,1],[1/2,1,1],[0,1,0]]));
/**/  I;  -- gens are the reduced Groebner basis
ideal(x*z +(-1/2)*y*z,  x*y +(-1/2)*y*z,  x^2 +(-1/4)*y*z,  y^2*z -y*z^2)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GBM(\ref{GBM} pg.\pageref{GBM}), 
    HGBM(\ref{HGBM} pg.\pageref{HGBM}), 
    GenericPoints(\ref{GenericPoints} pg.\pageref{GenericPoints}), 
    IdealAndSeparatorsOfPoints(\ref{IdealAndSeparatorsOfPoints} pg.\pageref{IdealAndSeparatorsOfPoints}), 
    IdealAndSeparatorsOfProjectivePoints(\ref{IdealAndSeparatorsOfProjectivePoints} pg.\pageref{IdealAndSeparatorsOfProjectivePoints}), 
    IdealOfPoints(\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}), 
    Interpolate(\ref{Interpolate} pg.\pageref{Interpolate}), 
    QuotientBasis(\ref{QuotientBasis} pg.\pageref{QuotientBasis}), 
    SeparatorsOfPoints(\ref{SeparatorsOfPoints} pg.\pageref{SeparatorsOfPoints}), 
    SeparatorsOfProjectivePoints(\ref{SeparatorsOfProjectivePoints} pg.\pageref{SeparatorsOfProjectivePoints})
\end{command} % -- end command --------------------------------

\section{IdentityMat}
\label{IdentityMat}
\begin{command} % -- COMMAND: IdentityMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IdentityMat(R: RING, N: INT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the NxN identity matrix with entries in ``\verb&R&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ Id := IdentityMat(QQ,3);  Id;
matrix(QQ,
 [[1, 0, 0],
  [0, 1, 0],
  [0, 0, 1]])
/**/ type(Id[1,1]);
RINGELEM
/**/ RingOf(Id[1,1]);
QQ
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{if}
\label{if}
\begin{command} % -- COMMAND: if ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
If B_1 Then C_1 EndIf
If B_1 Then C_1 Else D EndIf
If B_1 Then C_1 Elif B_2 Then C_2 Elif ... EndIf
If B_1 Then C_1 Elif B_2 Then C_2 Elif ... Else D EndIf

where the B_j are boolean expressions,
and the C_j and D are command sequences.
\end{Verbatim}


\subsection*{Description}

If ``\verb&B_n&'' is the first in the sequence of the ``\verb&B_j&'' to evaluate to ``\verb&true&'',
then ``\verb&C_n&'' is executed.  If none of the ``\verb&B_j&'' evaluates to ``\verb&true&'',
then ``\verb&D&'' is executed if present otherwise nothing is done.
\par 
The construct, ``\verb&Elif B_j Then C_j&'' can be repeated any number of times.
\par 
NOTE: the obsolete CoCoA-4 keyword ``\verb&Elsif&'' is no longer allowed.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Define MySign(A)
/**/    If A > 0 Then Return 1;
/**/    Elif A = 0 Then Return 0;
/**/    Else Return -1;
/**/    EndIf;
/**/  EndDefine;

/**/  MySign(3);
1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Bool01(\ref{Bool01} pg.\pageref{Bool01}), 
    All CoCoA commands(\ref{All CoCoA commands} pg.\pageref{All CoCoA commands})
\end{command} % -- end command --------------------------------

\section{ILogBase}
\label{ILogBase}
\begin{command} % -- COMMAND: ILogBase ------------



\subsection*{Description}

Renamed ``\verb&FloorLog2, FloorLog10, FloorLogBase&'' (\ref{FloorLog2, FloorLog10, FloorLogBase} pg.\pageref{FloorLog2, FloorLog10, FloorLogBase}).

\end{command} % -- end command --------------------------------

\section{image [OBSOLESCENT]}
\label{image [OBSOLESCENT]}
\begin{command} % -- COMMAND: image [OBSOLESCENT] ------------



\subsection*{Description}

In CoCoA-5 homomorphisms are properly implemented as ``\verb&RINGHOM&'' (\ref{RINGHOM} pg.\pageref{RINGHOM}).
``\verb&Image&'' was the CoCoA-4 function mimicking homomorphisms, in
particular ``\verb&PolyAlgebraHom&'' (\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use Dom ::= QQ[x,y];   -- domain
/**/  f := x-y;   -- a RINGELEM in D

/**/  use Cod ::= QQ[a,b,c]; -- codomain

/**/  -- the old trick
/**/  -- Phi := RMap(a, c^2-a*b);  -- OBSOLESCENT
/**/  -- Image(f, Phi);            -- OBSOLESCENT
a*b -c^2 +a

/**/  -- the proper call
/**/  phi := PolyAlgebraHom(Dom, Cod, [a, c^2-a*b]);  -- a RINGHOM
/**/  phi(f);
a*b -c^2 +a
/**/  phi([f, f^2]);
[a*b -c^2 +a,  a^2*b^2 -2*a*b*c^2 +c^4 +2*a^2*b -2*a*c^2 +a^2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PolyAlgebraHom(\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}), 
    Introduction to RINGHOM(\ref{Introduction to RINGHOM} pg.\pageref{Introduction to RINGHOM}), 
    BringIn(\ref{BringIn} pg.\pageref{BringIn}), 
    subst(\ref{subst} pg.\pageref{subst})
\end{command} % -- end command --------------------------------

\section{implicit}
\label{implicit}
\begin{command} % -- COMMAND: implicit ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
implicit(SubalgebraGens: LIST): IDEAL
implicit(R: RING, SubalgebraGens: LIST): IDEAL
\end{Verbatim}


\subsection*{Description}

This function returns the implicitization of the subalgebra generated
by the list ``\verb&SubalgebraGens&''.
\par 
If provided with a ring ``\verb&R&'', the result is in ``\verb&R&'',
otherwise it is in a newly created ring.
\par 
NOTE: Some cases have been optimized:
if the input is a list of power-products then use ``\verb&toric&'' (\ref{toric} pg.\pageref{toric}).
if you know the answer is a hypersurface then use ``\verb&ImplicitHypersurface&'' (\ref{ImplicitHypersurface} pg.\pageref{ImplicitHypersurface}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use S ::= QQ[s,t];
/**/  implicit([s^3, s^2*t, s*t^2, t^3]);
ideal(x[3]^2 -x[2]*x[4], x[2]*x[3] -x[1]*x[4], x[2]^2 -x[1]*x[3])

/**/  P ::= QQ[x,y,z,w];
/**/  implicit(P, [s^3, s^2*t, s*t^2, t^3]);
ideal(z^2 -y*w, y*z -x*w, y^2 -x*z)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ImplicitHypersurface(\ref{ImplicitHypersurface} pg.\pageref{ImplicitHypersurface}), 
    ker(\ref{ker} pg.\pageref{ker})
\end{command} % -- end command --------------------------------

\section{ImplicitHypersurface}
\label{ImplicitHypersurface}
\begin{command} % -- COMMAND: ImplicitHypersurface ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ImplicitHypersurface(ParamDescr: LIST): RINGELEM
ImplicitHypersurface(ParamDescr: LIST, Algo: STRING): RINGELEM
ImplicitHypersurface(P: RING, ParamDescr: LIST): RINGELEM
ImplicitHypersurface(P: RING, ParamDescr: LIST, Algo: STRING): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the implicitization of the hypersurface
parametrically described by the list ``\verb&ParamDescr&''.
From version CoCoA-5.2.2 it works also for rational parametrization.
\par 
The algorithms are described in the JSC paper Abbott, Bigatti, Robbiano
\textbf{Implicitization of Hypersurfaces}
\par 
If provided with a polynomial ring ``\verb&P&'', the result is in ``\verb&P&'',
otherwise it is in a newly created ring.
\par 
Verbosity: 20-80-90.
\par 
NOTE: it assumes the input is a correct parametric description of a
hypersurface in ``\verb&K^(len(ParamDescr)+1)&''!! 
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ P ::= QQ[x,y,z];
/**/ use S ::= QQ[s,t];
/**/ ImplicitHypersurface(P, [s^2, s*t, t^2]);
y^2 -x*z
/**/ ImplicitHypersurface(P, [s^2, s*t, t^2], "Direct");
y^2 -x*z
/**/ ImplicitHypersurface(P, [s^2, s*t, t^2], "ElimTH");
y^2 -x*z

/**/ -- Parametrization by rational functions
/**/ K := NewFractionField(RingQQt(1));
/**/ use K;
/**/ ParamDescr := [ (1-t^2)/(1+t^2), 2*t/(1+t^2) ];
/**/ ImplicitHypersurface(ParamDescr);
x[1]^2 +x[2]^2 -1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  implicit(\ref{implicit} pg.\pageref{implicit})
\end{command} % -- end command --------------------------------

\section{ImplicitPlot}
\label{ImplicitPlot}
\begin{command} % -- COMMAND: ImplicitPlot ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ImplicitPlot(F: POLY, Xrange: LIST, Yrange: LIST)
\end{Verbatim}


\subsection*{Description}

This function evaluates the first argument, a bivariate polynomial, at
a grid of points in the range given by the second and third arguments.
The coordinates of the approximate zeroes are output to a file
called "CoCoAPlot".
See ``\verb&ImplicitPlotOn&'' (\ref{ImplicitPlotOn} pg.\pageref{ImplicitPlotOn}) for outputting to another file.
\par 
This result can be plotted using your preferred plotting program.
For example, start "gnuplot" and then give it the command
\begin{verbatim}  plot "CoCoAPlot"\end{verbatim}
to see the plot.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  ImplicitPlot(x^2 + y^2 - 200^2, [-256,256], [-256,256]);
Plotting points...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
800 plotted points have been placed in the file CoCoAPlot
\end{Verbatim}



\SeeAlso %---- SEE ALSO ----
  ImplicitPlotOn(\ref{ImplicitPlotOn} pg.\pageref{ImplicitPlotOn}), 
    PlotPoints(\ref{PlotPoints} pg.\pageref{PlotPoints})
\end{command} % -- end command --------------------------------

\section{ImplicitPlotOn}
\label{ImplicitPlotOn}
\begin{command} % -- COMMAND: ImplicitPlotOn ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ImplicitPlotOn(F: POLY, Xrange: LIST, Yrange: LIST, PlotFileName: STRING)
\end{Verbatim}


\subsection*{Description}

This function is the same as ``\verb&ImplicitPlot&'' (\ref{ImplicitPlot} pg.\pageref{ImplicitPlot}) with a fourth
argument giving the name of the file to print on.
\par 
NOTE: the last argument is a ``\verb&STRING&'', the name of the file, and not
an ``\verb&OSTREAM&'', as for ``\verb&print on&'' (\ref{print on} pg.\pageref{print on}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  F := x^2 + y^2 - 100;
/**/  G := ((x+y)^2-1)*(x^2-36);
/**/  H := ((64*y^2-36*x^2)*(36*y^2-64*x^2)*(100*x^2-y^2)-1) * F - 1000^2 * G;

/**/  ImplicitPlotOn(F, [-16,16], [-16,16], "PLOT-circle");
Plotting points...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
640 plotted points have been placed in the file circle

/**/  ImplicitPlotOn(G, [-16,16], [-16,16], "PLOT-lines");
Plotting points...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
1502 plotted points have been placed in the file lines

/**/  ImplicitPlotOn(H, [-16,16], [-16,16], "PLOT-curve");
Plotting points...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
2790 plotted points have been placed in the file curve
\end{Verbatim}

After having produced the plot files using CoCoA-4,
start "gnuplot" and then give it the following commands:
\begin{verbatim}  plot "circle"
  replot "lines"
  replot "curve"
\end{verbatim}

\SeeAlso %---- SEE ALSO ----
  ImplicitPlot(\ref{ImplicitPlot} pg.\pageref{ImplicitPlot}), 
    PlotPointsOn(\ref{PlotPointsOn} pg.\pageref{PlotPointsOn})
\end{command} % -- end command --------------------------------

\section{ImportByRef, ImportByValue}
\label{ImportByRef, ImportByValue}
\begin{command} % -- COMMAND: ImportByRef, ImportByValue ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ImportByRef X;
ImportByValue X;
  where ``\verb&X&'' is the name of a variable in the containing scope.
\end{Verbatim}


\subsection*{Description}

These commands can be used only inside anonymous functions (see ``\verb&func&'' (\ref{func} pg.\pageref{func})).
\par 
These commands "import" an external, non-top-level variable by reference
or value.  ``\verb&ImportByValue&'' creates a variable inside the anon func with
the given name, and its initial value is taken from the external variable
of the same name in the context the anonymous function is defined.  In
contrast, ``\verb&ImportByRef&'' creates a \textbf{reference} (from inside the anon
func) to the named external variable in the context where the anon func
is defined.
\par 
See ``\verb&TopLevel&'' (\ref{TopLevel} pg.\pageref{TopLevel}) for accessing top-level variables.
\par 
NOTE: Package variables should be accessed directly (via their fully
qualified names); they cannot be imported.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  define add(X)
/**/    AnonFn := func(Y) ImportByValue X; return X+Y; EndFunc;
/**/    return AnonFn;
/**/  EndDefine;
/**/  add3 := add(3);
/**/  add3(2);
5
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  TopLevel(\ref{TopLevel} pg.\pageref{TopLevel}), 
    func(\ref{func} pg.\pageref{func})
\end{command} % -- end command --------------------------------

\section{in}
\label{in}
\begin{command} % -- COMMAND: in ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
[X in L | B: BOOL]
[E | X in L]
[E | X in L and B]
  where L: LIST, B: BOOL, E: expression
  returns LIST
\end{Verbatim}


\subsection*{Description}

See ``List Constructors'' (\ref{List Constructors} pg.\pageref{List Constructors}) for a full description.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  [N in 1..10 | IsPrime(N)];
[2, 3, 5, 7]

/**/  [N^2 | N in 1..10 and IsPrime(N)];
[4, 9, 25, 49]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  List Constructors(\ref{List Constructors} pg.\pageref{List Constructors}), 
    IsIn(\ref{IsIn} pg.\pageref{IsIn})
\end{command} % -- end command --------------------------------

\section{incr, decr}
\label{incr, decr}
\begin{command} % -- COMMAND: incr, decr ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
incr(ref X: INT)
decr(ref X: INT)
\end{Verbatim}


\subsection*{Description}

``\verb&incr(ref X)&'' adds 1 to the value of ``\verb&X&''.
``\verb&decr(ref X)&'' subtracts 1 from the value of ``\verb&X&''.
\par 
These functions are useful when counting objects or adjusting pointers.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ L := [(10^k-1)/9 | k in 1..99];
/**/ NPrimes := 0;
/**/ Foreach N in L Do
/**/   If IsPrime(N) Then incr(ref NPrimes); EndIf;
/**/ EndForeach;
/**/ PrintLn "The list L contains ", NPrimes, " primes.";
The list L contains 3 primes.
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{indent}
\label{indent}
\begin{command} % -- COMMAND: indent ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
indent(L: LIST)
indent(I: IDEAL)
indent(R: RECORD)
indent(X: OBJECT, RecursionDepth: INT)
\end{Verbatim}


\subsection*{Description}

This function prints its argument splitting it into several lines:
a LIST or IDEAL is printed one element per line, a RECORD
one field per line.
\par 
The second optional argument is for setting the level of recursive
indentation; it can be useful when printing a list of records.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ L := [[n,n+1] | n in [1,2,3]];
/**/ println L;
[[1, 2], [2, 3], [3, 4]]

/**/ indent(L);
[
  [1, 2],
  [2, 3],
  [3, 4]
]

/**/ indent(record[B := 1,  A := 2]);
record[
  A := 2,
  B := 1
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  format(\ref{format} pg.\pageref{format}), 
    fold(\ref{fold} pg.\pageref{fold})
\end{command} % -- end command --------------------------------

\section{indet}
\label{indet}
\begin{command} % -- COMMAND: indet ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
indet(R: RING, N: INT): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the N-th indeterminate of the current ring.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  indet(R, 2);
y
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IndetSubscripts(\ref{IndetSubscripts} pg.\pageref{IndetSubscripts}), 
    IndetIndex(\ref{IndetIndex} pg.\pageref{IndetIndex}), 
    IndetName(\ref{IndetName} pg.\pageref{IndetName}), 
    indets(\ref{indets} pg.\pageref{indets}), 
    NumIndets(\ref{NumIndets} pg.\pageref{NumIndets}), 
    UnivariateIndetIndex(\ref{UnivariateIndetIndex} pg.\pageref{UnivariateIndetIndex})
\end{command} % -- end command --------------------------------

\section{IndetIndex}
\label{IndetIndex}
\begin{command} % -- COMMAND: IndetIndex ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IndetIndex(X: RINGELEM): INT
\end{Verbatim}


\subsection*{Description}

This function returns the position in which the indeterminate is
listed when the corresponding ring was created.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  IndetIndex(y);
2

/**/  use R ::= QQ[x[1..2,1..2],y[1..2]];
/**/  Indets(R);
[x[1,1], x[1,2], x[2,1], x[2,2], y[1], y[2]]

/**/  IndetIndex(x[2,1]);
3

/**/  S ::= QQ[a,b,c];
/**/  IndetIndex(RingElem(S, "b"));
2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  indet(\ref{indet} pg.\pageref{indet}), 
    IndetSubscripts(\ref{IndetSubscripts} pg.\pageref{IndetSubscripts}), 
    IndetName(\ref{IndetName} pg.\pageref{IndetName}), 
    indets(\ref{indets} pg.\pageref{indets}), 
    NumIndets(\ref{NumIndets} pg.\pageref{NumIndets}), 
    UnivariateIndetIndex(\ref{UnivariateIndetIndex} pg.\pageref{UnivariateIndetIndex})
\end{command} % -- end command --------------------------------

\section{IndetName}
\label{IndetName}
\begin{command} % -- COMMAND: IndetName ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IndetName(X: RINGELEM): STRING
\end{Verbatim}


\subsection*{Description}

This function returns the name of the indeterminate X as a string
(\textit{i.e.} the letter without the indices).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  IndetName(indet(R, 2));
y

/**/  type(It);
STRING

/**/  use R ::= QQ[a, x[1..3]];
/**/  IndetName(Indet(R, 2));
x

/**/  indent(IndetSymbols(R));
[
  record[head := "a", indices := []],
  record[head := "x", indices := [1]],
  record[head := "x", indices := [2]],
  record[head := "x", indices := [3]]
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  indet(\ref{indet} pg.\pageref{indet}), 
    IndetSubscripts(\ref{IndetSubscripts} pg.\pageref{IndetSubscripts}), 
    IndetIndex(\ref{IndetIndex} pg.\pageref{IndetIndex}), 
    IndetSymbols(\ref{IndetSymbols} pg.\pageref{IndetSymbols}), 
    NumIndets(\ref{NumIndets} pg.\pageref{NumIndets})
\end{command} % -- end command --------------------------------

\section{indets}
\label{indets}
\begin{command} % -- COMMAND: indets ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
indets(R: RING): LIST
indets(R: RING, X: STRING): LIST
\end{Verbatim}


\subsection*{Description}

With one argument (a polynomial ring), this function returns the
list of indeterminates of that polynomial ring.
With two arguments (the second a STRING), it returns the
list of all indeterminates whose name is the given string.
The indeterminates in the list appear in order of increasing
index (see the function ``\verb&IndetIndex&'').
\par 
This function used to be called ``\verb&IndetsCalled&'' up to version CoCoA-5.0.3,
and ``\verb&AllIndetsCalled&'' in CoCoA-4.
\par 
Additionally, up to version 4.7.3 you could get this list just by giving
the name, \textit{e.g.} ``\verb&Use QQ[x[0..4]];  x;&'' but this syntax is no longer
allowed because it is ambiguous:
``\verb&x[2];&'' is different from ``\verb&X := x;  X[2];&''
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  S ::= QQ[x,y,z];
/**/  use R ::= QQ[a,b];
/**/  indets(CurrentRing);
[a, b]
/**/  indets(S);
[x, y, z]
/**/  indets(S,"x");
[x]
/**/  RingElem(S,"x"); -- works also if R is not a polynomial ring
x

/**/  use R ::= QQ[x[1..4],a[1..2,1..3]];
/**/  indets(R,"x");
[x[1], x[2], x[3], x[4]]
/**/  indets(R,"a");
[a[1,1], a[1,2], a[1,3], a[2,1], a[2,2], a[2,3]]
/**/  indets(R,"b"); -- empty list if no indet has a matching head
[]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  indet(\ref{indet} pg.\pageref{indet}), 
    IndetSubscripts(\ref{IndetSubscripts} pg.\pageref{IndetSubscripts}), 
    IndetIndex(\ref{IndetIndex} pg.\pageref{IndetIndex}), 
    IndetName(\ref{IndetName} pg.\pageref{IndetName}), 
    NumIndets(\ref{NumIndets} pg.\pageref{NumIndets})
\end{command} % -- end command --------------------------------

\section{IndetsProd}
\label{IndetsProd}
\begin{command} % -- COMMAND: IndetsProd ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IndetsProd(f: RINGELEM): RINGELEM
IndetsProd(L: LIST of RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function says which indeterminates are used in ``\verb&f&'' (or ``\verb&L&'').
The result is the product of all indeterminates which actually appear
in ``\verb&f&'' (or ``\verb&L&'').
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  IndetsProd(x^2-z);
x*z
/**/  IndetsProd([x^2-z,  y]);
x*y*z
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  indet(\ref{indet} pg.\pageref{indet}), 
    IndetIndex(\ref{IndetIndex} pg.\pageref{IndetIndex}), 
    support(\ref{support} pg.\pageref{support})
\end{command} % -- end command --------------------------------

\section{IndetSubscripts}
\label{IndetSubscripts}
\begin{command} % -- COMMAND: IndetSubscripts ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IndetSubscripts(X: RINGELEM): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the subscripts of the name of the argument,
an indeterminate (used to be called ``\verb&IndetInd&'').
\par 
Please note the difference with ``\verb&IndetIndex&'' (\ref{IndetIndex} pg.\pageref{IndetIndex}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x[1..3,1..2],y,z];
/**/  IndetSubscripts(x[3,2]);
[3, 2]
/**/  IndetSubscripts(y);
[]
/**/  IndetIndex(RingElem(R, ["x",3,2]));
6
/**/  IndetSubscripts(RingElem(R, ["x",3,2]));
[3, 2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  indet(\ref{indet} pg.\pageref{indet}), 
    IndetIndex(\ref{IndetIndex} pg.\pageref{IndetIndex}), 
    IndetName(\ref{IndetName} pg.\pageref{IndetName}), 
    IndetSymbols(\ref{IndetSymbols} pg.\pageref{IndetSymbols}), 
    indets(\ref{indets} pg.\pageref{indets}), 
    NumIndets(\ref{NumIndets} pg.\pageref{NumIndets})
\end{command} % -- end command --------------------------------

\section{IndetSymbols}
\label{IndetSymbols}
\begin{command} % -- COMMAND: IndetSymbols ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IndetSymbols(P: RING): RECORD
\end{Verbatim}


\subsection*{Description}

This function returns the list of the symbols in a polynomial ring.
A symbol is a record ``\verb&with&'' head (as ``\verb&IndetName&'' (\ref{IndetName} pg.\pageref{IndetName}))
and ``\verb&indices&'' (as ``\verb&IndetSubscripts&'' (\ref{IndetSubscripts} pg.\pageref{IndetSubscripts}))
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  indent(IndetSymbols(R));
[
  record[head := "x", indices := []],
  record[head := "y", indices := []],
  record[head := "z", indices := []]
]

/**/  use R ::= QQ[a, x[1..3]];
/**/  indent(IndetSymbols(R));
[
  record[head := "a", indices := []],
  record[head := "x", indices := [1]],
  record[head := "x", indices := [2]],
  record[head := "x", indices := [3]]
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  indet(\ref{indet} pg.\pageref{indet}), 
    IndetSubscripts(\ref{IndetSubscripts} pg.\pageref{IndetSubscripts}), 
    IndetIndex(\ref{IndetIndex} pg.\pageref{IndetIndex}), 
    IndetName(\ref{IndetName} pg.\pageref{IndetName}), 
    NumIndets(\ref{NumIndets} pg.\pageref{NumIndets}), 
    SymbolRange(\ref{SymbolRange} pg.\pageref{SymbolRange})
\end{command} % -- end command --------------------------------

\section{InducedHom}
\label{InducedHom}
\begin{command} % -- COMMAND: InducedHom ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
InducedHom(RmodI: RING, phi: RINGHOM): RINGHOM
\end{Verbatim}


\subsection*{Description}

``\verb&InducedHom(RmodI, phi)&'' -- where ``\verb&RmodI&'' is a QuotientRing,
and ``\verb&phi&'' is a homomorphism ``\verb&R --> S&''
(which must have ``\verb&BaseRing(RmodI)&'' as its ``\verb&domain&'' (\ref{domain} pg.\pageref{domain}),
and whose ``\verb&ker&'' (\ref{ker} pg.\pageref{ker}) must contain ``\verb&DefiningIdeal(RmodI)&'')
gives the homomorphism ``\verb&R/I --> S&'' induced by ``\verb&phi&''
\par 
``\verb&InducedHom(FrF, phi)&'' -- may be partial where ``\verb&FrF&'' is a
FractionField, gives the homomorphism induced by ``\verb&phi&'' (which must
have the base ring of FrF as its domain).  Note that the resulting
homomorphism may be only partial (\textit{e.g.} if ker(phi) is non-trivial,
or if the codomain is not a field).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  RmodI := NewQuotientRing(R, ideal(x^2-1));

/**/ use S ::= QQ[a,b,c];
/**/  SmodJ := NewQuotientRing(S, ideal(a^2-1));

/**/  phi := PolyAlgebraHom(R,S,[a,b]);
/**/  use R;
/**/  phi(x);
a
/**/ RingOf(phi(x)) = S;
true
/**/  psi := CanonicalHom(S,SmodJ)(phi);  -- composition of homomorphisms
/**/  psi(x);
(a)
/**/  RingOf(psi(x)) = SmodJ;
true

/**/  theta := InducedHom(RmodI, psi);
/**/  use RmodI;
/**/  theta(x);
(a)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  domain(\ref{domain} pg.\pageref{domain}), 
    codomain(\ref{codomain} pg.\pageref{codomain}), 
    Composition of RINGHOM(\ref{Composition of RINGHOM} pg.\pageref{Composition of RINGHOM}), 
    BaseRing(\ref{BaseRing} pg.\pageref{BaseRing}), 
    DefiningIdeal(\ref{DefiningIdeal} pg.\pageref{DefiningIdeal}), 
    NewQuotientRing(\ref{NewQuotientRing} pg.\pageref{NewQuotientRing}), 
    NewFractionField(\ref{NewFractionField} pg.\pageref{NewFractionField}), 
    CanonicalHom(\ref{CanonicalHom} pg.\pageref{CanonicalHom}), 
    PolyAlgebraHom(\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}), 
    PolyRingHom(\ref{PolyRingHom} pg.\pageref{PolyRingHom})
\end{command} % -- end command --------------------------------

\section{InitialIdeal}
\label{InitialIdeal}
\begin{command} % -- COMMAND: InitialIdeal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
InitialIdeal(I: IDEAL, Inds: LIST): IDEAL
\end{Verbatim}


\subsection*{Description}

Let ``\verb&Inds&'' be a subset of the set of indeterminates,
and let 0 be the degree of the remaining indeterminates.
The \textbf{initial form with respect to Inds} of a polynomial ``\verb&f&'' 
is the homogeneous component of ``\verb&f&'' of the lowest degree
(in contrast with the \textbf{leading form}, see ``\verb&LF&'' (\ref{LF} pg.\pageref{LF}), ``\verb&DF&'' (\ref{DF} pg.\pageref{DF})).
The \textbf{initial ideal} of the ideal ``\verb&I&'' is the ideal
generated by the initial forms of all polynomials in ``\verb&I&''.
\par 
If ``\verb&Inds&'' is the set of all indeterminates then the initial ideal 
is also called the \textbf{tangent cone} of ``\verb&I&'' (``\verb&TgCone&'' (\ref{TgCone} pg.\pageref{TgCone})).
\par 
The implementation is based on Lazard's method
(see Kreuzer-Robbiano, Computational Commutative Algebra 2, pg.463).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  I := ideal(x^3 +x^2 -y^2);
/**/  InitialIdeal(I, [x,y]);
ideal(x^2 -y^2)
/**/  TgCone(I);
ideal(x^2 -y^2)

/**/  use R ::= QQ[x,y];
/**/  I := ideal(x^2 +x*y);
/**/  InitialIdeal(I, [x,y]);
ideal(x^2 +x*y)
/**/  InitialIdeal(I, [x]);
ideal(x*y)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  TgCone(\ref{TgCone} pg.\pageref{TgCone}), 
    PrimaryHilbertSeries(\ref{PrimaryHilbertSeries} pg.\pageref{PrimaryHilbertSeries})
\end{command} % -- end command --------------------------------

\section{insert [OBSOLESCENT]}
\label{insert [OBSOLESCENT]}
\begin{command} % -- COMMAND: insert [OBSOLESCENT] ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
[OBSOLESCENT] insert(ref L: LIST, N: INT, E: OBJECT)
\end{Verbatim}


\subsection*{Description}

This function inserts ``\verb&E &''into ``\verb&L&'' as the ``\verb&N&''-th component.
Kept just for backward compatibility, it is \textbf{strongly discouraged} for its
intrinsic inefficiency.  See ``\verb&append&'' (\ref{append} pg.\pageref{append}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := ["a","b","d","e"];
/**/  insert(ref L,3,"c");
/**/  L;
["a", "b", "c", "d", "e"]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  append(\ref{append} pg.\pageref{append}), 
    remove(\ref{remove} pg.\pageref{remove})
\end{command} % -- end command --------------------------------

\section{Interpolate}
\label{Interpolate}
\begin{command} % -- COMMAND: Interpolate ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
Interpolate(Points: LIST, Values: LIST): RINGELEM

where Points is a list of lists of coefficients representing a set of
\textbf{distinct} points and Values is a list of the same size containing
numbers from the coefficient ring.
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function returns a multivariate polynomial which takes given
values at a given set of points.
\par 
NOTE:
\par 
 * the current ring must have at least as many indeterminates as the
   dimension of the space in which the points lie;
\par 
 * the base field for the space in which the points lie is taken to be
   the coefficient ring, which should be a field;
\par 
 * in the polynomials returned, the first coordinate in the space is
   taken to correspond to the first indeterminate, the second to the
   second, and so on;
\par 
 * if the number of points is large, say 100 or more, the returned
   value can be very large.  To avoid possible problems when printing
   such values as a single item we recommend printing out the elements
   one at a time as in this example:
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  X := Interpolate(Pts, Vals);
  foreach element in X do
    println element;
  endforeach;

  use QQ[x,y];
  Points := [[1/2, 2], [3/4, 4], [5, 6/11], [-1/2, -2]];
  Values := [1/2,1/3,1/5,-1/2];
  F := Interpolate(Points, Values);
  F;
-46849/834000y^2 - 1547/52125x + 13418/52125y + 46849/208500
-------------------------------
  [Eval(F, P) | P in Points] = Values;  -- check
true
-------------------------------
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{interreduce}
\label{interreduce}
\begin{command} % -- COMMAND: interreduce ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
interreduce(ref L: LIST of RINGELEM)
\end{Verbatim}


\subsection*{Description}

This function is the same as ``\verb&interreduced&'', but modifies the
argument ``\verb&L&'', and returns nothing.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  L := [x^3-x*y^2+y*z, x*y, z];
/**/  interreduce(ref L);  -- returns nothing, modifies L
/**/  L;
[z,  x*y,  x^3]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  interreduced(\ref{interreduced} pg.\pageref{interreduced})
\end{command} % -- end command --------------------------------

\section{interreduced}
\label{interreduced}
\begin{command} % -- COMMAND: interreduced ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
interreduced(L: LIST of RINGELEM): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns an interreduced list ``\verb&L0&'' of polynomials,
\textit{i.e.} each polynomial in ``\verb&L0&'' is fully reduced with respect to the others,
such that ``\verb&L&'' and ``\verb&L0&'' generate the same ideal.
\par 
This is generally computed in several interreducing loops.
In each loop each polynomial in the list is fully reduced with respect
to the others, and this process terminates when a loop finds no
possible reduction.
Verbosity shows how many loops are performed.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y,z];
/**/ L := [x^3-x*y^2+y*z,  x*y,  z];
/**/ interreduced(L);
[z,  x*y,  x^3]
/**/ L; -- unmodified
[x^3 -x*y^2 +y*z,  x*y,  z]

/**/ SetVerbosityLevel(90);
/**/ L := [x^3*y^3 -y,  x^3*y^2 +x,  x^3*y +y^2];
/**/ interreduced(L);
interreduced: loop n.1
interreduced: loop n.2
interreduced: loop n.3
interreduced: loop n.4
interreduced: loop n.5
[-2*y,  x]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{intersection}
\label{intersection}
\begin{command} % -- COMMAND: intersection ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
intersection(A: LIST,  B: LIST):  LIST
intersection(A: IDEAL, B: LIST):  LIST
intersection(A: LIST,  B: IDEAL): LIST
intersection(A: IDEAL, B: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

This function returns the intersection of ``\verb&A&'' and ``\verb&B&''.
\par 
The coefficient ring must be a field.
\par 
NOTE: To compute the intersection of ideals corresponding to
zero-dimensional schemes, see the commands ``\verb&GBM&'' (\ref{GBM} pg.\pageref{GBM}) and ``\verb&HGBM&'' (\ref{HGBM} pg.\pageref{HGBM}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  intersection(ideal(x,y,z), ideal(x*y));
ideal(x*y)

/**/  intersection(["a","b","c"], ["b","c","d"]);
["b", "c"]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GBM(\ref{GBM} pg.\pageref{GBM}), 
    HGBM(\ref{HGBM} pg.\pageref{HGBM}), 
    IntersectionList(\ref{IntersectionList} pg.\pageref{IntersectionList})
\end{command} % -- end command --------------------------------

\section{IntersectionList}
\label{IntersectionList}
\begin{command} % -- COMMAND: IntersectionList ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IntersectionList(L: LIST of LIST): LIST
IntersectionList(L: LIST of IDEAL): IDEAL
IntersectionList(L: LIST of MODULE): MODULE
\end{Verbatim}


\subsection*{Description}

This function returns the intersection of all elements in ``\verb&L&''.
Generalizes ``\verb&intersection&'' (\ref{intersection} pg.\pageref{intersection}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  Points := [[0,0],[1,0],[0,1],[1,1]]; -- a list of points in the plane
/**/  IntersectionList([ ideal(x-P[1]*z, y-P[2]*z)  |  P in Points]);
ideal(y^2 - y*z, x^2 - x*z)

/**/ IntersectionList([ 1..7, 3..10, 0..5 ]);
[3, 4, 5]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  intersection(\ref{intersection} pg.\pageref{intersection}), 
    IdealOfProjectivePoints(\ref{IdealOfProjectivePoints} pg.\pageref{IdealOfProjectivePoints}), 
    IdealOfPoints(\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}), 
    HGBM(\ref{HGBM} pg.\pageref{HGBM}), 
    intersection(\ref{intersection} pg.\pageref{intersection})
\end{command} % -- end command --------------------------------

\section{inverse}
\label{inverse}
\begin{command} % -- COMMAND: inverse ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
inverse(X: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function computes the multiplicative inverse of its argument.
It is included for use when writing inverse(X) comes more naturally
than writing ``\verb&X^(-1)&'', though both notations are functionally equivalent.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  inverse(mat([[1,2], [3,4]]));
matrix(QQ,
 [[-2, 1],
  [3/2, -1/2]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  adj(\ref{adj} pg.\pageref{adj})
\end{command} % -- end command --------------------------------

\section{InverseSystem}
\label{InverseSystem}
\begin{command} % -- COMMAND: InverseSystem ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
InverseSystem(I: IDEAL, D: INT): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

Thanks to Enrico Carlini.
\par 
Given an ideal of derivations ``\verb&I&'', and an integer ``\verb&D&'', this function
computes the degree ``\verb&D&'' part of the inverse system of ``\verb&I&''.
\par 
For the sake of simplicity Forms/Polynomials and Derivations live in
the same ring, the distinction between them is purely formal.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  InverseSystem(ideal(x^3+x*y*z), 3);
[z^3, y*z^2, x*z^2, y^2*z, x^2*z, y^3, x*y^2, x^2*y, x^3 - 6*x*y*z]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  DerivationAction(\ref{DerivationAction} pg.\pageref{DerivationAction}), 
    PerpIdealOfForm(\ref{PerpIdealOfForm} pg.\pageref{PerpIdealOfForm})
\end{command} % -- end command --------------------------------

\section{IsAntiSymmetric}
\label{IsAntiSymmetric}
\begin{command} % -- COMMAND: IsAntiSymmetric ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsAntiSymmetric(M: MAT): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the square matrix ``\verb&M&'' is anti-symmetric.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[0, 1, 2], [-1, 0, 3], [-2, -3, 0]]);
/**/  IsAntiSymmetric(M);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsSymmetric(\ref{IsSymmetric} pg.\pageref{IsSymmetric})
\end{command} % -- end command --------------------------------

\section{IsArrCentral}
\label{IsArrCentral}
\begin{command} % -- COMMAND: IsArrCentral ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsArrCentral(A: LIST): BOOL 
\end{Verbatim}


\subsection*{Description}

This function tests whether the arrangement is central from the list A of hyperplanes.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, x-y, y];
/**/ IsArrCentral(A);
true

/**/ A := [x, x-1, y];
/**/ IsArrCentral(A);
false
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{IsArrFree}
\label{IsArrFree}
\begin{command} % -- COMMAND: IsArrFree ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsArrFree(Q: RINGELEM): BOOL 
\end{Verbatim}


\subsection*{Description}

This function tests whether the arrangement A is free from its defining equation Q.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, x-y, y];
/**/ Q_A := product(A);
/**/ IsArrFree(Q_A);    
true

/**/ use QQ[x,y,z];    
/**/ A := [x, x+z, y, 2*y-3*z];
/**/ IsArrFree(product(A));
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ArrDerModule(\ref{ArrDerModule} pg.\pageref{ArrDerModule}), 
    ArrExponents(\ref{ArrExponents} pg.\pageref{ArrExponents})
\end{command} % -- end command --------------------------------

\section{IsAtEOF}
\label{IsAtEOF}
\begin{command} % -- COMMAND: IsAtEOF ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsAtEOF(in: ISTREAM): BOOL 
\end{Verbatim}


\subsection*{Description}

This function tests whether the input stream ``\verb&in&'' has reached end of input.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Istring := OpenIString("just one line");
/**/  GetLine(Istring);
just one line
/**/  IsAtEOF(Istring);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GetLine(\ref{GetLine} pg.\pageref{GetLine}), 
    OpenIFile(\ref{OpenIFile} pg.\pageref{OpenIFile}), 
    OpenIString(\ref{OpenIString} pg.\pageref{OpenIString})
\end{command} % -- end command --------------------------------

\section{IsCommutative}
\label{IsCommutative}
\begin{command} % -- COMMAND: IsCommutative ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsCommutative(R: RING): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the ring ``\verb&R&'' is commutative.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsCommutative(ZZ);
true
/**/  IsCommutative(NewWeylAlgebra(ZZ,"x,y"));
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewWeylAlgebra(\ref{NewWeylAlgebra} pg.\pageref{NewWeylAlgebra})
\end{command} % -- end command --------------------------------

\section{IsConstant}
\label{IsConstant}
\begin{command} % -- COMMAND: IsConstant ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsConstant(X: RINGELEM): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the value of ``\verb&X&'' in a polynomial ring
actually lies in the image of the coefficient ring.  It is equivalent to
checking that the degree is 0 (or the support comprises just the PP 1).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  QQx ::= QQ[x];
/**/  use QQx[y,z];
/**/  IsConstant(y+1);
false
/**/  IsConstant(x+1);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  indets(\ref{indets} pg.\pageref{indets})
\end{command} % -- end command --------------------------------

\section{IsContained}
\label{IsContained}
\begin{command} % -- COMMAND: IsContained ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsContained(A: IDEAL, B: IDEAL): BOOL
IsContained(A: MODULE, B: MODULE): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether A is contained in B.
Was ``\verb&<=&'' in CoCoA-4: this syntax is no longer supported.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  IsContained(ideal(x), ideal(x+y, x-y));
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsIn(\ref{IsIn} pg.\pageref{IsIn}), 
    IsSubset(\ref{IsSubset} pg.\pageref{IsSubset})
\end{command} % -- end command --------------------------------

\section{IsCoprime}
\label{IsCoprime}
\begin{command} % -- COMMAND: IsCoprime ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsCoprime(t1: RINGELEM, t2: RINGELEM): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether two POWER-PRODUCTS ``\verb&t1&'' and ``\verb&t2&''
are coprime.  (".. is coprime with ..").
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y,z];
/**/ IsCoprime(x*y, y*z);
false
/**/ IsCoprime(x*y, z);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsDivisible(\ref{IsDivisible} pg.\pageref{IsDivisible})
\end{command} % -- end command --------------------------------

\section{IsDefined}
\label{IsDefined}
\begin{command} % -- COMMAND: IsDefined ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsDefined(E)
\end{Verbatim}


\subsection*{Description}

This function returns true if ``\verb&E&'' is defined, otherwise it returns false.
Typically, it is used to check if a name has already been assigned.
\par 
To know if a field in a record has been assigned use ``\verb&fields&'' (\ref{fields} pg.\pageref{fields}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsDefined(MyVariable);
false

/**/  MyVariable := 3;
/**/  IsDefined(MyVariable);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  fields(\ref{fields} pg.\pageref{fields})
\end{command} % -- end command --------------------------------

\section{IsDiagonal}
\label{IsDiagonal}
\begin{command} % -- COMMAND: IsDiagonal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsDiagonal(M: MAT): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the square matrix M is diagonal.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[0, 1, 2],[-1, 0, 3],[-2, -3, 0]]);
/**/  IsDiagonal(M);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsSymmetric(\ref{IsSymmetric} pg.\pageref{IsSymmetric}), 
    DiagMat(\ref{DiagMat} pg.\pageref{DiagMat})
\end{command} % -- end command --------------------------------

\section{IsDivisible}
\label{IsDivisible}
\begin{command} % -- COMMAND: IsDivisible ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsDivisible(A: RINGELEM, B: RINGELEM): BOOL
IsDivisible(A: INT, B: INT): BOOL
IsDivisible(A: RINGELEM, B: INT): BOOL
IsDivisible(A: INT, B: RINGELEM): BOOL
\end{Verbatim}


\subsection*{Description}

This function says whether ``\verb&A&'' is divisible by ``\verb&B&''; it returns ``\verb&true&'' if so,
otherwise ``\verb&false&''.  An exception is thrown if the test is in a field; to
permit testing also field elements use ``\verb&IsDivisible_AllowFields&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y,z];
/**/ IsDivisible(x, x^2*(y-1));
false
/**/ IsDivisible(x^2*(y-1), x);
true
/**/ IsDivisible(9,3);
true
/**/ IsDivisible(9,2);
false
/**/ IsDivisible(9*x,2); -- 9*x is in QQ[x], so divisible by any constant!!
true
/**/ use ZZ[x];
/**/ IsDivisible(9*x,2);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  FactorMultiplicity(\ref{FactorMultiplicity} pg.\pageref{FactorMultiplicity}), 
    IsCoprime(\ref{IsCoprime} pg.\pageref{IsCoprime})
\end{command} % -- end command --------------------------------

\section{IsElem}
\label{IsElem}
\begin{command} % -- COMMAND: IsElem ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsElem(A: RINGELEM, B: IDEAL): BOOL
IsElem(A: MODULEELEM, B: MODULE): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether ``\verb&A&'' is an element of ``\verb&B&''.
Same as the command ``\verb&IsIn&'' (\ref{IsIn} pg.\pageref{IsIn}), but works on fewer types: it
is in CoCoA-5 for compatibility with the C++ function in CoCoALib.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  IsElem(x, ideal(x+y, x-y));
true

/**/  x IsIn ideal(x+y, x-y);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsIn(\ref{IsIn} pg.\pageref{IsIn})
\end{command} % -- end command --------------------------------

\section{IsEmpty}
\label{IsEmpty}
\begin{command} % -- COMMAND: IsEmpty ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsEmpty(L: LIST): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether ``\verb&L&'' is empty; it is equivalent to ``\verb&l = []&''..
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [1.2];
/**/  IsEmpty(L);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  List Constructors(\ref{List Constructors} pg.\pageref{List Constructors})
\end{command} % -- end command --------------------------------

\section{IsEven, IsOdd}
\label{IsEven, IsOdd}
\begin{command} % -- COMMAND: IsEven, IsOdd ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsEven(N: INT): BOOL
IsOdd(N: INT): BOOL
\end{Verbatim}


\subsection*{Description}

These functions test whether an integer is even or odd.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsEven(3);
false
/**/  IsOdd(3);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsZero(\ref{IsZero} pg.\pageref{IsZero})
\end{command} % -- end command --------------------------------

\section{IsEvenPoly, IsOddPoly}
\label{IsEvenPoly, IsOddPoly}
\begin{command} % -- COMMAND: IsEvenPoly, IsOddPoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsEvenPoly(F: RINGELEM): BOOL
IsOddPoly(F: RINGELEM): BOOL
\end{Verbatim}


\subsection*{Description}

These functions test whether a polynomial is even or odd (as a function).
Of course, most polynomials are neither even nor odd.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x];
/**/  f := x^2+1;
/**/  IsEvenPoly(f);
true
/**/  IsOddPoly(x*f);
true
/**/  IsEvenPoly(f+x);
false
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{IsFactorClosed}
\label{IsFactorClosed}
\begin{command} % -- COMMAND: IsFactorClosed ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsFactorClosed(L: LIST of power products): BOOL
\end{Verbatim}


\subsection*{Description}

A set of power products is factor closed iff it contains every factor of
every one of its elements.  This function checks whether the given set
is factor closed (also known as "order-ideal").  It is an error if the
list ``\verb&L&'' is empty.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  IsFactorClosed([1, x, x^2]);
true
/**/  IsFactorClosed([one(P), y^2]);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  QuotientBasis(\ref{QuotientBasis} pg.\pageref{QuotientBasis}), 
    LT(\ref{LT} pg.\pageref{LT}), 
    ApproxPointsNBM(\ref{ApproxPointsNBM} pg.\pageref{ApproxPointsNBM}), 
    IsStronglyStable(\ref{IsStronglyStable} pg.\pageref{IsStronglyStable})
\end{command} % -- end command --------------------------------

\section{IsField}
\label{IsField}
\begin{command} % -- COMMAND: IsField ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsField(R: RING): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether a ring is a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsField(ZZ);
false
/**/  IsField(QQ);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsFiniteField(\ref{IsFiniteField} pg.\pageref{IsFiniteField})
\end{command} % -- end command --------------------------------

\section{IsFiniteField}
\label{IsFiniteField}
\begin{command} % -- COMMAND: IsFiniteField ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsFiniteField(R: RING): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether a ring is a finite field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsFiniteField(ZZ);
false
/**/  IsFiniteField(QQ);
false
/**/  Fp::=ZZ/(7); IsFiniteField(Fp);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsField(\ref{IsField} pg.\pageref{IsField}), 
    IsPthPower(\ref{IsPthPower} pg.\pageref{IsPthPower}), 
    LogCardinality(\ref{LogCardinality} pg.\pageref{LogCardinality}), 
    PthRoot(\ref{PthRoot} pg.\pageref{PthRoot})
\end{command} % -- end command --------------------------------

\section{IsFractionField}
\label{IsFractionField}
\begin{command} % -- COMMAND: IsFractionField ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsFractionField(R: RING): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the ring ``\verb&R&'' is a fraction field,
\textit{i.e.} is ``\verb&QQ&'' (\ref{QQ} pg.\pageref{QQ}) or has been constructed with ``\verb&NewFractionField&'' (\ref{NewFractionField} pg.\pageref{NewFractionField}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];  R;
RingWithID(201, "QQ[x,y]")
/**/  IsFractionField(R);
false
/**/  K := NewFractionField(R);  K;
RingWithID(202, "FractionField(RingWithID(201))")
/**/  IsFractionField(K);
true
/**/ BaseRing(K);
RingWithID(201, "QQ[x,y]")
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewFractionField(\ref{NewFractionField} pg.\pageref{NewFractionField}), 
    BaseRing(\ref{BaseRing} pg.\pageref{BaseRing}), 
    RingID(\ref{RingID} pg.\pageref{RingID})
\end{command} % -- end command --------------------------------

\section{IsHomog}
\label{IsHomog}
\begin{command} % -- COMMAND: IsHomog ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsHomog(F: RINGELEM|MODULEELEM): BOOL
IsHomog(L: LIST): BOOL
IsHomog(I: IDEAL|MODULE): BOOL
\end{Verbatim}


\subsection*{Description}

The first form of this function returns ``\verb&true&'' if ``\verb&F&'' is homogeneous.
The second form returns ``\verb&true&'' if every element of ``\verb&L&'' is homogeneous.
Otherwise, they return ``\verb&false&''.  The third form returns ``\verb&true&'' if the
ideal/module can be generated by homogeneous elements, and ``\verb&false&''
if not.
\par 
NOTE: when the grading dimension is 0 everything is homogeneous.
For safety reasons (from version CoCoALib-5.0.3) ``\verb&IsHomog&''
throws an error in this case, \textit{e.g.} ``\verb&IsHomog(x-1)&'' gives error
instead of a possibly misleading ``\verb&true&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  IsHomog(x^2-x*y);
true

/**/  IsHomog(x-y^2);
false

/**/  IsHomog([x^2-x*y, x-y^2]);
false

/**/  R := NewPolyRing(QQ, "x,y", mat([[2,3],[1,2]]), 1);
/**/  use R;
/**/  IsHomog(x^3*y^2+y^4);
true

/**/  R := NewPolyRing(QQ, "x,y", mat([[2,3],[1,2]]), 2);
/**/  use R;
/**/  IsHomog(x^3*y^2+y^4);
false

/**/  use R ::= QQ[x,y];
/**/  IsHomog(ideal(x^2+y,y));
true

/**/  use R ::= QQ[x,y], Lex;  -- note: GradingDim = 0
-- /**/  IsHomog(x-1); -- !!! ERROR !!! as expected: instead of "true"
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  deg(\ref{deg} pg.\pageref{deg}), 
    homog(\ref{homog} pg.\pageref{homog}), 
    wdeg(\ref{wdeg} pg.\pageref{wdeg})
\end{command} % -- end command --------------------------------

\section{IsIn}
\label{IsIn}
\begin{command} % -- COMMAND: IsIn ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
X  IsIn  Y        (return BOOL)
\end{Verbatim}


\subsection*{Description}

The semantics of ``\verb&IsIn&'' is explained in the following table:
\begin{verbatim}
   --------------------------------------------------------------------
  | OBJECT     IsIn  LIST    checks if the list contains the object.   |
  | RINGELEM   IsIn  IDEAL   checks for ideal membership.              |
  | MODULEELEM IsIn  MODULE  checks for module membership.             |
  | STRING     IsIn  STRING  checks if the first string is a substring |
  |                          of the second one.                        |
   --------------------------------------------------------------------
NOTE: if RINGELEM (or MODULEELEM) is in an IDEAL (or MODULE), a
  representation in terms of the generators is given by ``\verb&GenRepr&'' (\ref{GenRepr} pg.\pageref{GenRepr}).
\end{verbatim}

\SeeAlso %---- SEE ALSO ----
  GenRepr(\ref{GenRepr} pg.\pageref{GenRepr})
\end{command} % -- end command --------------------------------

\section{IsIndet}
\label{IsIndet}
\begin{command} % -- COMMAND: IsIndet ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsIndet(X: RINGELEM): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether ``\verb&X&'' is an indeterminate.  If so, it
returns ``\verb&true&''; otherwise it returns ``\verb&false&''.  An error is
signalled if ``\verb&X&'' is not a RINGELEM or if ``\verb&RingOf(X)&'' is not a
polynomial ring.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  IsIndet(x);
true
/**/  IsIndet(x-1);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsIndetPosPower(\ref{IsIndetPosPower} pg.\pageref{IsIndetPosPower})
\end{command} % -- end command --------------------------------

\section{IsIndetPosPower}
\label{IsIndetPosPower}
\begin{command} % -- COMMAND: IsIndetPosPower ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsIndetPosPower(X: RINGELEM): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether ``\verb&X&'' is a (positive) power of an indeterminate.
If so, it returns ``\verb&true&''; otherwise it returns ``\verb&false&''.  An error is
signalled if ``\verb&X&'' is not a RINGELEM or if ``\verb&RingOf(X)&'' is not a
polynomial ring.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  IsIndetPosPower(x);
true
/**/  IsIndetPosPower(x/x);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsIndet(\ref{IsIndet} pg.\pageref{IsIndet})
\end{command} % -- end command --------------------------------

\section{IsInImage}
\label{IsInImage}
\begin{command} % -- COMMAND: IsInImage ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsInImage(phi: RINGHOM, f: RINGELEM): BOOL
\end{Verbatim}


\subsection*{Description}

This function checks if ``\verb&f&'' is in the image of ``\verb&phi&''
(better use ``\verb&preimage0&'' (\ref{preimage0} pg.\pageref{preimage0}) directly).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  QQxyz ::= QQ[x,y,z];
/**/  QQab  ::= QQ[a,b];

/**/  use QQab;
/**/  phi := PolyAlgebraHom(QQxyz, QQab, [a+1, a*b+3, b^2]);

/**/  IsInImage(phi, b);
false
/**/  preimage0(phi, b);
0
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsSurjective(\ref{IsSurjective} pg.\pageref{IsSurjective}), 
    preimage0(\ref{preimage0} pg.\pageref{preimage0})
\end{command} % -- end command --------------------------------

\section{IsInjective}
\label{IsInjective}
\begin{command} % -- COMMAND: IsInjective ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsInjective(phi: RINGHOM): BOOL
\end{Verbatim}


\subsection*{Description}

This function checks if a RINGHOM is injective.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  QQxyz ::= QQ[x,y,z];
/**/  QQab  ::= QQ[a,b];

/**/  use QQab;
/**/  phi := PolyAlgebraHom(QQxyz, QQab, [a+1, a*b+3, b^2]);
/**/  IsInjective(phi);
false
/**/  ker(phi);
ideal(-x^2*z +y^2 +2*x*z -6*y -z +9)
/**/  IsSurjective(phi);
false

/**/  use QQab;
/**/  preimage0(phi, b);
0

/**/  preimage0(phi, a^2);
x^2 -2*x +1

/**/  phi(RingElem(QQxyz, "x^2 - 2*x + 1"));
a^2
/**/  phi(RingElem(QQxyz, "x^2 - 2*x + 1 + (-x^2*z +y^2 +2*x*z -6*y -z +9)"));
a^2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ker(\ref{ker} pg.\pageref{ker}), 
    preimage0(\ref{preimage0} pg.\pageref{preimage0}), 
    IsSurjective(\ref{IsSurjective} pg.\pageref{IsSurjective})
\end{command} % -- end command --------------------------------

\section{IsInRadical}
\label{IsInRadical}
\begin{command} % -- COMMAND: IsInRadical ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsInRadical(F: RINGELEM, I: IDEAL): BOOL
IsInRadical(J: IDEAL, I: IDEAL): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the first argument, a polynomial or an
ideal, is contained in the radical of the second argument, an ideal.
\par 
This function is much faster than asking ``\verb&F IsIn Radical(I);&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  I := ideal(x^6*y^4, z);
/**/  IsInRadical(x*y, I);
true
/**/  IsInRadical(ideal(x,y), I);
false
/**/  MinPowerInIdeal(x*y, I);
6
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  MinPowerInIdeal(\ref{MinPowerInIdeal} pg.\pageref{MinPowerInIdeal}), 
    radical(\ref{radical} pg.\pageref{radical})
\end{command} % -- end command --------------------------------

\section{IsInSubalgebra [OBSOLETE]}
\label{IsInSubalgebra [OBSOLETE]}
\begin{command} % -- COMMAND: IsInSubalgebra [OBSOLETE] ------------



\subsection*{Description}

See ``\verb&SubalgebraHom&'' (\ref{SubalgebraHom} pg.\pageref{SubalgebraHom}).

\end{command} % -- end command --------------------------------

\section{IsInteger}
\label{IsInteger}
\begin{command} % -- COMMAND: IsInteger ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsInteger(ref n: INT, f: RINGELEM): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the argument ``\verb&f&'' is integer and
convert it into an INT.
To convert ``\verb&f&'' straight away use ``\verb&AsINT(f)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use R ::= QQ[x];
/**/ f := x-x-3;  f;  type(f);
-3
RINGELEM
/**/ IsInteger(ref a, x-x-3);
true
/**/ a;  type(a);
-3
INT
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  AsINT(\ref{AsINT} pg.\pageref{AsINT}), 
    AsRAT(\ref{AsRAT} pg.\pageref{AsRAT}), 
    IsRational(\ref{IsRational} pg.\pageref{IsRational})
\end{command} % -- end command --------------------------------

\section{IsIntegralDomain}
\label{IsIntegralDomain}
\begin{command} % -- COMMAND: IsIntegralDomain ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsIntegralDomain(R: RING): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the ring ``\verb&R&'' is integral.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ IsIntegralDomain(ZZ);
true
/**/ IsIntegralDomain(NewZZmod(6));
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsField(\ref{IsField} pg.\pageref{IsField})
\end{command} % -- end command --------------------------------

\section{IsInvertible}
\label{IsInvertible}
\begin{command} % -- COMMAND: IsInvertible ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsInvertible(f: RINGELEM): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the argument ``\verb&f&'' is invertible in
``\verb&RingOf(f)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  Q := R/ideal(x^2+1);
/**/  use Q;
/**/  IsInvertible(x-2);
true
/**/ 1/(x-2);
((-1/5)*x -2/5)
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{IsIrred}
\label{IsIrred}
\begin{command} % -- COMMAND: IsIrred ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsIrred(f: RINGELEM): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the argument ``\verb&f&'' is irreducible in
``\verb&RingOf(f)&''.  The coefficient ring must be a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ FFp := NewZZmod(7);
/**/ use FFp[x];
/**/ f := x^9+x+1;
/**/ IsIrred(f);
true
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{IsLattice}
\label{IsLattice}
\begin{command} % -- COMMAND: IsLattice ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsLattice(relP: LIST): BOOL 
\end{Verbatim}


\subsection*{Description}

This function tests whether the poset P is a lattice from the list relP of its strict relations.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
// POSET:
//         3   4
//          \ /
//           2
//           |
//           1
/**/ relP := [[1,  2], [2, 3],  [2,  4]];    
/**/ IsLattice(relP);
false
    
// P:
//           5
//         /  \   
//        3    4
//        |    |
//         2   |
//          \ /
//           1
/**/ relP := [[1,2],  [2,3],  [1,4],  [3,5],  [4,5]];
/**/ IsLattice(relP);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsPosetGraded(\ref{IsPosetGraded} pg.\pageref{IsPosetGraded})
\end{command} % -- end command --------------------------------

\section{IsLexSegment}
\label{IsLexSegment}
\begin{command} % -- COMMAND: IsLexSegment ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsLexSegment(I: IDEAL): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the monomial ideal I is a lex-segment ideal.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x*y^3, y^4, x^3, x^2*y, x^2*z);
/**/  IsLexSegment(I);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsStable(\ref{IsStable} pg.\pageref{IsStable}), 
    IsStronglyStable(\ref{IsStronglyStable} pg.\pageref{IsStronglyStable}), 
    LexSegmentIdeal(\ref{LexSegmentIdeal} pg.\pageref{LexSegmentIdeal})
\end{command} % -- end command --------------------------------

\section{IsMaximal}
\label{IsMaximal}
\begin{command} % -- COMMAND: IsMaximal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsMaximal(I: IDEAL): BOOL
\end{Verbatim}


\subsection*{Description}

This function determines whether an ideal is maximal.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  IsMaximal(ideal(x^2+1, z^3+z-1, x-5*y+4*z));
true 
/**/  IsMaximal(ideal(x^2+1, z^3+z-1, (x-5*y+4*z)*(y-3)));
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsPrimary(\ref{IsPrimary} pg.\pageref{IsPrimary}), 
    IsRadical(\ref{IsRadical} pg.\pageref{IsRadical})
\end{command} % -- end command --------------------------------

\section{IsMinusOne}
\label{IsMinusOne}
\begin{command} % -- COMMAND: IsMinusOne ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsOne(X: OBJECT): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether its argument is -1; the argument can be
of almost any type for which \textbf{-1} makes sense.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsMinusOne(23);
false
/**/  IsMinusOne(3/-3);
true
/**/  use R ::= QQ[x,y,z];
/**/  IsMinusOne(-x/x);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsOne(\ref{IsOne} pg.\pageref{IsOne})
\end{command} % -- end command --------------------------------

\section{IsMultiArrFree}
\label{IsMultiArrFree}
\begin{command} % -- COMMAND: IsMultiArrFree ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsMultiArrFree(MultiA: LIST): BOOL 
\end{Verbatim}


\subsection*{Description}

This function tests whether the multiarrangement MultiA is free.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ MultiA := [[x,1], [x-y,3], [y,2]];
/**/ IsMultiArrFree(MultiA);    
true

/**/ use QQ[x,y,z];	
/**/ MultiA := [[x,1], [x-y,3], [z,2], [x+y-z,3]];
/**/ IsMultiArrFree(MultiA);    
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  MultiArrDerModule(\ref{MultiArrDerModule} pg.\pageref{MultiArrDerModule}), 
    MultiArrExponents(\ref{MultiArrExponents} pg.\pageref{MultiArrExponents})
\end{command} % -- end command --------------------------------

\section{IsNumber [OBSOLETE]}
\label{IsNumber [OBSOLETE]}
\begin{command} % -- COMMAND: IsNumber [OBSOLETE] ------------



\subsection*{Description}

See ``\verb&IsInteger&'', ``\verb&IsRational&''

\end{command} % -- end command --------------------------------

\section{IsOne}
\label{IsOne}
\begin{command} % -- COMMAND: IsOne ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsOne(X: OBJECT): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether its argument is one; the argument can be
of almost any type for which \textbf{one} makes sense.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsOne(23);
false
/**/  IsOne(3/3);
true
/**/  use R ::= QQ[x,y,z];
/**/  IsOne(1);
true
/**/  IsOne(ideal(x^2, x^2-1));
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsEven, IsOdd(\ref{IsEven, IsOdd} pg.\pageref{IsEven, IsOdd}), 
    one(\ref{one} pg.\pageref{one}), 
    IsZero(\ref{IsZero} pg.\pageref{IsZero})
\end{command} % -- end command --------------------------------

\section{IsPolyRing}
\label{IsPolyRing}
\begin{command} % -- COMMAND: IsPolyRing ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsPolyRing(R: RING): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether its argument is a polynomial ring.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y];
/**/  IsPolyRing(P);
true
/**/  PmodI := NewQuotientRing(P,ideal([x])); // NO, but isom to QQ[y]
false
/**/  IsPolyRing(QQ);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsQuotientRing(\ref{IsQuotientRing} pg.\pageref{IsQuotientRing}), 
    NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing})
\end{command} % -- end command --------------------------------

\section{IsPosetGraded}
\label{IsPosetGraded}
\begin{command} % -- COMMAND: IsPosetGraded ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsPosetGraded(relP: LIST): BOOL 
\end{Verbatim}


\subsection*{Description}

This function tests whether the poset P is graded from the list relP of its strict relations.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
// POSET:
//         3   4
//          \ /
//           2
//           |
//           1
/**/ relP := [[1,  2], [2, 3],  [2,  4]];    
/**/ IsPosetGraded(relP);
true
    
// P:
//           5
//         /  \   
//        3    4
//        |    |
//         2   |
//          \ /
//           1
/**/ relP := [[1,2],  [2,3],  [1,4],  [3,5],  [4,5]];
/**/ IsPosetGraded(relP);
false
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{IsPositiveGrading}
\label{IsPositiveGrading}
\begin{command} % -- COMMAND: IsPositiveGrading ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsPositiveGrading(M: MAT): BOOL
\end{Verbatim}


\subsection*{Description}

This function determines whether a matrix of integers defines a
positive grading, \textit{i.e.} each column has a non-zero entry and its
first non-zero entry is positive.
\par 
NOTE: it also requires that the matrix has maximal rank (from
version CoCoA-5.1.3).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsPositiveGrading(LexMat(5));
true
/**/  IsPositiveGrading(submat(LexMat(5),1..3,1..5)); --only the first 3 rows
false
/**/  IsPositiveGrading(mat([[0,2,3], [1, -1, 0]]));
true
/**/  IsPositiveGrading(mat([[1,1], [0,-1]]));
true
/**/  IsPositiveGrading(mat([[1,1], [0,-1], [-1, 0]])); --not maximal rank
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  HilbertSeriesMultiDeg(\ref{HilbertSeriesMultiDeg} pg.\pageref{HilbertSeriesMultiDeg})
\end{command} % -- end command --------------------------------

\section{IsPrimary}
\label{IsPrimary}
\begin{command} % -- COMMAND: IsPrimary ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsPrimary(I: IDEAL): BOOL
\end{Verbatim}


\subsection*{Description}

This function determines whether an ideal is primary.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  IsPrimary(ideal(x^2, y^2, z));
true 
/**/  IsPrimary(ideal(x*(x-1), y^2, z));
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PrimaryDecomposition(\ref{PrimaryDecomposition} pg.\pageref{PrimaryDecomposition}), 
    IsMaximal(\ref{IsMaximal} pg.\pageref{IsMaximal}), 
    IsRadical(\ref{IsRadical} pg.\pageref{IsRadical})
\end{command} % -- end command --------------------------------

\section{IsPrime}
\label{IsPrime}
\begin{command} % -- COMMAND: IsPrime ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsPrime(N: INT): BOOL
\end{Verbatim}


\subsection*{Description}

This function determines whether a positive integer is prime; if ``\verb&N&''
is not positive, an error is signalled.  This function may be extremely
slow when ``\verb&N&'' is a large prime; in practice it is usually
better to call ``\verb&IsProbPrime&'' (\ref{IsProbPrime} pg.\pageref{IsProbPrime}).
\par 
For the curious: currently, the function first performs a probabilistic
check (Miller-Rabin), if that passes, it then verifies primality (via
the Lucas test).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsPrime(32003);
true
/**/  IsPrime(10^100);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsProbPrime(\ref{IsProbPrime} pg.\pageref{IsProbPrime}), 
    NextPrime, NextProbPrime(\ref{NextPrime, NextProbPrime} pg.\pageref{NextPrime, NextProbPrime}), 
    PrevPrime, PrevProbPrime(\ref{PrevPrime, PrevProbPrime} pg.\pageref{PrevPrime, PrevProbPrime})
\end{command} % -- end command --------------------------------

\section{IsProbPrime}
\label{IsProbPrime}
\begin{command} % -- COMMAND: IsProbPrime ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsProbPrime(N: INT): BOOL
\end{Verbatim}


\subsection*{Description}

This function returns ``\verb&true&'' if its integer argument passes a fairly
stringent primality test; otherwise it returns ``\verb&false&''.  There is a very
small chance of the function returning ``\verb&true&'' even when the argument is
composite; however, if it returns ``\verb&false&'', we are certain that the
argument is composite.  Some people call it a "compositeness test".
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsProbPrime(2);
true

/**/  IsProbPrime(1111111111111111111);
true

/**/  [N in 1..1111 | IsProbPrime((10^N-1)/9)]; -- only five values are known
[2, 19, 23, 317, 1031]                          -- next might be 49081
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsPrime(\ref{IsPrime} pg.\pageref{IsPrime}), 
    NextPrime, NextProbPrime(\ref{NextPrime, NextProbPrime} pg.\pageref{NextPrime, NextProbPrime}), 
    PrevPrime, PrevProbPrime(\ref{PrevPrime, PrevProbPrime} pg.\pageref{PrevPrime, PrevProbPrime})
\end{command} % -- end command --------------------------------

\section{IsPthPower}
\label{IsPthPower}
\begin{command} % -- COMMAND: IsPthPower ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsPthPower(X: RINGELEM): BOOL
\end{Verbatim}


\subsection*{Description}

This function determines whether a polynomial over a finite
field (of char p) is a p-th power.
If the coefficient ring is not a finite field then an error is signalled.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use ZZ/(7)[x];
/**/  IsPthPower(x^7+3);
true
/**/  IsPthPower(x^6+3);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsFiniteField(\ref{IsFiniteField} pg.\pageref{IsFiniteField}), 
    PthRoot(\ref{PthRoot} pg.\pageref{PthRoot})
\end{command} % -- end command --------------------------------

\section{IsQQ}
\label{IsQQ}
\begin{command} % -- COMMAND: IsQQ ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsQQ(R: RING): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether a ring is the ring of rationals.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  R ::= QQ[x,y];
/**/  IsQQ(CoeffRing(R));
true;
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  QQ(\ref{QQ} pg.\pageref{QQ}), 
    RingQQ(\ref{RingQQ} pg.\pageref{RingQQ}), 
    IsZZ(\ref{IsZZ} pg.\pageref{IsZZ})
\end{command} % -- end command --------------------------------

\section{isqrt [OBSOLETE]}
\label{isqrt [OBSOLETE]}
\begin{command} % -- COMMAND: isqrt [OBSOLETE] ------------



\subsection*{Description}

Renamed ``\verb&FloorSqrt&'' (\ref{FloorSqrt} pg.\pageref{FloorSqrt}).

\end{command} % -- end command --------------------------------

\section{IsQuotientRing}
\label{IsQuotientRing}
\begin{command} % -- COMMAND: IsQuotientRing ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsQuotientRing(R: RING): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether a ring is a quotient ring; it returns ``\verb&true&''
if the ring is a quotient ring.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  S := R/ideal(x);
/**/  IsQuotientRing(S);
true;
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  DefiningIdeal(\ref{DefiningIdeal} pg.\pageref{DefiningIdeal})
\end{command} % -- end command --------------------------------

\section{IsRadical}
\label{IsRadical}
\begin{command} % -- COMMAND: IsRadical ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsRadical(I: IDEAL): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the IDEAL ``\verb&I&'' is radical.
Currently works only for 0-dimensional ideals.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use R ::= QQ[x,y,z];
/**/ I := ideal(x^2-1, y^2-2, z^3);
/**/ IsRadical(I);
false
/**/ I := ideal(x^2-1, y^2-2, z^3-3);
/**/ IsRadical(I);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  radical(\ref{radical} pg.\pageref{radical}), 
    IsMaximal(\ref{IsMaximal} pg.\pageref{IsMaximal}), 
    IsPrimary(\ref{IsPrimary} pg.\pageref{IsPrimary})
\end{command} % -- end command --------------------------------

\section{IsRational}
\label{IsRational}
\begin{command} % -- COMMAND: IsRational ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsRational(ref n: RAT, f: RINGELEM): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the argument ``\verb&f&'' is rational and
convert it into a RAT.
To convert ``\verb&f&'' straight away use ``\verb&AsRAT(f)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use R ::= QQ[x];
/**/ f := x-x-3;  f;  type(f);
-3
RINGELEM
/**/ IsRational(ref a, x-x-3);
true
/**/ a;  type(a);
-3
RAT
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  AsINT(\ref{AsINT} pg.\pageref{AsINT}), 
    AsRAT(\ref{AsRAT} pg.\pageref{AsRAT}), 
    IsInteger(\ref{IsInteger} pg.\pageref{IsInteger})
\end{command} % -- end command --------------------------------

\section{IsSigmaGoodPrime}
\label{IsSigmaGoodPrime}
\begin{command} % -- COMMAND: IsSigmaGoodPrime ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsSigmaGoodPrime(p: INT, I: IDEAL): BOOL
\end{Verbatim}


\subsection*{Description}

This function checks if ``\verb&p&'' is a sigma-good prime for ``\verb&I&'',
that is if it is good for modular reduction of the sigma-reduced
GBasis of ``\verb&I&''.
\par 
See article Abbott, Bigatti, Robbiano
"Ideals modulo p"
(``\verb&https://arxiv.org/abs/1801.06112&'')
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y,z];
/**/ I := ideal(2*x*y^2 -1, 3*x^3*y -1);
/**/ ReducedGBasis(I);
[x*y^2 -1/2,  x^2 +(-2/3)*y,  y^3 +(-3/4)*x]
/**/ DenSigma(I);
12
/**/ IsSigmaGoodPrime(2,I);
false
/**/ IsSigmaGoodPrime(32003,I);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CommonDenom(\ref{CommonDenom} pg.\pageref{CommonDenom}), 
    DenSigma(\ref{DenSigma} pg.\pageref{DenSigma})
\end{command} % -- end command --------------------------------

\section{IsSqFree}
\label{IsSqFree}
\begin{command} % -- COMMAND: IsSqFree ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsSqFree(f: RINGELEM): BOOL
IsSqFree(N: INT): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the argument is square-free.
A ring elem ``\verb&f&'' must belong to a polynomial ring over a field.
Currently, it may wrongly declare as square-free an integer ``\verb&N&'' with
a repeated large prime factor.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use R ::= QQ[x];
/**/ IsSqFree(x^2);
false
/**/ IsSqFree(101);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  radical(\ref{radical} pg.\pageref{radical}), 
    factor(\ref{factor} pg.\pageref{factor}), 
    FactorINT(\ref{FactorINT} pg.\pageref{FactorINT})
\end{command} % -- end command --------------------------------

\section{IsSquare}
\label{IsSquare}
\begin{command} % -- COMMAND: IsSquare ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsSquare(N: INT): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the argument is a "perfect" square.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ IsSquare(99);
false
/**/ IsSquare(100);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsSqFree(\ref{IsSqFree} pg.\pageref{IsSqFree}), 
    FactorINT(\ref{FactorINT} pg.\pageref{FactorINT})
\end{command} % -- end command --------------------------------

\section{IsStable}
\label{IsStable}
\begin{command} % -- COMMAND: IsStable ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsStable(I: IDEAL): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the monomial ideal I is stable.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x*y^3, y^4, x^3, x^2*y, x^2*z);
/**/  IsStable(I);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsLexSegment(\ref{IsLexSegment} pg.\pageref{IsLexSegment}), 
    IsStronglyStable(\ref{IsStronglyStable} pg.\pageref{IsStronglyStable}), 
    LexSegmentIdeal(\ref{LexSegmentIdeal} pg.\pageref{LexSegmentIdeal})
\end{command} % -- end command --------------------------------

\section{IsStdGraded}
\label{IsStdGraded}
\begin{command} % -- COMMAND: IsStdGraded ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsStdGraded(P: RING): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether ``\verb&P&'' is standard graded,
\textbf{i.e.} ``\verb&GradingDim&'' is 1 and all indeterminates
in ``\verb&P&'' have degree 1.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  P ::= QQ[x,y,z];
/**/  IsStdGraded(P);
true
/**/  P ::= QQ[x,y,z], lex;
/**/  IsStdGraded(P);
false
/**/  P := NewPolyRing(QQ, "x,y", mat([[2,3],[1,2]]), 1);
/**/  IsStdGraded(P);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing}), 
    wdeg(\ref{wdeg} pg.\pageref{wdeg})
\end{command} % -- end command --------------------------------

\section{IsStronglyStable}
\label{IsStronglyStable}
\begin{command} % -- COMMAND: IsStronglyStable ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsStronglyStable(I: IDEAL): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the monomial ideal I is strongly stable
(Borel-fixed in characteristic 0).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x*y^3, y^4, x^3, x^2*y, x^2*z);
/**/  IsStronglyStable(I);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsLexSegment(\ref{IsLexSegment} pg.\pageref{IsLexSegment}), 
    IsStable(\ref{IsStable} pg.\pageref{IsStable})
\end{command} % -- end command --------------------------------

\section{IsSubset}
\label{IsSubset}
\begin{command} % -- COMMAND: IsSubset ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsSubset(L: LIST, M: LIST): BOOL
\end{Verbatim}


\subsection*{Description}

This function returns ``\verb&true&'' if ``\verb&MakeSet(L)&'' is contained in ``\verb&MakeSet(M)&'';
otherwise it returns ``\verb&false&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsSubset([1,1,2],[1,2,3,"a"]);
true
/**/  IsSubset([1,2],["a","b"]);
false
/**/  IsSubset([],[1,2]);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsContained(\ref{IsContained} pg.\pageref{IsContained}), 
    IsIn(\ref{IsIn} pg.\pageref{IsIn}), 
    EqSet(\ref{EqSet} pg.\pageref{EqSet}), 
    MakeSet(\ref{MakeSet} pg.\pageref{MakeSet}), 
    subsets(\ref{subsets} pg.\pageref{subsets})
\end{command} % -- end command --------------------------------

\section{IsSurjective}
\label{IsSurjective}
\begin{command} % -- COMMAND: IsSurjective ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsSurjective(phi: RINGHOM): BOOL
\end{Verbatim}


\subsection*{Description}

This function checks if a RINGHOM is surjective.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  QQxyz ::= QQ[x,y,z];
/**/  QQab  ::= QQ[a,b];

/**/  use QQab;
/**/  phi := PolyAlgebraHom(QQxyz, QQab, [a+1, a*b+3, b^2]);
ideal(-x^2*z +y^2 +2*x*z -6*y -z +9)
/**/  IsSurjective(phi);
false

/**/  preimage0(phi, b);
0
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ker(\ref{ker} pg.\pageref{ker}), 
    IsInjective(\ref{IsInjective} pg.\pageref{IsInjective}), 
    preimage0(\ref{preimage0} pg.\pageref{preimage0})
\end{command} % -- end command --------------------------------

\section{IsSymmetric}
\label{IsSymmetric}
\begin{command} % -- COMMAND: IsSymmetric ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsSymmetric(M: MAT): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the square matrix ``\verb&M&'' is symmetric.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ M := mat([[1, 2, 3],  [2, 4, 5],  [3, 5, 6]]);
/**/ IsSymmetric(M);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsAntiSymmetric(\ref{IsAntiSymmetric} pg.\pageref{IsAntiSymmetric})
\end{command} % -- end command --------------------------------

\section{IsTerm}
\label{IsTerm}
\begin{command} % -- COMMAND: IsTerm ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsTerm(X: RINGELEM|MODULEELEM): BOOL
\end{Verbatim}


\subsection*{Description}

The function determines whether X is a term.  For a polynomial, a
\textbf{term} is a power-product, namely, a product of indeterminates.
Thus, $x*y^2*z$ is a term, while $4*x*y^2*z$ and $x*y+z^3$ are not.
For a vector, a term is a power-product times a standard basis vector, for
instance $(0, x*y^2*z, 0)$.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  IsTerm(x+y^2);
false

/**/  IsTerm(x^3*y*z^2);
true

/**/  IsTerm(5*x^3*y*z^2);
false

/**/  R2 := NewFreeModule(R,2);
--/**/  IsTerm(ModuleElem(R2, [0,x*z])); --***WORK IN PROGRESS***
--true

--/**/  IsTerm(ModuleElem(R2, [x,y])); --***WORK IN PROGRESS***
--false
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{IsTermOrdering}
\label{IsTermOrdering}
\begin{command} % -- COMMAND: IsTermOrdering ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsTermOrdering(M: MAT): BOOL
\end{Verbatim}


\subsection*{Description}

This function determines whether a square matrix defines a term-ordering,
\textit{i.e.} if its determinant is non-zero and if for each column the first
nonnegative entry is positive.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsTermOrdering(LexMat(5));
true

/**/  IsTermOrdering(StdDegRevLexMat(5));
true

/**/  IsTermOrdering(RevLexMat(5));
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing}), 
    OrdMat(\ref{OrdMat} pg.\pageref{OrdMat})
\end{command} % -- end command --------------------------------

\section{IsTree5}
\label{IsTree5}
\begin{command} % -- COMMAND: IsTree5 ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsTree5(L: LIST): [BOOL, LIST ]
IsTree5(L: LIST, "NOOPT"): [BOOL, LIST]
IsTree5(L: LIST, "OPT"): [BOOL, LIST]
IsTree5(L: LIST, "CS_NOOPT"): [BOOL, LIST]
IsTree5(L: LIST, "CS_OPT"): [BOOL, LIST]
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function is implemented in CoCoALib.
\par 
This function tests whether the facet complex described by the
list L of square free power products is a tree, plus a list which:
\par 
- is empty if L is a tree
\par 
- contains three elements of a cycle of L if L is not a tree.
\par 
Four options ``\verb&NOOPT&'',``\verb&OPT&'',``\verb&CS_NOOPT&'',``\verb&CS_OPT&'' are available as second
argument, specifying different algorithms; the default is ``\verb&CS_OPT&''.
\par 
For a full description of the algorithms we refer to the paper by
M. Caboara, S. Faridi, and P. Selinger, "Simplicial cycles and
the computation of simplicial trees", Journal of Symbolic Computation,
vol.42/1-2, pp.77-88 (2006).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  use R ::= QQ[x,y,z,t];
  D := [x*y, y*z, z*t, t*x];
  IsTree5(D);
[false, [xy, xt, yt]]
-------------------------------
  IsTree5([xy, yz, zt]);
[true, [ ]]
-------------------------------
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{IsTrueGCDDomain}
\label{IsTrueGCDDomain}
\begin{command} % -- COMMAND: IsTrueGCDDomain ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsTrueGCDDomain(R: RING): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether a ring is a (true) GCD domain but not a field.
CoCoA can compute GCDs of elements of a true GCD domain.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsTrueGCDDomain(ZZ);
true
/**/  IsTrueGCDDomain(QQ);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsField(\ref{IsField} pg.\pageref{IsField})
\end{command} % -- end command --------------------------------

\section{IsZero}
\label{IsZero}
\begin{command} % -- COMMAND: IsZero ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsZero(X: OBJECT): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether its argument is zero; the argument can be
of almost any type for which \textbf{zero} makes sense.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsZero(23);
false
/**/  IsZero(3-3);
true
/**/  use R ::= QQ[x,y,z];
/**/  IsZero(x^2+3*y-1);
false
/**/  IsZero(ideal(x^2,x*y^3));
false
/**/  F := NewFreeModule(R, 3);
/**/  zero(F);
[0, 0, 0]
/**/  IsZero(zero(F));
true
/**/  IsZero(matrix([[0,0,0], [0,0,0]]));
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsEven, IsOdd(\ref{IsEven, IsOdd} pg.\pageref{IsEven, IsOdd}), 
    IsOne(\ref{IsOne} pg.\pageref{IsOne}), 
    zero(\ref{zero} pg.\pageref{zero}), 
    ZeroMat(\ref{ZeroMat} pg.\pageref{ZeroMat})
\end{command} % -- end command --------------------------------

\section{IsZeroCol, IsZeroRow}
\label{IsZeroCol, IsZeroRow}
\begin{command} % -- COMMAND: IsZeroCol, IsZeroRow ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsZeroCol(M: MAT, N: INT): BOOL
IsZeroRow(M: MAT, N: INT): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether all entries in the ``\verb&N&''-th column(row)
of ``\verb&M&'' are zero.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  IsZeroRow(matrix([[1,0,0], [0,0,0]]), 1);
false
/**/  IsZeroCol(matrix([[1,0,0], [0,0,0]]), 2);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsZero(\ref{IsZero} pg.\pageref{IsZero}), 
    ZeroMat(\ref{ZeroMat} pg.\pageref{ZeroMat})
\end{command} % -- end command --------------------------------

\section{IsZeroDet}
\label{IsZeroDet}
\begin{command} % -- COMMAND: IsZeroDet ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsZeroDet(M: MAT): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether the determinant of ``\verb&M&'' is zero; it may
sometimes be faster than computing the determinant.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := matrix([[1,2], [3,4]]);
/**/  IsZeroDet(M);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  det(\ref{det} pg.\pageref{det}), 
    rk(\ref{rk} pg.\pageref{rk}), 
    IsZero(\ref{IsZero} pg.\pageref{IsZero})
\end{command} % -- end command --------------------------------

\section{IsZeroDim}
\label{IsZeroDim}
\begin{command} % -- COMMAND: IsZeroDim ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsZeroDim(I: IDEAL): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether its argument is zero-dimensional.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  IsZeroDim(ideal(x));
false
/**/  IsZeroDim(ideal(x^3, y^4-x ,z-3));
true
/**/  IsZeroDim(ideal(x^2, x*y^3));
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  dim(\ref{dim} pg.\pageref{dim})
\end{command} % -- end command --------------------------------

\section{IsZeroDivisor}
\label{IsZeroDivisor}
\begin{command} % -- COMMAND: IsZeroDivisor ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsZeroDivisor(X: RINGELEM): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether its argument is a zero-divisor.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  R := NewQuotientRing(P, ideal(x*y));
/**/  IsZeroDivisor(RingElem(R,x));
true
/**/  colon(ideal(zero(R)), ideal(RingElem(R,x)));
ideal((y))
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  colon(\ref{colon} pg.\pageref{colon})
\end{command} % -- end command --------------------------------

\section{IsZZ}
\label{IsZZ}
\begin{command} % -- COMMAND: IsZZ ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
IsZZ(R: RING): BOOL
\end{Verbatim}


\subsection*{Description}

This function tests whether a ring is the ring of integers.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  R ::= QQ[x,y];
/**/  IsZZ(CoeffRing(R));
false
/**/  IsZZ(BaseRing(CoeffRing(R)));
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ZZ(\ref{ZZ} pg.\pageref{ZZ}), 
    RingZZ(\ref{RingZZ} pg.\pageref{RingZZ}), 
    IsQQ(\ref{IsQQ} pg.\pageref{IsQQ})
\end{command} % -- end command --------------------------------

\section{It}
\label{It}
\begin{command} % -- COMMAND: It ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
It
\end{Verbatim}


\subsection*{Description}

``\verb&It&'' is a top-level \textbf{system variable} containing the last result computed
but not assigned.  It is the CoCoA equivalent to ``\verb&last&'' in GAP.
\par 
When CoCoA evaluates a \textbf{standalone expression}, the result is assigned to
the system variable named ``\verb&It&'' (and then printed as if in a ``println'' (\ref{println} pg.\pageref{println})
command).  You may use ``\verb&It&'' in expressions just like any other variable.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  1+1; -- standalone expression ==> result is saved in "It".
2
/**/  It;
2

/**/  It+1;
3
/**/  It;
3

/**/  X := 17;  -- assignment is not a standalone expression, "It" is unchanged
/**/  It;
3
/**/  X+It;
20
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  print(\ref{print} pg.\pageref{print}), 
    println(\ref{println} pg.\pageref{println}), 
    Evaluation and Assignment(\ref{Evaluation and Assignment} pg.\pageref{Evaluation and Assignment})
\end{command} % -- end command --------------------------------

\chapter{J}  %----=== CHAPTER LETTER ===----
\label{J}

\section{JacobianMat}
\label{JacobianMat}
\begin{command} % -- COMMAND: JacobianMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
JacobianMat(L: LIST of RINGELEM): MAT
JacobianMat(L: LIST of RINGELEM, X: LIST of indets): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the Jacobian matrix of the polynomials in
the non empty list ``\verb&L&'' with respect to all the indeterminates
of the ring of ``\verb&L&'' or, if specified, to the indeterminates in ``\verb&X&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  L := [x-y, x^2-y, x^3-y^2];
/**/  JacobianMat(L);
matrix( /*RingWithID(26, "QQ[x,y]")*/
 [[1, -1],
  [2*x, -1],
  [3*x^2, -2*y]])
/**/  JacobianMat(L,[y]);
matrix( /*RingWithID(26, "QQ[x,y]")*/
 [[-1],
  [-1],
  [-2*y]])
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{JanetBasis}
\label{JanetBasis}
\begin{command} % -- COMMAND: JanetBasis ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
JanetBasis(I: IDEAL): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the Janet basis of the ideal ``\verb&I&''
as a list of polynomials..
\par 
Originally written by Mario Albert.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  L := [x-y,  x^2-z+1,  x^3-y^2];
/**/  JanetBasis(ideal(L));
[x -y,  z^2 -3*z +2,  y*z -y -z +1,  y^2 -z +1]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GBasis(\ref{GBasis} pg.\pageref{GBasis})
\end{command} % -- end command --------------------------------

\chapter{K}  %----=== CHAPTER LETTER ===----
\label{K}

\section{ker}
\label{ker}
\begin{command} % -- COMMAND: ker ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ker(phi: RINGHOM): IDEAL
\end{Verbatim}


\subsection*{Description}

This function returns the kernel of a homomorphism.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  R ::= QQ[x,y,z,w];
/**/  Use S ::= QQ[s,t];
/**/  phi := PolyAlgebraHom(R, S, [s^3, s^2*t, s*t^2, t^3]);
/**/  ker(phi);
ideal(z^2 -y*w,  y*z -x*w,  y^2 -x*z)

/**/  SmodJ := NewQuotientRing(S, "t+s");
/**/  use SmodJ;
/**/  psi := PolyAlgebraHom(R, SmodJ, [s^3, s^2*t, s*t^2, t^3]);
/**/  ker(psi);
ideal(x +w, y -w, z +w)

/**/  RmodI := NewQuotientRing(R, "x+y");
/**/  ker(InducedHom(RmodI, psi));
ideal((z +w),  (y -w))
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  preimage0(\ref{preimage0} pg.\pageref{preimage0}), 
    IsInjective(\ref{IsInjective} pg.\pageref{IsInjective}), 
    IsSurjective(\ref{IsSurjective} pg.\pageref{IsSurjective}), 
    implicit(\ref{implicit} pg.\pageref{implicit})
\end{command} % -- end command --------------------------------

\section{KroneckerProd}
\label{KroneckerProd}
\begin{command} % -- COMMAND: KroneckerProd ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
KroneckerProd(M: MATRIX, N: MATRIX): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the Kronecker (tensor) product of two matrices.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z,w];
/**/  KroneckerProd(mat(R, [[1,-1],[2,-2],[3,-3]]), mat(R, [[x,y],[z,w]]));
matrix( /*RingWithID(42, "QQ[x,y,z,w]")*/
 [[x, y, -x, -y],
  [z, w, -z, -w],
  [2*x, 2*y, -2*x, -2*y],
  [2*z, 2*w, -2*z, -2*w],
  [3*x, 3*y, -3*x, -3*y],
  [3*z, 3*w, -3*z, -3*w]])
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{KroneckerSymbol}
\label{KroneckerSymbol}
\begin{command} % -- COMMAND: KroneckerSymbol ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
KroneckerSymbol(R: INT, M: INT): INT
\end{Verbatim}


\subsection*{Description}

This function returns the kronecker symbol of ``\verb&R&'' modulo ``\verb&M&''.
If ``\verb&M&'' is prime then this value is 0 when ``\verb&R&'' is divisible
by ``\verb&M&'', and otherwise is 1 when ``\verb&R&'' is a square modulo
``\verb&M&'' (\textit{i.e.} a quadratic reside), and -1 when it is not a square.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  KroneckerSymbol(1,3);
1
/**/  KroneckerSymbol(-1,7);
-1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsSquare(\ref{IsSquare} pg.\pageref{IsSquare})
\end{command} % -- end command --------------------------------

\chapter{L}  %----=== CHAPTER LETTER ===----
\label{L}

\section{LaguerrePoly}
\label{LaguerrePoly}
\begin{command} % -- COMMAND: LaguerrePoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LaguerrePoly(N: INT, X: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

The function ``\verb&LaguerrePoly&'' returns the ``\verb&N&''-th Laguerre polynomial
multiplied by ``\verb&factorial(N)&'' (so that the coefficients are integers).
\par 
This function also works if ``\verb&X&'' is not an indeterminate: the result
is then the evaluation of the polynomial at the given value.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  LaguerrePoly(3,x);
-x^3 +9*x^2 -18*x +6
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ChebyshevPoly(\ref{ChebyshevPoly} pg.\pageref{ChebyshevPoly}), 
    HermitePoly(\ref{HermitePoly} pg.\pageref{HermitePoly})
\end{command} % -- end command --------------------------------

\section{last}
\label{last}
\begin{command} % -- COMMAND: last ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
last(L: LIST): OBJECT
last(L: LIST, N: INT): OBJECT
\end{Verbatim}


\subsection*{Description}

In the first form, the function returns the last element of L.  In
the second form, it returns the list of the last N elements of L.
\par 
The CoCoA equivalent to GAP ``\verb&last&'' is the variable ``\verb&It&'' (\ref{It} pg.\pageref{It}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [1,2,3,4,5];
/**/  last(L);
5

/**/  last(L,3);
[3, 4, 5]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  first(\ref{first} pg.\pageref{first}), 
    tail(\ref{tail} pg.\pageref{tail}), 
    It(\ref{It} pg.\pageref{It})
\end{command} % -- end command --------------------------------

\section{latex}
\label{latex}
\begin{command} % -- COMMAND: latex ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
latex(X: OBJECT): STRING
\end{Verbatim}


\subsection*{Description}

This function returns a string containing the argument formatted in LaTeX.
It can also be called with the name ``\verb&LaTeX&''.
\par 
For typesetting ideals this function assumes use of a LaTeX macro like this:
\begin{verbatim}
  \newcommand{\ideal}[1]{\langle #1 \rangle}
\end{verbatim}
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  F := x^10 +2*y^12*z^3;
/**/  latex(F);
2 y^{12} z^3  +x^{10} 

/**/  M := mat([[1,2],[3,4]]);
/**/  latex(M);
\left( \begin{array}{cc}
  1 & 2 \\
  3 & 4 \end{array}\right)

/**/  R ::= QQ[x,y,z];
/**/  latex(ideal(x^2, y+z));
\ideal{x^2 ,
  y +z}

/**/  P := NewFractionField(R);
/**/  use P;
/**/  F := (x+y)/(1-z)^3;
/**/  latex(F);
\frac{ -x -y} {z^3  -3 z^2  +3 z -1}
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  format(\ref{format} pg.\pageref{format}), 
    sprint(\ref{sprint} pg.\pageref{sprint})
\end{command} % -- end command --------------------------------

\section{LawrenceMat}
\label{LawrenceMat}
\begin{command} % -- COMMAND: LawrenceMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LawrenceMat(M: MATRIX): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the Lawrence lifting of the matrix ``\verb&M&'',
defined as follows:
\begin{verbatim}
                | M 0 |
                | I I |
\end{verbatim}
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  LawrenceMat(mat([[1,2,3],[4,5,6]]));
matrix(QQ,
 [[1, 2, 3, 0, 0, 0],
  [4, 5, 6, 0, 0, 0],
  [1, 0, 0, 1, 0, 0],
  [0, 1, 0, 0, 1, 0],
  [0, 0, 1, 0, 0, 1]])
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{LC}
\label{LC}
\begin{command} % -- COMMAND: LC ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LC(F: RINGELEM|MODULEELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the leading coefficient of ``\verb&F&'', as determined by
the term-ordering of the ring to which ``\verb&F&'' belongs.  It is an error if ``\verb&F&''
is zero.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  LC(x +3*x^2 -5*y^2);
3

/**/  F := NewFreeModule(R,3);
/**/  LC(ModuleElem(F, [0, 5*y+6*x^2, y^2]));
6
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ConstantCoeff(\ref{ConstantCoeff} pg.\pageref{ConstantCoeff}), 
    coefficients(\ref{coefficients} pg.\pageref{coefficients}), 
    CoeffOfTerm(\ref{CoeffOfTerm} pg.\pageref{CoeffOfTerm}), 
    LT(\ref{LT} pg.\pageref{LT})
\end{command} % -- end command --------------------------------

\section{lcm}
\label{lcm}
\begin{command} % -- COMMAND: lcm ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
lcm(M: INT, N: INT): INT
lcm(L: LIST of INT): INT

lcm(F: RINGELEM, G: RINGELEM): RINGELEM
lcm(L: LIST of RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the least common multiple of its arguments,
or of the elements in the list ``\verb&L&''.
For the calculation of the GCDs and LCMs of polynomials, the
coefficient ring must be a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  F := x^2-y^2;
/**/  G := (x+y)^3;
/**/  lcm(F, G);
x^4 +2*x^3*y -2*x*y^3 -y^4

/**/  IsDivisible(F*G, It);
true

/**/  lcm(F, G) * gcd(F,G) = F*G;
true

/**/  lcm([3*4,3*8,6*16]);
96
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  div(\ref{div} pg.\pageref{div}), 
    mod(\ref{mod} pg.\pageref{mod}), 
    gcd(\ref{gcd} pg.\pageref{gcd})
\end{command} % -- end command --------------------------------

\section{len}
\label{len}
\begin{command} % -- COMMAND: len ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
len(S: STRING): INT
len(L: LIST): INT
\end{Verbatim}


\subsection*{Description}

This function returns the \textbf{length} of a string or a list.
\par 
NOTE: 
previously ``\verb&len&'' could be applied to other types too; this is no
longer supported: see
``\verb&NumCompts&'' (\ref{NumCompts} pg.\pageref{NumCompts}) for module elements,
``\verb&NumRows&'' (\ref{NumRows} pg.\pageref{NumRows}) for matrices,
``\verb&NumTerms&'' (\ref{NumTerms} pg.\pageref{NumTerms}) for polynomials.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  len( [2,3,4] );
3

/**/  len( "string" );
6
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  count(\ref{count} pg.\pageref{count}), 
    NumCompts(\ref{NumCompts} pg.\pageref{NumCompts}), 
    NumRows(\ref{NumRows} pg.\pageref{NumRows}), 
    NumTerms(\ref{NumTerms} pg.\pageref{NumTerms})
\end{command} % -- end command --------------------------------

\section{LexMat}
\label{LexMat}
\begin{command} % -- COMMAND: LexMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LexMat(N: INT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the matrix defining the standard term-ordering "lex".
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  LexMat(3);
matrix(ZZ,
 [[1, 0, 0],
  [0, 1, 0],
  [0, 0, 1]
])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Term Orderings(\ref{Term Orderings} pg.\pageref{Term Orderings}), 
    StdDegLexMat(\ref{StdDegLexMat} pg.\pageref{StdDegLexMat}), 
    StdDegRevLexMat(\ref{StdDegRevLexMat} pg.\pageref{StdDegRevLexMat}), 
    RevLexMat(\ref{RevLexMat} pg.\pageref{RevLexMat}), 
    XelMat(\ref{XelMat} pg.\pageref{XelMat})
\end{command} % -- end command --------------------------------

\section{LexSegmentIdeal}
\label{LexSegmentIdeal}
\begin{command} % -- COMMAND: LexSegmentIdeal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LexSegmentIdeal(L: LIST of power-products): IDEAL
LexSegmentIdeal(I: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

If the argument is a LIST of power-products ``\verb&L&'', this function returns the
smallest lex-segment ideal containing the power-products in ``\verb&L&''.
\par 
If it is an IDEAL ``\verb&I&'', it returns the lex-segment ideal having the same
Hilbert function as ``\verb&I&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  LexSegmentIdeal([y^3]);
ideal(y^3, x*z^2, x*y*z, x*y^2, x^2*z, x^2*y, x^3)
/**/  LexSegmentIdeal(ideal(y^3));
ideal(x^3)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsLexSegment(\ref{IsLexSegment} pg.\pageref{IsLexSegment}), 
    StableIdeal(\ref{StableIdeal} pg.\pageref{StableIdeal}), 
    StronglyStableIdeal(\ref{StronglyStableIdeal} pg.\pageref{StronglyStableIdeal})
\end{command} % -- end command --------------------------------

\section{LF}
\label{LF}
\begin{command} % -- COMMAND: LF ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LF(I: IDEAL): IDEAL
LF(F: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

For a polynomial ``\verb&F&'' this function returns the leading form, \textit{i.e.} the
sum of all summands having highest degree.  It throws an error if the
argument is zero or if the ``\verb&GradingDim&'' (\ref{GradingDim} pg.\pageref{GradingDim}) of the polynomial
ring is 0 (use ``\verb&DF&'' (\ref{DF} pg.\pageref{DF}) to allow these cases).
\par 
For an ideal ``\verb&I&'' this function returns the ideal of all the ``\verb&LF(f)&''
for ``\verb&f in I&''.  It throws an error if the ``\verb&GradingDim&'' (\ref{GradingDim} pg.\pageref{GradingDim}) of the polynomial
ring is 0.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  LF(x^2 -x*y +2*x -1);
x^2 -x*y

/**/  use R ::= QQ[x,y], Lex;  -- GradingDim is 0: everything is homogeneous
-- /**/  LF(x-1); --> !!! ERROR !!! as expected: instead of x-1

/**/  P := NewPolyRing(QQ, IndetSymbols(R), mat([[1,4],[1,0]]), 1);
/**/  Use P;
/**/  LF(x^2 - x*y);
-x*y
/**/  LF(x^4 + x^2 - y);
 x^4 -y
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  DF(\ref{DF} pg.\pageref{DF}), 
    IsHomog(\ref{IsHomog} pg.\pageref{IsHomog}), 
    LC(\ref{LC} pg.\pageref{LC}), 
    LM(\ref{LM} pg.\pageref{LM}), 
    LPP(\ref{LPP} pg.\pageref{LPP}), 
    LT(\ref{LT} pg.\pageref{LT})
\end{command} % -- end command --------------------------------

\section{LinearSimplify}
\label{LinearSimplify}
\begin{command} % -- COMMAND: LinearSimplify ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LinearSimplify(F: RINGELEM): RECORD
\end{Verbatim}


\subsection*{Description}

This function returns a ``\verb&RECORD[LinearChange, SimplePoly]&''
where ``\verb&LinearChange&'' is a linear change of variable
and ``\verb&SimplePoly&'' is simple (in a heuristic sense).
The composition ``\verb&SimplePoly(LinearChange)&'' is equal the
univariate polynomial ``\verb&F&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x];
/**/  LinearSimplify((123*x-456)^9-1);
record[LinearChange := 123*x - 456, SimplePoly := x^9 - 1]

/**/  LinearSimplify(x^9-1); -- the heuristic finds no useful simplification
record[LinearChange := x, SimplePoly := x^9 - 1]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{LinKer}
\label{LinKer}
\begin{command} % -- COMMAND: LinKer ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LinKer(M: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns a matrix whose columns represent a basis for
the kernel of ``\verb&M&''.  Calling the function twice on the same input will
not necessarily produce the same output, though in each case, a basis
for the kernel is produced.
\par 
This function works only on matrices whose entries are in a field
(from version CoCoA-5.0.3).  See ``\verb&LinKerZZ&'' (\ref{LinKerZZ} pg.\pageref{LinKerZZ}) for computing a
ZZ-basis for the kernel of ``\verb&M&''.
\par 
The output as it was given by CoCoA-4 (the basis of the ker) is
now given by ``\verb&LinKerBasis&'' (\ref{LinKerBasis} pg.\pageref{LinKerBasis}).  See also ``\verb&HilbertBasisKer&'' (\ref{HilbertBasisKer} pg.\pageref{HilbertBasisKer}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/   M := mat([[1,2,3,4],[5,6,7,8],[9,10,11,12]]);
/**/   LinKer(M);
matrix(QQ,
 [[-1, -2],
  [2, 3],
  [-1, 0],
  [0, -1]])

/**/ M*It;
matrix(QQ,
 [[0, 0],
  [0, 0],
  [0, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LinKerBasis(\ref{LinKerBasis} pg.\pageref{LinKerBasis}), 
    LinKerZZ(\ref{LinKerZZ} pg.\pageref{LinKerZZ}), 
    LinSolve(\ref{LinSolve} pg.\pageref{LinSolve}), 
    HilbertBasisKer(\ref{HilbertBasisKer} pg.\pageref{HilbertBasisKer})
\end{command} % -- end command --------------------------------

\section{LinKerBasis}
\label{LinKerBasis}
\begin{command} % -- COMMAND: LinKerBasis ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LinKerBasis(M: MAT): LIST of RINGELEM
LinKerBasis(L: LIST): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns a list whose components are lists representing
a basis for the kernel of the matrix ``\verb&M&'' or for the solutions of the
linear system given by linear polynomials ``\verb&L&''.  
\par 
NOTE: calling the function twice on the same input will not necessarily
produce the same output, though in each case, a basis for the kernel
is produced.
\par 
NOTE: this function works only on matrices whose entries are in a field
(from version CoCoA-5.0.3).  See ``\verb&LinKerZZ&'' (\ref{LinKerZZ} pg.\pageref{LinKerZZ}) for computing a
ZZ-basis for the kernel of ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  L := [x+y+z,  y-z];
/**/  LinKerBasis(L);
[[-2,  1,  1]]

/**/  M := mat([[1,2,3,4],[5,6,7,8],[9,10,11,12]]);
/**/  LinKerBasis(M);
[[-1, 2, -1, 0], [-2, 3, 0, -1]]

/**/  K := NewFractionField(NewPolyRing(QQ, "a,b"));
/**/  use K;
/**/  M := mat([[1,2,3,a],[5,6,7,a*b]]);
/**/  LinKerBasis(M);
[[-1, 2, -1, 0], [(a*b -3*a)/2, (-a*b +5*a)/4, 0, -1]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LinKer(\ref{LinKer} pg.\pageref{LinKer}), 
    LinKerZZ(\ref{LinKerZZ} pg.\pageref{LinKerZZ}), 
    LinSolve(\ref{LinSolve} pg.\pageref{LinSolve})
\end{command} % -- end command --------------------------------

\section{LinKerModP [OBSOLETE]}
\label{LinKerModP [OBSOLETE]}
\begin{command} % -- COMMAND: LinKerModP [OBSOLETE] ------------



\subsection*{Description}

In CoCoA-4 it was difficult to map a matrix into ``\verb&ZZ/(p)&''.
Now, in CoCoA-5, we can map the matrix and then call directly
``\verb&LinKer&'' (\ref{LinKer} pg.\pageref{LinKer}) and ``\verb&LinKerBasis&'' (\ref{LinKerBasis} pg.\pageref{LinKerBasis}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use ZZ/(7);
/**/  M := mat([[1,2,3,4],[5,6,7,8],[9,10,11,12]]); --> by default over QQ
/**/  LinKerBasis(M);
[[-1, 2, -1, 0], [-2, 3, 0, -1]]

/**/  LinKerBasis(matrix(NewZZmod(3), M)); --> map M into ZZ/(3)
[[-1, -1, -1, 0], [1, 0, 0, -1]]

/**/  LinKer(matrix(CurrentRing, M)); --> map M into CurrentRing ZZ/(7)
matrix( /*RingWithID(9, "FFp(7)")*/
 [[-1, -2],
  [2, 3],
  [-1, 0],
  [0, -1]])
/**/  matrix(CurrentRing, M) * It;
matrix( /*RingWithID(9,"FFp(7)")*/
 [[0, 0],
  [0, 0],
  [0, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LinKer(\ref{LinKer} pg.\pageref{LinKer}), 
    LinKerBasis(\ref{LinKerBasis} pg.\pageref{LinKerBasis}), 
    LinSolve(\ref{LinSolve} pg.\pageref{LinSolve})
\end{command} % -- end command --------------------------------

\section{LinKerZZ}
\label{LinKerZZ}
\begin{command} % -- COMMAND: LinKerZZ ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LinKerZZ(M: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function expects a matrix ``\verb&M&'' with integer or rational entries,
and returns a matrix of integers whose columns represent a ``\verb&ZZ&''-module
basis for the integer vectors in the kernel of ``\verb&M&''.  Calling the function
twice on the same input will not necessarily produce the same output,
though in each case, a basis for the kernel is produced.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ LinKerZZ(RowMat([1,1/2,1/3]));
matrix(ZZ,
 [[1, 0],
  [0, 2],
  [-3, -3]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LinKer(\ref{LinKer} pg.\pageref{LinKer}), 
    LinKerBasis(\ref{LinKerBasis} pg.\pageref{LinKerBasis}), 
    LinSolve(\ref{LinSolve} pg.\pageref{LinSolve})
\end{command} % -- end command --------------------------------

\section{LinSol [OBSOLETE]}
\label{LinSol [OBSOLETE]}
\begin{command} % -- COMMAND: LinSol [OBSOLETE] ------------



\subsection*{Description}

Renamed ``\verb&LinSolve&'' (\ref{LinSolve} pg.\pageref{LinSolve}).

\end{command} % -- end command --------------------------------

\section{LinSolve}
\label{LinSolve}
\begin{command} % -- COMMAND: LinSolve ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LinSolve(M: MAT, RHS: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function finds a solution ``\verb&X&'' to the matrix equation ``\verb&M*X = RHS&''.
If more than one solution exists, it returns just one of them.
If no solution exists then it produces a 0-by-0 matrix.
To find all solutions, compute the kernel of ``\verb&M&'' using the function ``\verb&LinKerBasis&'' (\ref{LinKerBasis} pg.\pageref{LinKerBasis}).
\par 
NOTE: an easy way of converting a list into a column matrix (for the second
argument) is to use the function ``\verb&ColMat&'' (\ref{ColMat} pg.\pageref{ColMat}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[3,1,4],[1,5,9],[2,6,5]]);
/**/  L := [123,456,789];
/**/  LinSolve(M, ColMat(L));
mat([
  [199/5],
  [742/5],
  [-181/5]
])

/**/  M*It;
mat([
  [123],
  [456],
  [789]
])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ColMat(\ref{ColMat} pg.\pageref{ColMat}), 
    LinKer(\ref{LinKer} pg.\pageref{LinKer}), 
    LinKerBasis(\ref{LinKerBasis} pg.\pageref{LinKerBasis})
\end{command} % -- end command --------------------------------

\section{LM}
\label{LM}
\begin{command} % -- COMMAND: LM ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LM(X: RINGELEM): RINGELEM
LM(X: MODULEELEM): MODULEELEM
\end{Verbatim}


\subsection*{Description}

This function returns the leading monomial of ``\verb&X&''.  The monomial
includes the coefficient.  To get the leading term of ``\verb&P&'', (which does
not included the coefficient), use ``\verb&LT&'' (\ref{LT} pg.\pageref{LT}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  LM(3*x^2*y + y);
3*x^2*y
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LC(\ref{LC} pg.\pageref{LC}), 
    LF(\ref{LF} pg.\pageref{LF}), 
    LPP(\ref{LPP} pg.\pageref{LPP}), 
    LT(\ref{LT} pg.\pageref{LT})
\end{command} % -- end command --------------------------------

\section{log [OBSOLESCENT]}
\label{log [OBSOLESCENT]}
\begin{command} % -- COMMAND: log [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&exponents&'' (\ref{exponents} pg.\pageref{exponents}).

\end{command} % -- end command --------------------------------

\section{LogCardinality}
\label{LogCardinality}
\begin{command} % -- COMMAND: LogCardinality ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LogCardinality(Fp: RING): INT
\end{Verbatim}


\subsection*{Description}

This function returns the extension degree of a finite field over its
prime field, or equivalently the log (base p) of its cardinality.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Fp ::= ZZ/(7);
/**/  use Fpx ::= Fp[x];
/**/  Fq := Fpx/ideal(x^2+1);
/**/  LogCardinality(Fq);
2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsFiniteField(\ref{IsFiniteField} pg.\pageref{IsFiniteField}), 
    characteristic(\ref{characteristic} pg.\pageref{characteristic})
\end{command} % -- end command --------------------------------

\section{LPosn}
\label{LPosn}
\begin{command} % -- COMMAND: LPosn ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LPosn(V: MODULEELEM): INT
\end{Verbatim}


\subsection*{Description}

This function returns the position of the leading power-product of ``\verb&V&''.
\par 
This function used to be called ``\verb&LPos&'' up to version 5.0.3.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];  -- the default term-ordering is DegRevLex
/**/  R4 := NewFreeModule(R,4); -- the default module ordering is TOPos
/**/  LPosn(ModuleElem(R4, [0, x, y^2, x^2]));
4
/**/  LPP(ModuleElem(R4, [0, x, y^2, x^2]));
x^2
/**/  LT(ModuleElem(R4, [0, x, y^2, x^2]));
[0, 0, 0, x^2]


  use R ::= QQ[x,y], PosTo;
  LT(Vector(x,y^2));
Vector(x, 0)
-------------------------------
  LPP(Vector(x,y^2));
x
-------------------------------
  LPosn(Vector(x,y^2));
1
-------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LF(\ref{LF} pg.\pageref{LF}), 
    LM(\ref{LM} pg.\pageref{LM}), 
    LPP(\ref{LPP} pg.\pageref{LPP}), 
    LT(\ref{LT} pg.\pageref{LT})
\end{command} % -- end command --------------------------------

\section{LPP}
\label{LPP}
\begin{command} % -- COMMAND: LPP ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LPP(X: RINGELEM): RINGELEM
LPP(X: MODULEELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the leading power-product of ``\verb&X&''; it discards
information about which component the power-product appears in.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  LPP(3*x^2*y+y);  -- LPP is the same as LT for polynomials
x^2*y

-- Note the difference between LPP and LT for MODULEELEM.
/**/  R4 := NewFreeModule(R,4); -- the default module ordering is TOPos
/**/  LPP(ModuleElem(R4, [0, x, y^2, x^2]));
x^2
/**/  LT(ModuleElem(R4, [0, x, y^2, x^2]));
[0, 0, 0, x^2]
/**/  LPosn(ModuleElem(R4, [0, x, y^2, x^2]));
4
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LC(\ref{LC} pg.\pageref{LC}), 
    LF(\ref{LF} pg.\pageref{LF}), 
    LM(\ref{LM} pg.\pageref{LM}), 
    LPosn(\ref{LPosn} pg.\pageref{LPosn}), 
    LT(\ref{LT} pg.\pageref{LT})
\end{command} % -- end command --------------------------------

\section{LT}
\label{LT}
\begin{command} % -- COMMAND: LT ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
LT(I: RINGELEM):   RINGELEM
LT(I: IDEAL):      IDEAL
LT(I: MODULEELEM): MODULEELEM
LT(I: MODULE):     MODULE
\end{Verbatim}


\subsection*{Description}

If ``\verb&E&'' is a polynomial this function returns the leading term of the
polynomial ``\verb&E&'' with respect to the term-ordering of the polynomial ring
of ``\verb&E&''.
\par 
For the leading monomial, which includes the coefficient, use ``\verb&LM&'' (\ref{LM} pg.\pageref{LM}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];  -- the default term-ordering is DegRevLex
/**/  LT(y^2-x*z);
y^2

/**/  use R ::= QQ[x,y,z], Lex;
/**/  LT(y^2-x*z);
x*z
\end{Verbatim}

If ``\verb&E&'' is a MODULEELEM, ``\verb&LT(E)&'' gives the leading term
of ``\verb&E&'' with respect to the module term-ordering of ``\verb&E&''.
For the leading monomial, which includes the coefficient, use ``\verb&LM&'' (\ref{LM} pg.\pageref{LM}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  R3 := NewFreeModule(R,3);
/**/  LT(ModuleElem(R3, [0, x, y^2]));
[0, 0, y^2]
\end{Verbatim}

If ``\verb&E&'' is an ideal or module, ``\verb&LT(E)&'' returns the ideal or module
generated by the leading terms of all elements of E, sometimes called
the \textbf{initial} ideal or module.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x-y, x-z^2);
/**/  LT(I);
ideal(x, z^2)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LC(\ref{LC} pg.\pageref{LC}), 
    LF(\ref{LF} pg.\pageref{LF}), 
    LM(\ref{LM} pg.\pageref{LM}), 
    LPP(\ref{LPP} pg.\pageref{LPP}), 
    Module Orderings(\ref{Module Orderings} pg.\pageref{Module Orderings}), 
    Term Orderings(\ref{Term Orderings} pg.\pageref{Term Orderings})
\end{command} % -- end command --------------------------------

\chapter{M}  %----=== CHAPTER LETTER ===----
\label{M}

\section{MakeCheck}
\label{MakeCheck}
\begin{command} % -- COMMAND: MakeCheck ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MakeCheck()
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function run a series of tests on the whole system.  To get a
reliable result you should run this on a \textbf{just opened} CoCoA
because some printouts may mysteriously add some empty spaces which
will result in an, apparent, failure of some tests.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  MakeCheck();
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{MakeMatByRows, MakeMatByCols}
\label{MakeMatByRows, MakeMatByCols}
\begin{command} % -- COMMAND: MakeMatByRows, MakeMatByCols ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MakeMatByRows(R: INT, C: INT, L: LIST): MAT
MakeMatByCols(R: INT, C: INT, L: LIST): MAT
\end{Verbatim}


\subsection*{Description}

 These functions create an ``\verb&RxC&'' matrix from the list ``\verb&L&''.
 The first argument ``\verb&R&'' is the number of rows,
 and the second ``\verb&C&'' is the number of columns.
 It is an error if the length of ``\verb&L&'' is not ``\verb&RxC&''.
\par 
 The ring of the matrix is determined from the ring containing the
 elements of ``\verb&L&''.  If ``\verb&L&'' contains only integers/rationals
 then the matrix is over ``\verb&QQ&''. 
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  MakeMatByRows(2, 10, 1..20);
matrix(QQ,
 [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
  [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]])

/**/  MakeMatByCols(2, 10, 1..20);
matrix(QQ,
 [[1, 3, 5, 7, 9, 11, 13, 15, 17, 19],
  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BlockMat(\ref{BlockMat} pg.\pageref{BlockMat}), 
    matrix(\ref{matrix} pg.\pageref{matrix}), 
    NewMat(\ref{NewMat} pg.\pageref{NewMat}), 
    ColMat(\ref{ColMat} pg.\pageref{ColMat}), 
    RowMat(\ref{RowMat} pg.\pageref{RowMat}), 
    DiagMat(\ref{DiagMat} pg.\pageref{DiagMat}), 
    ConcatHor(\ref{ConcatHor} pg.\pageref{ConcatHor}), 
    ConcatVer(\ref{ConcatVer} pg.\pageref{ConcatVer})
\end{command} % -- end command --------------------------------

\section{MakeSet}
\label{MakeSet}
\begin{command} % -- COMMAND: MakeSet ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MakeSet(L: LIST): LIST
\end{Verbatim}


\subsection*{Description}

This function returns a list obtained by removing duplicates from ``\verb&L&''.
\par 
NOTE: to test two sets for equality use the function ``\verb&EqSet&'' (\ref{EqSet} pg.\pageref{EqSet})
instead of a normal equality test (because the latter yields false if
the elements are in a different order).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  MakeSet([2,2,2,1,2,1,1,3,3]);
[2, 1, 3]
/**/  MakeSet([2,2,2,1,2,1,1,3,3]) = [1,2,3];
false
/**/  EqSet([2,2,2,1,2,1,1,3,3],  [1,2,3]);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  EqSet(\ref{EqSet} pg.\pageref{EqSet}), 
    intersection(\ref{intersection} pg.\pageref{intersection}), 
    IntersectionList(\ref{IntersectionList} pg.\pageref{IntersectionList}), 
    remove(\ref{remove} pg.\pageref{remove})
\end{command} % -- end command --------------------------------

\section{MakeTerm}
\label{MakeTerm}
\begin{command} % -- COMMAND: MakeTerm ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MakeTerm(R: RING, L: LIST of INT): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the power-product in ``\verb&R&'' whose list of exponents is
``\verb&L&''.  It is the inverse of ``\verb&exponents&'' (\ref{exponents} pg.\pageref{exponents}).  The length of ``\verb&L&'' must be equal
to the number of indeterminates in ``\verb&R&''.
\par 
This function was called ``\verb&LogToTerm&'' up to version CoCoA-5.1.2.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  MakeTerm(R, [2,3,5]);
x^2*y^3*z^5

/**/  exponents(It);
[2, 3, 5]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  exponents(\ref{exponents} pg.\pageref{exponents})
\end{command} % -- end command --------------------------------

\section{MakeTermOrd [OBSOLESCENT]}
\label{MakeTermOrd [OBSOLESCENT]}
\begin{command} % -- COMMAND: MakeTermOrd [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&MakeTermOrdMat&'' (\ref{MakeTermOrdMat} pg.\pageref{MakeTermOrdMat}) from version 5.3.4.

\end{command} % -- end command --------------------------------

\section{MakeTermOrdMat}
\label{MakeTermOrdMat}
\begin{command} % -- COMMAND: MakeTermOrdMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MakeTermOrdMat(DegVec: MAT): MAT
MakeTermOrdMat(DegVec: MAT, GrDim: INT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns a (square) matrix of integers defining a term
ordering; the output matrix is built from ``\verb&DegVec&''.  The first ``\verb&GrDim&''
rows are left unchanged; if ``\verb&GrDim&'' is not given then it is taken to be 0.
\par 
The input matrix ``\verb&DegVec&'' must have rational entries; the first ``\verb&GrDim&''
rows must have non-negative integer entries, and they must be linearly
independent.
\par 
If ``\verb&DegVec&'' is not square then rows are appended or eliminated as necessary.
\par 
NOTE: this function was called ``\verb&CompleteToOrd&'' up to version CoCoA-5.1.2.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  DegVec := matrix([[1,2,3,4]]);
/**/  MakeTermOrdMat(DegVec);
 [[1, 2, 3, 4],
  [0, 0, 0, -1],
  [0, 0, -1, 0],
  [0, -1, 0, 0]])

/**/  MakeTermOrdMat(RowMat([1,2,0,0]));
 [[1, 2, 0, 0],
  [0, 0, 1, 1],
  [0, 0, 0, -1],
  [0, -1, 0, 0]])

/**/  MakeTermOrdMat(matrix([[1,2,0,0],[0,0,3,4]]),2);
matrix(ZZ,
 [[1, 2, 0, 0],
  [0, 0, 3, 4],
  [0, 0, 0, -1],
  [0, -1, 0, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LexMat(\ref{LexMat} pg.\pageref{LexMat}), 
    RevLexMat(\ref{RevLexMat} pg.\pageref{RevLexMat}), 
    StdDegLexMat(\ref{StdDegLexMat} pg.\pageref{StdDegLexMat}), 
    StdDegRevLexMat(\ref{StdDegRevLexMat} pg.\pageref{StdDegRevLexMat}), 
    NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing})
\end{command} % -- end command --------------------------------

\section{MantissaAndExponent10}
\label{MantissaAndExponent10}
\begin{command} % -- COMMAND: MantissaAndExponent10 ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MantissaAndExponent10(X: INT|RAT, Prec: INT): RECORD
\end{Verbatim}


\subsection*{Description}

This function converts a rational number into a ``\verb&RECORD&'' with components
named ``\verb&exponent&'', ``\verb&mantissa&'' and ``\verb&NumDigits&''.
\par 
If ``\verb&X=0&'', all fields of the record are set to zero.
\par 
For non-zero ``\verb&X&'' the fields give the best representation of the form $M*10^E$
where ``\verb&M&'' has ``\verb&Prec&'' decimal digits.
The value of ``\verb&NumDigits&'' is simply ``\verb&Prec&''.
The value of ``\verb&exponent&'' is ``\verb&FloorLog10(X)&'', plus 1 if the mantissa "overflows".
The value of ``\verb&mantissa&'' is an integer ``\verb&M&'' satisfying $10^(Prec-1) \le  |M| < 10^Prec-1$
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  MantissaAndExponent10(1/2,3);       --  1/2 = 5.00*10^(-1)
record[NumDigits := 3, exponent := -1, mantissa := 500]

/**/  MantissaAndExponent10(0.99999, 4);   --  0.99999 rounds up to give 1.000
record[NumDigits := 4, exponent := 0, mantissa := 1000]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  AsINT(\ref{AsINT} pg.\pageref{AsINT}), 
    AsRAT(\ref{AsRAT} pg.\pageref{AsRAT}), 
    DecimalStr(\ref{DecimalStr} pg.\pageref{DecimalStr}), 
    FloatApprox(\ref{FloatApprox} pg.\pageref{FloatApprox}), 
    FloatStr(\ref{FloatStr} pg.\pageref{FloatStr}), 
    FloorLog2, FloorLog10, FloorLogBase(\ref{FloorLog2, FloorLog10, FloorLogBase} pg.\pageref{FloorLog2, FloorLog10, FloorLogBase}), 
    MantissaAndExponent2(\ref{MantissaAndExponent2} pg.\pageref{MantissaAndExponent2}), 
    ScientificStr(\ref{ScientificStr} pg.\pageref{ScientificStr})
\end{command} % -- end command --------------------------------

\section{MantissaAndExponent2}
\label{MantissaAndExponent2}
\begin{command} % -- COMMAND: MantissaAndExponent2 ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MantissaAndExponent2(X: INT|RAT, Prec: INT): RECORD
MantissaAndExponent2(X: RINGELEM): RECORD
\end{Verbatim}


\subsection*{Description}

The first form of this function converts an integer or rational number into a ``\verb&RECORD&'' with components
named ``\verb&exponent&'', ``\verb&mantissa&'' and ``\verb&NumDigits&''.
\par 
If ``\verb&X=0&'', all fields of the record are set to zero.
\par 
For non-zero ``\verb&X&'' the fields give the best representation of the form $M*2^E$
where ``\verb&M&'' has ``\verb&Prec&'' bits.
The value of ``\verb&NumDigits&'' is simply ``\verb&Prec&''.
The value of ``\verb&exponent&'' is ``\verb&FloorLog2(X,2)&'', plus 1 if the mantissa "overflows".
The value of ``\verb&mantissa&'' is an integer ``\verb&M&'' satisfying $2^(Prec-1) \le  |M| < 2^Prec-1$
\par 
The second form of this function applies to elements of a "twin-float"
ring.  In this case the "precision" is determined directly from the
twin-float value; since twin-float arithmetic is based on a randomized
heuristic, repeating a computation may give a slightly different result
(and this can be seen in the output of ``\verb&MantissaAndExponent2&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  MantissaAndExponent2(1/2,8);       --  1/2 = 128*2^(-8)
record[NumDigits := 8, exponent := -1, mantissa := 128]

/**/  MantissaAndExponent2(65535, 10);   --  rounds up
record[NumDigits := 10, exponent := 16, mantissa := 512]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  AsINT(\ref{AsINT} pg.\pageref{AsINT}), 
    AsRAT(\ref{AsRAT} pg.\pageref{AsRAT}), 
    FloatApprox(\ref{FloatApprox} pg.\pageref{FloatApprox}), 
    FloorLog2, FloorLog10, FloorLogBase(\ref{FloorLog2, FloorLog10, FloorLogBase} pg.\pageref{FloorLog2, FloorLog10, FloorLogBase}), 
    MantissaAndExponent10(\ref{MantissaAndExponent10} pg.\pageref{MantissaAndExponent10}), 
    NewRingTwinFloat(\ref{NewRingTwinFloat} pg.\pageref{NewRingTwinFloat})
\end{command} % -- end command --------------------------------

\section{Manual}
\label{Manual}
\begin{command} % -- COMMAND: Manual ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
? key
?? key
\end{Verbatim}


\subsection*{Description}

These operators are used to search the online help system for
information matching a keyword (introduced in CoCoA 4.2).
\par 
The commands have the form ``\verb&?key&'' and ``\verb&??key&'' where ``\verb&key&'' is a
literal string without quotes.
The search for the ``\verb&key&'' is case insensitive and ignores blank space
before or after ``\verb&key&''.  Also, the semicolon usually required at the end
of a line of CoCoA input is optional.
\par 
The search system is fairly simple.  The searching algorithm looks through
the title and keywords of each manual page.  A page matches if ``\verb&key&''
appears as a (case-insensitive) substring of the title/keywords.
\par 
The ``\verb&??&'' form prints the list of all matches.
The ``\verb&?&'' form prints the page matching exactly if there is one,
otherwise it prints the list of all matches.
\par 
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ ?approxs
--============[ ApproxSolve ]=============--
--> ApproxSolve(L: LIST of RINGELEM): LIST of LIST of RAT

This function returns the list of real solutions (points) of a
... ... ...

/**/ ?approx
--====<  No exact match for "approx"  >====--
All 9 matches for "approx":
 ? ApproxPointsNBM
 ? ApproxSolve
 ... ... ...

\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{MapDown [OBSOLETE]}
\label{MapDown [OBSOLETE]}
\begin{command} % -- COMMAND: MapDown [OBSOLETE] ------------



\subsection*{Description}

See ``\verb&AsINT&'' (\ref{AsINT} pg.\pageref{AsINT}), ``\verb&AsRAT&'' (\ref{AsRAT} pg.\pageref{AsRAT}).

\end{command} % -- end command --------------------------------

\section{matrix}
\label{matrix}
\begin{command} % -- COMMAND: matrix ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
matrix(LofL: LIST): MAT
matrix(R: RING, LofL: LIST): MAT
matrix(R: RING, M: MAT): MAT
\end{Verbatim}


\subsection*{Description}

These functions construct a matrix.
The 2nd and 3rd forms produce a matrix over the specified ring ``\verb&R&''
(or error if the entries in ``\verb&LofL&'' or ``\verb&M&'' cannot be mapped into ``\verb&R&'').
\par 
In the first form, where the ring is not specified, CoCoA "guesses" the
ring: if all elements of ``\verb&LofL&'' are \textsf{INT} or \textsf{RAT} the resulting matrix is in ``\verb&QQ&''
(otherwise it picks the biggest ring from the given elements and uses that).
\par 
The third form is equivalent to ``\verb&CanonicalHom(RingOf(M),R)(M)&''
(See ``\verb&CanonicalHom&'' (\ref{CanonicalHom} pg.\pageref{CanonicalHom})).
\par 
``\verb&LofL&'' must be a \textbf{rectangular} \textsf{LIST} of \textsf{LIST} of \textsf{RINGELEM}s or \textsf{INT}s or \textsf{RAT}s.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [[1,2],[3,4]];
/**/  mat(L);
matrix(QQ,
 [[1, 2],
  [3, 4]])
/**/  mat(ZZ,L);
matrix(ZZ,
 [[1, 2],
  [3, 4]])

/**/  P ::= QQ[x,y];
/**/  M := mat(P,L); print M;
matrix( /*RingWithID(3, "QQ[x,y]")*/
 [[1, 2],
  [3, 4]])
/**/  RingOf(M);
RingWithID(3, "QQ[x,y]")

/**/ M := IdentityMat(ZZ,2);
/**/ matrix(QQ, M);
matrix(QQ,
 [[1, 0],
  [0, 1]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewMat(\ref{NewMat} pg.\pageref{NewMat}), 
    ColMat(\ref{ColMat} pg.\pageref{ColMat}), 
    RowMat(\ref{RowMat} pg.\pageref{RowMat}), 
    DiagMat(\ref{DiagMat} pg.\pageref{DiagMat}), 
    MakeMatByRows, MakeMatByCols(\ref{MakeMatByRows, MakeMatByCols} pg.\pageref{MakeMatByRows, MakeMatByCols}), 
    ConcatHor(\ref{ConcatHor} pg.\pageref{ConcatHor}), 
    ConcatVer(\ref{ConcatVer} pg.\pageref{ConcatVer}), 
    BlockMat(\ref{BlockMat} pg.\pageref{BlockMat}), 
    Commands and Functions for MAT(\ref{Commands and Functions for MAT} pg.\pageref{Commands and Functions for MAT})
\end{command} % -- end command --------------------------------

\section{max}
\label{max}
\begin{command} % -- COMMAND: max ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
max(E_1: OBJECT,...,E_n: OBJECT): OBJECT
max(L: LIST): OBJECT
\end{Verbatim}


\subsection*{Description}

In the first form, this function returns a maximum of $E_1,...,E_n$.
In the second form, it returns a maximum of the objects in the list ``\verb&L&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  max([1,2,3]);
3
/**/  max(1,2,3);
3

/**/  use R ::= QQ[x,y,z];
/**/  max(x^3*z, x^2*y^2); -- x^2y^2 > x^3z in the default ordering, DegRevLex
x^2*y^2
/**/  min(x^3*z, x^2*y^2);
x^3*z

/**/  use R ::= QQ[x,y,z], DegLex;
/**/  max(x^3*z, x^2*y^2); -- x^3z < x^2y^2 in DegLex
x^3*z
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  min(\ref{min} pg.\pageref{min}), 
    max(\ref{max} pg.\pageref{max}), 
    MaxBy(\ref{MaxBy} pg.\pageref{MaxBy}), 
    Relational Operators(\ref{Relational Operators} pg.\pageref{Relational Operators})
\end{command} % -- end command --------------------------------

\section{MaxBy}
\label{MaxBy}
\begin{command} % -- COMMAND: MaxBy ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MaxBy(L: LIST, LessThanFunc: FUNCTION)
\end{Verbatim}


\subsection*{Description}

This function returns a maximum of the elements of the list ``\verb&L&''
with respect to the comparisons made by ``\verb&LessThanFunc&''.
\par 
The comparison function ``\verb&LessThanFunc&'' takes two arguments and returns ``\verb&true&''
if the first argument is less than the second, otherwise it returns ``\verb&false&''.
\par 
NOTE: to call ``\verb&MaxBy(L,LessThanFunc)&'' inside a function you will need
to make the name ``\verb&LessThanFunc&'' accessible using ``\verb&TopLevel LessThanFunc;&''
\par 
NOTE: if both ``\verb&LessThanFunc(A, B)&'' and ``\verb&LessThanFunc(B, A)&'' return
``\verb&true&'', then ``\verb&A&'' and ``\verb&B&'' are viewed as being equal:
for example, when comparing two polynomials by their ``\verb&LPP&'' only.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Define ByLength(S, T)    -- define the sorting function
/**/    Return len(S) < len(T);
/**/  EndDefine;

/**/  L := ["bird", "mouse", "cat", "elephant"];
/**/  MaxBy(L, ByLength);
elephant

/**/  use QQ[x,y];
/**/  Define ByLPP(S, T)  return LPP(S) < LPP(T);  EndDefine;
/**/  L := [x^2*y -y -3, x^5 -1, x^5 -y^2 +3];
/**/  MaxBy(L, ByLPP);
x^5 -1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  MinBy(\ref{MinBy} pg.\pageref{MinBy}), 
    func(\ref{func} pg.\pageref{func}), 
    SortBy(\ref{SortBy} pg.\pageref{SortBy}), 
    SortedBy(\ref{SortedBy} pg.\pageref{SortedBy}), 
    TopLevel(\ref{TopLevel} pg.\pageref{TopLevel})
\end{command} % -- end command --------------------------------

\section{MaxChains}
\label{MaxChains}
\begin{command} % -- COMMAND: MaxChains ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MaxChains(relP: LIST): LIST of LIST
\end{Verbatim}


\subsection*{Description}

This function returns the list of all maximal chains from the list relP of the strict relations in a poset.
\par 
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
// POSET:
//         3   4
//          \ /
//           2
//           |
//           1
/**/ relP := [[1,  2], [2, 3],  [2,  4]];
/**/ MaxChains(relP);
[[1,  2,  3],  [1,  2,  4]]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{MayerVietorisTreeN1}
\label{MayerVietorisTreeN1}
\begin{command} % -- COMMAND: MayerVietorisTreeN1 ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MayerVietorisTreeN1(I: IDEAL): INT
\end{Verbatim}


\subsection*{Description}

Implemented in CoCoALib by Eduardo Saenz-de-Cabezon.
\par 
This function returns the list of multidegrees ``\verb&M&'' such that the N-1st
Betti number of a monomial ideal ``\verb&I&'' at multidegree ``\verb&M&'' is not zero.
It is computed via a version of its Mayer-Vietoris tree.
\par 
The length of this list is the number of irreducible components of I,
the number of maximal standard monomials, and the number of generators
of its Alexander Dual.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  I := ideal(x, y, z)^2;
/**/  MayerVietorisTreeN1(I);
[x^2*y*z, x*y^2*z, x*y*z^2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Frobby(\ref{Frobby} pg.\pageref{Frobby})
\end{command} % -- end command --------------------------------

\section{min}
\label{min}
\begin{command} % -- COMMAND: min ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
min(E_1: OBJECT,...,E_n: OBJECT): OBJECT
min(L: LIST): OBJECT
\end{Verbatim}


\subsection*{Description}

In the first form, this function returns a minimum of $E_1,...,E_n$.
In the second form, it returns a minimum of the objects in the list ``\verb&L&''.
\par 
See more examples in ``\verb&max&'' (\ref{max} pg.\pageref{max}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  min([1,2,3]);
1
/**/  min(1,2,3);
1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  max(\ref{max} pg.\pageref{max}), 
    min(\ref{min} pg.\pageref{min}), 
    MinBy(\ref{MinBy} pg.\pageref{MinBy}), 
    MaxBy(\ref{MaxBy} pg.\pageref{MaxBy}), 
    Relational Operators(\ref{Relational Operators} pg.\pageref{Relational Operators})
\end{command} % -- end command --------------------------------

\section{MinBy}
\label{MinBy}
\begin{command} % -- COMMAND: MinBy ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MinBy(L: LIST, LessThanFunc: FUNCTION): OBJECT
\end{Verbatim}


\subsection*{Description}

This function returns a minimum of the elements of the list ``\verb&L&''
with respect to the comparisons made by ``\verb&LessThanFunc&''.
(see ``\verb&MaxBy&'' (\ref{MaxBy} pg.\pageref{MaxBy}) for details)
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Define ByLength(S, T)    -- define the sorting function
/**/    Return len(S) < len(T);
/**/  EndDefine;

/**/  L := ["bird", "mouse", "cat", "elephant"];
/**/  MinBy(L, ByLength);
cat
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  MaxBy(\ref{MaxBy} pg.\pageref{MaxBy}), 
    func(\ref{func} pg.\pageref{func}), 
    SortBy(\ref{SortBy} pg.\pageref{SortBy}), 
    SortedBy(\ref{SortedBy} pg.\pageref{SortedBy}), 
    TopLevel(\ref{TopLevel} pg.\pageref{TopLevel})
\end{command} % -- end command --------------------------------

\section{MinGBoverZZ [PROTOTYPE]}
\label{MinGBoverZZ [PROTOTYPE]}
\begin{command} % -- COMMAND: MinGBoverZZ [PROTOTYPE] ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MinGBoverZZ(L: LIST of RINGELEM): LIST
\end{Verbatim}


\subsection*{Description}

This function returns a minimal Groebner basis of the ideal generated by ``\verb&L&'',
which must be a list of polynomials from a ring with coefficient ring ``\verb&ZZ&'' (\ref{ZZ} pg.\pageref{ZZ}).
\textbf{This is just a prototype:} exact semantics, and interface are likely to change!
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use ZZ[x,y];
/**/ MinGBoverZZ([x^2+y^2+2, x^3-y^3, x*y-2*x-3]);
[1460,  4*y +308,  x +499*y +500,  y^2 -6*x +4*y -3]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GBasis(\ref{GBasis} pg.\pageref{GBasis})
\end{command} % -- end command --------------------------------

\section{MinGens}
\label{MinGens}
\begin{command} % -- COMMAND: MinGens ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MinGens(M: IDEAL|MODULE): LIST
\end{Verbatim}


\subsection*{Description}

If ``\verb&M&'' is a homogeneous ideal or module, this function returns
a list of minimal generators for ``\verb&M&'' (not necessarily a subset
of ``\verb&gens(M)&'').
\par 
For non-homogeneous input use ``\verb&MinSubsetOfGens&'' (\ref{MinSubsetOfGens} pg.\pageref{MinSubsetOfGens}).
\par 
NOTE: the coefficient ring must be a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x-y, (x-y)^4, z+y, (z+y)^2);
/**/  MinGens(I);
[y + z, x + z]

/**/  R3 := NewFreeModule(R, 3);
/**/  MGens := matrix(R, [[x,y,z], [x^2,0,z^2], [2*x^2,x*y,z^2+x*z]]);
/**/  M := SubmoduleRows(R3, MGens);
/**/  gens(M);
[[x, y, z], [x^2, 0, z^2], [2*x^2, x*y, x*z +z^2]]
/**/  MinGens(M);
[[x, y, z], [0, x*y, x*z -z^2]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IdealOfMinGens(\ref{IdealOfMinGens} pg.\pageref{IdealOfMinGens}), 
    SubmoduleOfMinGens(\ref{SubmoduleOfMinGens} pg.\pageref{SubmoduleOfMinGens}), 
    MinSubsetOfGens(\ref{MinSubsetOfGens} pg.\pageref{MinSubsetOfGens})
\end{command} % -- end command --------------------------------

\section{MinGensGeneral [OBSOLESCENT]}
\label{MinGensGeneral [OBSOLESCENT]}
\begin{command} % -- COMMAND: MinGensGeneral [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&MinSubsetOfGens&'' (\ref{MinSubsetOfGens} pg.\pageref{MinSubsetOfGens}) (more expressive).

\end{command} % -- end command --------------------------------

\section{minimalize [OBSOLESCENT]}
\label{minimalize [OBSOLESCENT]}
\begin{command} % -- COMMAND: minimalize [OBSOLESCENT] ------------



\subsection*{Description}

Essentially replaced by ``\verb&IdealOfMinGens&'' (\ref{IdealOfMinGens} pg.\pageref{IdealOfMinGens}) and ``\verb&SubmoduleOfMinGens&'' (\ref{SubmoduleOfMinGens} pg.\pageref{SubmoduleOfMinGens}).

\SeeAlso %---- SEE ALSO ----
  MinGens(\ref{MinGens} pg.\pageref{MinGens}), 
    MinSubsetOfGens(\ref{MinSubsetOfGens} pg.\pageref{MinSubsetOfGens})
\end{command} % -- end command --------------------------------

\section{minimalized [OBSOLESCENT]}
\label{minimalized [OBSOLESCENT]}
\begin{command} % -- COMMAND: minimalized [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&IdealOfMinGens&'' (\ref{IdealOfMinGens} pg.\pageref{IdealOfMinGens}) and ``\verb&SubmoduleOfMinGens&'' (\ref{SubmoduleOfMinGens} pg.\pageref{SubmoduleOfMinGens}).

\end{command} % -- end command --------------------------------

\section{MinimalPresentation}
\label{MinimalPresentation}
\begin{command} % -- COMMAND: MinimalPresentation ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MinimalPresentation(Q:TAGGED): TAGGED

where Q is a quotient module of the type R^s/M
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
Given a quotient module of the type $R^{s}/M$,
or a zero module, this function computes an isomorphic quotient,
$R^{t}/N$, minimally presented
[using the algorithm in Kreuzer-Robbiano II].
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  use R ::= QQ[x,y,z];
  MinimalPresentation(R^3/Module([[x,1,1], [x,2,2]]));
R^2/Module([[x, 0]])
-------------------------------
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{minors}
\label{minors}
\begin{command} % -- COMMAND: minors ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
minors(M: MAT, N: INT): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the list of all determinants of N x N
submatrices of M.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,2,3],[-1,2,4]]);
/**/  minors(M, 2);
[4, 7, 2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  det(\ref{det} pg.\pageref{det})
\end{command} % -- end command --------------------------------

\section{MinPoly}
\label{MinPoly}
\begin{command} % -- COMMAND: MinPoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MinPoly(M: MAT, X: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

Thanks to Maria-Laura Torrente.
\par 
This function returns the minimal polynomial of the matrix ``\verb&M&'' in the
indeterminate ``\verb&X&'' (with ``\verb&M&'' a square matrix whose entries lie
in the coefficient ring of ``\verb&X&'', or in the same ring as ``\verb&X&'' but not
dependent on ``\verb&X&'').
See also ``\verb&CharPoly&'' (\ref{CharPoly} pg.\pageref{CharPoly}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  MinPoly(matrix([[0,0,1],[0,0,0],[0,0,0]]), x);
x^2
/**/  CharPoly(matrix([[0,0,1],[0,0,0],[0,0,0]]), x);
x^3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CharPoly(\ref{CharPoly} pg.\pageref{CharPoly})
\end{command} % -- end command --------------------------------

\section{MinPolyQuot}
\label{MinPolyQuot}
\begin{command} % -- COMMAND: MinPolyQuot ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MinPolyQuot(f: RINGELEM, I: IDEAL, z: RINGELEM): RINGELEM
MinPolyQuot(f: RINGELEM, I: IDEAL, z: RINGELEM, VerificationLevel: INT): RINGELEM
MinPolyQuotDef(f: RINGELEM, I: IDEAL, z: RINGELEM): RINGELEM
MinPolyQuotElim(f: RINGELEM, I: IDEAL, z: RINGELEM): RINGELEM
MinPolyQuotMat(f: RINGELEM, I: IDEAL, z: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

These functions return the minimal polynomial (in the indeterminate ``\verb&z&'')
of the element ``\verb&f&'' modulo the 0-dimensional ideal ``\verb&I&''.
\par 
See article Abbott, Bigatti, Palezzato, Robbiano
"Computing and Using Minimal Polynomials"
(``\verb&https://arxiv.org/abs/1702.07262&'')
\par 
When coefficients are in ``\verb&QQ&'' (\ref{QQ} pg.\pageref{QQ}), ``\verb&MinPolyQuot&'' uses modular methods.
If called with ``\verb&VerificationLevel&'' equal to $n>=0$ the result polynomial
is verified over ``\verb&FF_p&'', with n different primes (if n=0, not verified).
\par 
Verbosity:
At level 80 it lists all primes used, indicating any which are \textbf{bad}.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use P ::= QQ[x,y];
/**/ I := IdealOfPoints(P, mat([[1,2], [3,4], [5,6]]));
/**/ MinPolyQuot(x,I,x); -- the smallest x-univariate poly in I
x^3 -9*x^2 +23*x -15
/**/ indent(factor(It));
record[
  RemainingFactor := 1,
  factors := [x -1, x -3, x -5],
  multiplicities := [1, 1, 1]
]

/**/ f := x+y;
/**/ I := ideal(x^2, y^2);
/**/ MinPolyQuot(f,I,x);
x^3
/**/ subst(It, x, f) isin I;
true

/**/ use QQ[x,y];
/**/ I := ideal(x^3-5,y^2-3);
/**/ f := x+y;
/**/ SetVerbosityLevel(80);
/**/ MinPolyQuot(f, I, x);
1: prime is 32009
2: prime is 32027
x^6 -9*x^4 -10*x^3 +27*x^2 -90*x -2

---- this is how to use an indet in another ring:
/**/ QQt := RingQQt(1);
/**/ MinPolyQuot(f, I, indet(RingQQt(1),1));
t^6 -9*t^4 -10*t^3 +27*t^2 -90*t -2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  MinPoly(\ref{MinPoly} pg.\pageref{MinPoly})
\end{command} % -- end command --------------------------------

\section{MinPowerInIdeal}
\label{MinPowerInIdeal}
\begin{command} % -- COMMAND: MinPowerInIdeal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MinPowerInIdeal(F: RINGELEM, I: IDEAL): INT
\end{Verbatim}


\subsection*{Description}

This function returns the minimum power of F, the first argument, in
the ideal I, the second argument.
If F is not in the radical I then -1 is returned.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  I := ideal(x^6*y^4, z);
/**/  IsInRadical(x*y, I);
true

/**/  MinPowerInIdeal(x*y, I);
6
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsInRadical(\ref{IsInRadical} pg.\pageref{IsInRadical}), 
    radical(\ref{radical} pg.\pageref{radical})
\end{command} % -- end command --------------------------------

\section{MinSubsetOfGens}
\label{MinSubsetOfGens}
\begin{command} % -- COMMAND: MinSubsetOfGens ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MinSubsetOfGens(M: IDEAL|MODULE): LIST
\end{Verbatim}


\subsection*{Description}

This function returns a subset ``\verb&S&'' of ``\verb&gens(M)&'' which is
minimal in the sense that no proper subset of ``\verb&S&'' generates ``\verb&M&''.
\par 
NOTE: there no guarantee that ``\verb&S&'' is the subset with smallest cardinality.
\par 
If ``\verb&M&'' is a homogeneous ideal or module, the function
``\verb&MinGens&'' (\ref{MinGens} pg.\pageref{MinGens}) is much faster (but may return a generating set
which is not a subset of ``\verb&gens(M)&'').
\par 
The coefficient ring must be a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x-1, (x-y)^4, z+y, (z+y)^2);
/**/  MinSubsetOfGens(I);
[x -1, x^4 -4*x^3*y +6*x^2*y^2 -4*x*y^3 +y^4, y +z]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  MinGens(\ref{MinGens} pg.\pageref{MinGens}), 
    IdealOfMinGens(\ref{IdealOfMinGens} pg.\pageref{IdealOfMinGens}), 
    SubmoduleOfMinGens(\ref{SubmoduleOfMinGens} pg.\pageref{SubmoduleOfMinGens})
\end{command} % -- end command --------------------------------

\section{mod}
\label{mod}
\begin{command} % -- COMMAND: mod ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
mod(N: INT, D: INT): INT
\end{Verbatim}


\subsection*{Description}

This function computes the remainder of integer division of ``\verb&N&'' by ``\verb&D&'';
the \textbf{remainder is zero or has the same sign as} ``\verb&N&''.
\par 
If we set ``\verb&Q = div(N,D)&'' and ``\verb&R = mod(N,D)&'' then $N = Q*D + R$.
\par 
NOTE: for polynomials use ``\verb&NR&'' (\ref{NR} pg.\pageref{NR}) (remainder),  ``\verb&DivAlg&'' (\ref{DivAlg} pg.\pageref{DivAlg}) (quotients and remainder),
``\verb&IsIn&'' (\ref{IsIn} pg.\pageref{IsIn}) (ideal membership).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  mod(10,3);
1
/**/  mod(-10,3);
-1
/**/  // How to test if two numbers are equivalent modulo M
/**/  A := 10; B := -5; M := 3;
/**/  mod(A-B,M) = 0;      // CORRECT!
true
/**/  mod(A,M) = mod(B,M); // WRONG!!  Do not do this!
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  div(\ref{div} pg.\pageref{div}), 
    DivAlg(\ref{DivAlg} pg.\pageref{DivAlg}), 
    IsIn(\ref{IsIn} pg.\pageref{IsIn}), 
    NF(\ref{NF} pg.\pageref{NF}), 
    NR(\ref{NR} pg.\pageref{NR})
\end{command} % -- end command --------------------------------

\section{Mod2Rat [OBSOLETE]}
\label{Mod2Rat [OBSOLETE]}
\begin{command} % -- COMMAND: Mod2Rat [OBSOLETE] ------------



\subsection*{Description}

See ``\verb&RatReconstructWithBounds&'' (\ref{RatReconstructWithBounds} pg.\pageref{RatReconstructWithBounds}).

\end{command} % -- end command --------------------------------

\section{ModuleElem}
\label{ModuleElem}
\begin{command} % -- COMMAND: ModuleElem ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ModuleElem(M: MODULE, L: LIST): MODULEELEM
\end{Verbatim}


\subsection*{Description}

This function returns the MODULEELEM (called ``\verb&Vector&'' in CoCoA-4)
in the module ``\verb&M&'' whose components are the components of the list ``\verb&L&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  R3 := NewFreeModule(R,3);
/**/  V := ModuleElem(R3, [1, x, x^2]);  V;
[1, x, x^2]
/**/  type(V);
MODULEELEM
/**/  zero(R3);
[0, 0, 0]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  SubmoduleCols, SubmoduleRows(\ref{SubmoduleCols, SubmoduleRows} pg.\pageref{SubmoduleCols, SubmoduleRows})
\end{command} % -- end command --------------------------------

\section{ModuleOf}
\label{ModuleOf}
\begin{command} % -- COMMAND: ModuleOf ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ModuleOf(V: MODULEELEM): MODULE
ModuleOf(M: MODULE): MODULE
\end{Verbatim}


\subsection*{Description}

The first form gives the free module to which ``\verb&V&'' belongs;
the second form gives the free module containing ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  R3 := NewFreeModule(R,3);
/**/  V := ModuleElem(R3, [1, x, x^2]);  V;
[1, x, x^2]
/**/  type(V);
MODULEELEM
/**/  ModuleOf(V) = R3;
true
/**/  ModuleOf(V);
FreeModule(RingDistrMPolyClean(QQ, 1), 3)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  submodule(\ref{submodule} pg.\pageref{submodule})
\end{command} % -- end command --------------------------------

\section{moebius}
\label{moebius}
\begin{command} % -- COMMAND: moebius ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
moebius(relP: LIST): LIST of INT
\end{Verbatim}


\subsection*{Description}

This function returns a list ``\verb&L&'' such that ``\verb&L[i]&'' is the
moebius function value of the node i in the poset from the list ``\verb&relP&''
of the strict relations in the poset.
\par 
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
// POSET:
//         3   4
//          \ /
//           2
//           |
//           1
/**/ relP := [[1,  2], [2, 3],  [2,  4]];
/**/ moebius(relP);
[1,  -1,  0,  0]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{monic}
\label{monic}
\begin{command} % -- COMMAND: monic ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
monic(F: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns ``\verb&F&'' divided by its leading coefficient (see ``\verb&LC&'' (\ref{LC} pg.\pageref{LC})).
If ``\verb&F&'' is zero, it throws an error.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  F := 4*x^5-y^2;
/**/  monic(F);
x^5 +(-1/4)*y^2

/**/  use R ::= ZZ[x,y];
/**/  F := 4*x^5-y^2;
-- /**/  monic(F);  --> !!! ERROR !!! as expected: cannot invert over ZZ

/**/  use P ::= ZZ/(5)[x,y];
/**/  F := 2*x^2+4*y^3;
/**/  monic(F);
y^3 -2*x^2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LC(\ref{LC} pg.\pageref{LC}), 
    prim(\ref{prim} pg.\pageref{prim}), 
    CommonDenom(\ref{CommonDenom} pg.\pageref{CommonDenom})
\end{command} % -- end command --------------------------------

\section{monomials}
\label{monomials}
\begin{command} % -- COMMAND: monomials ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
monomials(F: RINGELEM|MODULEELEM): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the list of monomials of F.
The function ``\verb&support&'' (\ref{support} pg.\pageref{support}) returns the list of terms
(monomials without coefficients).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  F := 3*x^2*y +5*y^3 -x*y^5;
/**/  monomials(F);
[-x*y^5, 3*x^2*y, 5*y^3]

/**/  support(F);
[x*y^5, x^2*y, y^3]

  Monomials(Vector(3*x^2*y+y,5*x*y+4)); --***WORK IN PROGRESS***
[Vector(3x^2y, 0), Vector(0, 5xy), Vector(y, 0), Vector(0, 4)]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  coefficients(\ref{coefficients} pg.\pageref{coefficients}), 
    support(\ref{support} pg.\pageref{support})
\end{command} % -- end command --------------------------------

\section{MonsInIdeal}
\label{MonsInIdeal}
\begin{command} % -- COMMAND: MonsInIdeal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MonsInIdeal(I: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function returns the ideal generated by all monomials in the
original ideal I.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  use R ::= QQ[x,y,z];
  I := ideal(xy^3+z^2, y^5-z^3, xz-y^2-x^3, x^4-xz^2+y^3);
  MonsInIdeal(I);
ideal(z^3, yz^2, x^2z^2, x^5z, x^4yz, x^5y, x^2y^2z, x^7, x^4y^2,
      xy^3z, y^4z, xy^4, x^3y^3, y^5)
-------------------------------
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{MSatLinSolve}
\label{MSatLinSolve}
\begin{command} % -- COMMAND: MSatLinSolve ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MSatLinSolve(Env: RECORD): MATRIX
\end{Verbatim}


\subsection*{Description}

This function calls the ``\verb&MathSAT&'' (\ref{MathSAT} pg.\pageref{MathSAT}) implementation of the simplex method.
The argument ``\verb&Env&'' may contain the following fields: ``\verb&leq0&'', ``\verb&neq0&'',
``\verb&eq0&'', ``\verb&lt0&''; each field must have as value a matrix with rational entries,
where each row of the matrix corresponds to a linear condition.  The matrices
must all have the same number of columns.
\par 
The work for this communication has been partly supported by the
European Union Horizon 2020 research and innovation programme
under grant agreement No H2020-FETOPEN-2015-CSA 712689:
SC-square ``\verb&http://www.sc-square.org&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ LinSys := 
/**/   record[leq0 := matrix([[1,2,3, 4],  //   x +2*y +3*z +4 <= 0
/**/                          [9,8,7, 0]]),// 9*x +8*y +7*z    <= 0
/**/          neq0 := matrix([[1,0,0, 0]]) //   x              <> 0
/**/         ];
/**/ soln := MSatLinSolve(LinSys);  soln;
matrix(QQ,
 [[1],
  [4/5],
  [-11/5]])
/**/ // verify:
/**/ soln1 := ConcatVer(soln, matrix([[1]])); //-->  [[1], [4/5], [-11/5], [1]]
/**/ LinSys.leq0 * soln1;  // is <= 0
matrix(QQ,
 [[0],
  [0]])
/**/ LinSys.neq0 * soln1;  // is <> 0
matrix(QQ,
 [[1]])
/**/ // now we add new contraints:
/**/ LinSys.eq0 := RowMat([1,1,0, 4]);   //  x +y +4 = 0
/**/ LinSys.lt0 := RowMat([0,1,0, 0]);   //     y    < 0
/**/ soln := MSatLinSolve(LinSys);  soln;
matrix(QQ,
 [[-2],
  [-2],
  [-2/7]])
/**/ // verify:
/**/ soln1 := ConcatVer(soln, RowMat([1]));  //-->  [[-2], [-2], [-2/7], [1]]
/**/ LinSys.leq0 * soln1;  // <= 0
matrix(QQ,
 [[-20/7],
  [-36]])
/**/ LinSys.neq0 * soln1;  // <> 0
matrix(QQ,
 [[-2]])
/**/ LinSys.eq0  * soln1;  //  = 0
matrix(QQ,
 [[0]])
/**/ LinSys.lt0  * soln1;  //  < 0
matrix(QQ,
 [[-2]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LinSolve(\ref{LinSolve} pg.\pageref{LinSolve}), 
    MathSAT(\ref{MathSAT} pg.\pageref{MathSAT})
\end{command} % -- end command --------------------------------

\section{MultiArrDerMod [OBSOLESCENT]}
\label{MultiArrDerMod [OBSOLESCENT]}
\begin{command} % -- COMMAND: MultiArrDerMod [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&MultiArrDerModule&'' (\ref{MultiArrDerModule} pg.\pageref{MultiArrDerModule}).

\end{command} % -- end command --------------------------------

\section{MultiArrDerModule}
\label{MultiArrDerModule}
\begin{command} % -- COMMAND: MultiArrDerModule ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MultiArrDerModule(MultiA: LIST): MAT 
\end{Verbatim}


\subsection*{Description}

This function returns the matrix whose columns are a set of generators
of the module of logarithmic derivations of a multiarrangement of hyperplanes.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ MultiA := [[x,1], [x-y,3], [y,2]];
/**/ MultiArrDerModule(MultiA);
matrix( /*RingWithID(2200, "QQ[x,y]")*/
 [[x*y^2, x^3 -3*x^2*y],
  [x*y^2, -3*x*y^2 +y^3]])	
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  MultiArrExponents(\ref{MultiArrExponents} pg.\pageref{MultiArrExponents}), 
    IsMultiArrFree(\ref{IsMultiArrFree} pg.\pageref{IsMultiArrFree})
\end{command} % -- end command --------------------------------

\section{MultiArrExponents}
\label{MultiArrExponents}
\begin{command} % -- COMMAND: MultiArrExponents ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MultiArrExponents(MultiA: LIST): LIST 
\end{Verbatim}


\subsection*{Description}

This function returns the list of exponents of a free multiarrangement of hyperplanes MultiA.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ MultiA := [[x,1], [x-y,3], [y,2]]; -- free
/**/ MultiArrExponents(MultiA);
[3,  3]

/**/ use QQ[x,y,z];
/**/ MultiA := [[x,1], [x-y,3], [z,2], [x+y-z,3]]; -- not free
/**/ IsMultiArrFree(MultiA); --> false
-- /**/ MultiArrExponents(MultiA);  --> !!! ERROR !!! as expected, not free
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  MultiArrDerModule(\ref{MultiArrDerModule} pg.\pageref{MultiArrDerModule}), 
    IsMultiArrFree(\ref{IsMultiArrFree} pg.\pageref{IsMultiArrFree})
\end{command} % -- end command --------------------------------

\section{MultiArrRestrictionZiegler}
\label{MultiArrRestrictionZiegler}
\begin{command} % -- COMMAND: MultiArrRestrictionZiegler ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MultiArrRestrictionZiegler(A: LIST, H: RINGELEM): LIST 
\end{Verbatim}


\subsection*{Description}

This function returns the Ziegler multirestriction of the arrangement of
hyperplanes A with respect to its hyperplane H in the variables [y[1],..,y[n]].
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y,z];	
/**/ A := [x, x-z, y-z, z];
/**/ MultiArrRestrictionZiegler(A, z);
[[y[1],  2],  [y[2],  1]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ArrRestriction(\ref{ArrRestriction} pg.\pageref{ArrRestriction}), 
    ArrToMultiArr(\ref{ArrToMultiArr} pg.\pageref{ArrToMultiArr})
\end{command} % -- end command --------------------------------

\section{MultiArrToArr}
\label{MultiArrToArr}
\begin{command} % -- COMMAND: MultiArrToArr ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MultiArrToArr(MultiA: LIST): LIST 
\end{Verbatim}


\subsection*{Description}

This function constructs the underling arrangement of the
multiarrangement MultiA.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y,z];
/**/ MultiA := [[x,1], [y,3], [z,2]];
/**/ MultiArrToArr(MultiA);
[x,  y,  z]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ArrToMultiArr(\ref{ArrToMultiArr} pg.\pageref{ArrToMultiArr})
\end{command} % -- end command --------------------------------

\section{MultiplicationMat}
\label{MultiplicationMat}
\begin{command} % -- COMMAND: MultiplicationMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
MultiplicationMat(X: RINGELEM, I: IDEAL): MAT
MultiplicationMat(X: RINGELEM, I: IDEAL, QB: LIST): MAT
\end{Verbatim}


\subsection*{Description}

This function computes the multiplication matrix of a ringelem ``\verb&f&''
modulo a zero-dimensional ideal ``\verb&I&'' with respect to a quotient
basis of ``\verb&I&''.
\par 
In the second form it is computed with respect to the given quotient
basis ``\verb&QB&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y];
/**/  I := ideal(x*y +y^2 -x -4*y +3, x^2 -y^2 -4*x +2*y +3, y^3 -4*y^2 +5*y -2);
/**/  MultiplicationMat(x, I);
matrix(QQ,
 [[0, -3, -5, -3],
  [0, 4, 6, -2],
  [0, -1, -1, 1],
  [1, 1, 1, 4]])

/**/  MultiplicationMat(x, I, [one(CurrentRing), x, y, y^2]);
matrix(QQ,
 [[0, -3, -3, -5],
  [1, 4, 1, 1],
  [0, -2, 4, 6],
  [0, 1, -1, -1]])
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{multiplicity}
\label{multiplicity}
\begin{command} % -- COMMAND: multiplicity ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
multiplicity(R: RING): INT
multiplicity(M: MODULE): INT
\end{Verbatim}


\subsection*{Description}

This function computes the multiplicity (or degree) of ``\verb&R&'' or ``\verb&M&'',
\textit{i.e.} the leading coefficient of the Hilbert polynomial multiplied by
the factorial of the degree of the Hilbert polynomial.
``\verb&M&'' can be a module or a quotient.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[t,x,y,z];
/**/  multiplicity(R/ideal(x,y,z)^5);
35
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  HilbertFn(\ref{HilbertFn} pg.\pageref{HilbertFn}), 
    HilbertSeries(\ref{HilbertSeries} pg.\pageref{HilbertSeries}), 
    HVector(\ref{HVector} pg.\pageref{HVector})
\end{command} % -- end command --------------------------------

\chapter{N}  %----=== CHAPTER LETTER ===----
\label{N}

\section{NewFractionField}
\label{NewFractionField}
\begin{command} % -- COMMAND: NewFractionField ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NewFractionField(R: RING): RING
\end{Verbatim}


\subsection*{Description}

Create the fraction field of ``\verb&R&''; ``\verb&R&'' must be a true GCD domain.
\par 
NOTE: calling twice ``\verb&NewFractionField&'' will produce
two different rings, even with identical input: equality test is
performed on the pointers.  See ``\verb&RingID&'' (\ref{RingID} pg.\pageref{RingID}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  K := NewFractionField(NewPolyRing(QQ, "a,b"));
/**/  use K;
/**/  M := mat([[1,2,3,a],[5,6,7,a*b]]);
/**/  LinKerBasis(M);
[[-1, 2, -1, 0], [(a*b -3*a)/2, (-a*b +5*a)/4, 0, -1]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewQuotientRing(\ref{NewQuotientRing} pg.\pageref{NewQuotientRing}), 
    BaseRing(\ref{BaseRing} pg.\pageref{BaseRing}), 
    den(\ref{den} pg.\pageref{den}), 
    num(\ref{num} pg.\pageref{num}), 
    RingID(\ref{RingID} pg.\pageref{RingID})
\end{command} % -- end command --------------------------------

\section{NewFreeModule}
\label{NewFreeModule}
\begin{command} % -- COMMAND: NewFreeModule ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NewFreeModule(R: RING, N: INT): MODULE
NewFreeModule(R: RING, Shifts: MAT): MODULE
\end{Verbatim}


\subsection*{Description}

This function returns a free module of rank ``\verb&N&'' over ``\verb&R&''; for
the second form ``\verb&N&'' is taken to be the number of columns in ``\verb&Shifts&''.
\par 
NOTE: as for rings, calling twice ``\verb&NewFreeModule&'' will produce
two different modules, even with identical input: equality test is
performed on the pointers.
\par 
Starting from version CoCoA-5.0.4, this function does accept shifts.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  F := NewFreeModule(R, 3);
/**/  zero(F);
[0, 0, 0]
/**/ type(zero(F));  -- is NOT a LIST
MODULEELEM
/**/ CanonicalBasis(F);
[[1, 0, 0], [0, 1, 0], [0, 0, 1]]

/**/ F := NewFreeModule(R, matrix([[1],[2],[3]])); -- shifts
/**/ [wdeg(e) | e in gens(F)];
[[1], [2], [3]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BaseRing(\ref{BaseRing} pg.\pageref{BaseRing}), 
    CanonicalBasis(\ref{CanonicalBasis} pg.\pageref{CanonicalBasis}), 
    RingOf(\ref{RingOf} pg.\pageref{RingOf})
\end{command} % -- end command --------------------------------

\section{NewId [OBSOLETE]}
\label{NewId [OBSOLETE]}
\begin{command} % -- COMMAND: NewId [OBSOLETE] ------------



\subsection*{Description}

[OBSOLETE]

\end{command} % -- end command --------------------------------

\section{NewLine [OBSOLESCENT]}
\label{NewLine [OBSOLESCENT]}
\begin{command} % -- COMMAND: NewLine [OBSOLESCENT] ------------



\subsection*{Description}

This function is \textbf{OBSOLESCENT} and exists only for backward
compatibility with old CoCoA code.
It returns a string containing just a newline; in CoCoA-5 it is
simpler to write ``\verb&\n&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  str1 := "Line 1" + NewLine() + "Line 2"; --> old CoCoA-4 way
/**/  str2 := "Line 1\nLine 2";                --> more compact in CoCoA-5
/**/  str1 = str2;
true
/**/ Print str2;
Line 1
Line2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  String Literals(\ref{String Literals} pg.\pageref{String Literals}), 
    println(\ref{println} pg.\pageref{println}), 
    ascii(\ref{ascii} pg.\pageref{ascii})
\end{command} % -- end command --------------------------------

\section{NewList}
\label{NewList}
\begin{command} % -- COMMAND: NewList ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NewList(N: INT): LIST
NewList(N: INT, E: OBJECT): LIST
\end{Verbatim}


\subsection*{Description}

The first form returns a list of length ``\verb&N&'' filled with 0 (INT).
The second form returns a list of length ``\verb&N&'', filled with copies of ``\verb&E&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  NewList(4,"a");
["a", "a", "a", "a"]

/**/  NewList(4);
[0, 0, 0, 0]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  List Constructors(\ref{List Constructors} pg.\pageref{List Constructors})
\end{command} % -- end command --------------------------------

\section{NewMat}
\label{NewMat}
\begin{command} % -- COMMAND: NewMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NewMat(R: RING, M: INT, N: INT): MAT
\end{Verbatim}


\subsection*{Description}

This function is kept for CoCoA-4 nostalgia: better use ``\verb&ZeroMat&'' (\ref{ZeroMat} pg.\pageref{ZeroMat}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use S ::= QQ[x,y,z];
/**/  NewMat(S,2,3);
matrix( /*RingDistrMPolyClean(QQ, 3)*/
 [[0, 0, 0],
  [0, 0, 0]])
/**/  ZeroMat(S,2,3);
matrix( /*RingDistrMPolyClean(QQ, 3)*/
 [[0, 0, 0],
  [0, 0, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  matrix(\ref{matrix} pg.\pageref{matrix}), 
    NewMatFilled(\ref{NewMatFilled} pg.\pageref{NewMatFilled})
\end{command} % -- end command --------------------------------

\section{NewMatFilled}
\label{NewMatFilled}
\begin{command} % -- COMMAND: NewMatFilled ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NewMatFilled(M: INT, N: INT, Val: INT|RAT|RINGELEM): MAT
\end{Verbatim}


\subsection*{Description}

This function returns an ``\verb&MxN&'' matrix, filled with ``\verb&Val&''.  If ``\verb&Val&''
is an integer or rational, the ring of the matrix is ``\verb&QQ&'' (\ref{QQ} pg.\pageref{QQ}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use S ::= QQ[x,y,z];
/**/  NewMatFilled(1,3,x);
matrix( /*RingDistrMPolyClean(QQ, 3)*/
 [[x, x, x]])

/**/  NewMatFilled(1,3, 0);
matrix(QQ,
 [[0, 0, 0]])
/**/  ZeroMat(QQ, 1, 3); --> same as NewMatFilled(1,3, 0)
matrix(QQ,
 [[0, 0, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewMat(\ref{NewMat} pg.\pageref{NewMat}), 
    ZeroMat(\ref{ZeroMat} pg.\pageref{ZeroMat}), 
    matrix(\ref{matrix} pg.\pageref{matrix})
\end{command} % -- end command --------------------------------

\section{NewPolyRing}
\label{NewPolyRing}
\begin{command} % -- COMMAND: NewPolyRing ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NewPolyRing(CoeffRing: RING, IndetNames: STRING/LIST): RING
NewPolyRing(CoeffRing: RING, IndetNames: STRING/LIST, OrdMat: MAT, GradingDim: INT): RING
\end{Verbatim}


\subsection*{Description}

This function returns a polynomial ring which can be used as any
programming variable (assigned with ``\verb&:=&'').
\par 
The ``\verb&::=&'' syntax starts the input method for a new polynomial ring,
with the special interpretation of brackets and symbols
(\textit{i.e.} ``\verb&R ::= QQ[x]&'' is not read the same way as ``\verb&X := L[i]&'').
The PP-orderings which can be specified with the ``\verb&::=&'' syntax are
``\verb&Lex&'' and ``\verb&Xel&'' (no grading), ``\verb&DegLex&'' and ``\verb&DegRevLex&'' (std grading).
For other PP-orderings you must use the ``\verb&NewPolyRing&'' function call
(see also ``\verb&ElimMat&'' (\ref{ElimMat} pg.\pageref{ElimMat})).
\par 
NOTE: calling ``\verb&NewPolyRing&'' twice with the same arguments gives
two \textbf{different rings}, therefore incompatible.  See ``\verb&RingID&'' (\ref{RingID} pg.\pageref{RingID}).
\par 
NOTE: the syntax with all indet names in one string is new in CoCoA-5.1.2.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  OrdM := matrix([[2,3,1],[0,0,-1],[0,-1,0]]);
/**/  P := NewPolyRing(QQ, "x[1],x[2],x[9]", OrdM, 1); -- 3 indeterminates
/**/  [wdeg(X) | X in indets(P)];
[[2], [3], [1]]

/**/  P2 := NewPolyRing(RingZZ(), IndetSymbols(P)); -- same indet names as P
/**/  Indets(P2);
[x[1], x[2], x[9]]

/**/  R ::= QQ[x,y,alpha]; -- is equivalent to
/**/  R := NewPolyRing(QQ, "x,y,alpha"); -- in "define/enddefine" use "RingQQ()"

/**/  R ::= QQ[x,y], DegRevLex; -- is equivalent to
/**/  R := NewPolyRing(QQ, "x,y", StdDegRevLexMat(2), 1);

/**/  P3 := NewPolyRing(P2, SymbolRange("alpha", -2,2));
/**/  indets(P3);
[alpha[-2], alpha[-1], alpha[0], alpha[1], alpha[2]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ElimMat(\ref{ElimMat} pg.\pageref{ElimMat}), 
    MakeTermOrdMat(\ref{MakeTermOrdMat} pg.\pageref{MakeTermOrdMat}), 
    OrdMat(\ref{OrdMat} pg.\pageref{OrdMat}), 
    GradingDim(\ref{GradingDim} pg.\pageref{GradingDim}), 
    IndetSymbols(\ref{IndetSymbols} pg.\pageref{IndetSymbols}), 
    SymbolRange(\ref{SymbolRange} pg.\pageref{SymbolRange}), 
    RingID(\ref{RingID} pg.\pageref{RingID})
\end{command} % -- end command --------------------------------

\section{NewQuotientRing}
\label{NewQuotientRing}
\begin{command} % -- COMMAND: NewQuotientRing ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NewQuotientRing(R: RING, I: IDEAL): RING
NewQuotientRing(R: RING, s: STRING): RING
R/I    -- R: RING, I: IDEAL
\end{Verbatim}


\subsection*{Description}

This function makes a new ring ``\verb&R/I&''.
The syntax with the ``\verb&STRING&'' is a shortcut for quotienting by the 
principal ideal generated by the RINGELEM it represents.
This syntax is expecially useful when the base ring is contextually created
(see example below).
\par 
NOTE: calling twice ``\verb&NewQuotientRing&'' will produce
two different rings, even with identical input: equality test is
performed on the pointers.  See ``\verb&RingID&'' (\ref{RingID} pg.\pageref{RingID}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use Qi ::= QQ[i];
/**/  CC := Qi/ideal(i^2+1);  -- sort of  ;-)
/**/  use CC[x];
/**/  (x+i)^2;  --> round brackets in output indicate class in CC
x^2 +(2*i)*x +(-1)

/**/  -- string shortcut
/**/  RmodI := NewQuotientRing(NewPolyRing(QQ, "x,y,z"), "y-3, z^2-5");
/**/  use RmodI;
/**/  (x+y)^2;  --> round brackets in output indicate class in RmodI
(x^2 +6*x +9)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BaseRing(\ref{BaseRing} pg.\pageref{BaseRing}), 
    QuotientBasis(\ref{QuotientBasis} pg.\pageref{QuotientBasis}), 
    NewFractionField(\ref{NewFractionField} pg.\pageref{NewFractionField}), 
    RingID(\ref{RingID} pg.\pageref{RingID})
\end{command} % -- end command --------------------------------

\section{NewRingFp [OBSOLESCENT]}
\label{NewRingFp [OBSOLESCENT]}
\begin{command} % -- COMMAND: NewRingFp [OBSOLESCENT] ------------



\subsection*{Description}

Please use ``\verb&NewZZmod&'' (\ref{NewZZmod} pg.\pageref{NewZZmod}) instead.

\SeeAlso %---- SEE ALSO ----
  NewZZmod(\ref{NewZZmod} pg.\pageref{NewZZmod})
\end{command} % -- end command --------------------------------

\section{NewRingTwinFloat}
\label{NewRingTwinFloat}
\begin{command} % -- COMMAND: NewRingTwinFloat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NewRingTwinFloat(Prec: INT): RING
\end{Verbatim}


\subsection*{Description}

Create a new twin-float ring with bit precision ``\verb&Prec&''.
\par 
NOTE: calling twice ``\verb&NewRingTwinFloat&'' will produce two different
rings, even with identical arguments, since the equality test for
rings is performed on the pointers: see manual entry for ``\verb&RingID&'' (\ref{RingID} pg.\pageref{RingID}).

\par 
For more information see the article:
John Abbott, "Twin-float arithmetic",
Journal of Symbolic Computation, Volume 47 (2012), 536--551.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  RR32 := NewRingTwinFloat(32);
/**/  use RR32[x];
/**/  (3*x-1)/3;
x -0.3333333333333333333

/**/  RR64 := NewRingTwinFloat(64);
/**/ use RR64[x];
/**/  (3*x-1)/3;
x -0.333333333333333333333333333333333333333
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  AsRAT(\ref{AsRAT} pg.\pageref{AsRAT}), 
    RingID(\ref{RingID} pg.\pageref{RingID})
\end{command} % -- end command --------------------------------

\section{NewWeylAlgebra}
\label{NewWeylAlgebra}
\begin{command} % -- COMMAND: NewWeylAlgebra ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NewWeylAlgebra(K: RING, Indets: STRING): RING
NewWeylAlgebra(K: RING, Indets: STRING, ..): RING
\end{Verbatim}


\subsection*{Description}

Create a new Weyl Algebra.
\par 
NOTE: calling twice ``\verb&NewWeylAlgebra&'' will produce
two different rings, even with identical input: equality test is
performed on the pointers.  See ``\verb&RingID&'' (\ref{RingID} pg.\pageref{RingID}).

\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ NewWeylAlgebra(QQ,"x,y");
RingWithID(3, "QQ[x,y,dx,dy]")
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{NewZZmod}
\label{NewZZmod}
\begin{command} % -- COMMAND: NewZZmod ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NewZZmod(N: INT): RING
\end{Verbatim}


\subsection*{Description}

Create a new finite ring/field being the integers modulo ``\verb&n&'';
with ``\verb&use&'' (\ref{use} pg.\pageref{use}) or ``\verb&::=&'' you can alternatively write
the convenient notation ``\verb&ZZ/(n)&''.
\par 
NOTE: calling twice ``\verb&NewZZmod&'' will produce
two different rings, even with identical input: equality test is
performed on the pointers: see ``\verb&RingID&'' (\ref{RingID} pg.\pageref{RingID}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  p := NextProbPrime(1000000);
/**/  Fp := NewZZmod(p);
/**/  use Fp[x]; -- same as "use ZZ/(p)[x];"

/**/ Characteristic(Fp);
1000003

/**/  n := 6;
/**/  R := NewZZmod(n);
/**/  use R[x];  -- same as "use ZZ/(6)[x];"
/**/  product([x-i | i in 1..6]);
x^6 +3*x^5 +x^4 +3*x^3 -2*x^2
/**/  (x-3)*(x-2);
x^2 +x
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  RingID(\ref{RingID} pg.\pageref{RingID}), 
    NewQuotientRing(\ref{NewQuotientRing} pg.\pageref{NewQuotientRing})
\end{command} % -- end command --------------------------------

\section{NextPrime, NextProbPrime}
\label{NextPrime, NextProbPrime}
\begin{command} % -- COMMAND: NextPrime, NextProbPrime ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NextPrime(N: INT): INT
NextProbPrime(N: INT): INT
\end{Verbatim}


\subsection*{Description}

The first function computes the smallest prime number greater than ``\verb&N&''.
If ``\verb&N&'' is too large then an error is signalled.  The upper
limit depends on the computer you are using; it is probably $2^31$
or $2^63$.
\par 
The second function computes the smallest probable prime number greater than ``\verb&N&''.  
To be absolutely certain the number produced is prime,
you must call ``\verb&IsPrime&'' (\ref{IsPrime} pg.\pageref{IsPrime}) on it, but this may be very costly.
\par 
The functions give errors if handed negative arguments.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  NextPrime(1000);
1009
/**/ NextProbPrime(10^50);
100000000000000000000000000000000000000000000000151
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsPrime(\ref{IsPrime} pg.\pageref{IsPrime}), 
    PrevPrime, PrevProbPrime(\ref{PrevPrime, PrevProbPrime} pg.\pageref{PrevPrime, PrevProbPrime})
\end{command} % -- end command --------------------------------

\section{NF}
\label{NF}
\begin{command} % -- COMMAND: NF ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NF(F: RINGELEM, I: IDEAL): RINGELEM
NF(V: MODULEELEM, M: MODULE): MODULEELEM
\end{Verbatim}


\subsection*{Description}

The first function returns the normal form of F with respect to I.
It also computes a Groebner basis of I if that basis has not been
computed previously.
\par 
The second function returns the normal form of V with respect to M. It
also computes a Groebner basis of M if that basis has not been
computed previously.
\par 
Currently only full reduction is computed: each monomial in
the result cannot be reduced.
(CoCoA-4 allowed setting the flag FullRed, of the panel GROEBNER,
so that only the leading term is reduced)
\par 
Currently polynomial ideals are implemented only with coeffs
in a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(z);
/**/  NF(x^2+x*y+x*z+y^2+y*z+z^2, I);
x^2 +x*y +y^2

/**/  I := ideal(z-1);
/**/  NF(x^2+x*y+x*z+y^2+y*z+z^2, I);
x^2 +x*y +y^2 +x +y +1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  DivAlg(\ref{DivAlg} pg.\pageref{DivAlg}), 
    GenRepr(\ref{GenRepr} pg.\pageref{GenRepr}), 
    IsIn(\ref{IsIn} pg.\pageref{IsIn}), 
    NR(\ref{NR} pg.\pageref{NR})
\end{command} % -- end command --------------------------------

\section{NFsAreZero [OBSOLETE]}
\label{NFsAreZero [OBSOLETE]}
\begin{command} % -- COMMAND: NFsAreZero [OBSOLETE] ------------



\subsection*{Description}

[OBSOLETE]
``\verb&NFsAreZero(L, I)&'' is the same as ``\verb&IsContained(ideal(L), I)&''.

\SeeAlso %---- SEE ALSO ----
  IsContained(\ref{IsContained} pg.\pageref{IsContained}), 
    IsIn(\ref{IsIn} pg.\pageref{IsIn}), 
    NF(\ref{NF} pg.\pageref{NF})
\end{command} % -- end command --------------------------------

\section{NmzComputation}
\label{NmzComputation}
\begin{command} % -- COMMAND: NmzComputation ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NmzComputation(Cone: RECORD): RECORD
NmzComputation(Cone: RECORD, ToCompute: LIST): RECORD
\end{Verbatim}


\subsection*{Description}

``\verb&NmzComputation&'' provides direct access to libnormaliz.  It faithfully
reflects the internal structure of the libnormaliz design.  Its first
argument should be a record representing the cone.  For the possible
input options see the Normaliz documentation.  With the second (optional)
argument one can specify what should be computed.  If it is omitted,
everything that can be computed by libnormaliz will be computed.
\par 
(sub-)list of fields of cone properties:
ModuleGenerators, Generators, ExtremeRays, VerticesOfPolyhedron,
Deg1Elements, OriginalMonoidGenerators, SupportHyperplanes,
ExcludedFaces, HilbertSeries, Multiplicity, Grading,
IsDeg1HilbertBasis, IsPointed, IsIntegrallyClosed, RecessionRank,
AffineDim, ModuleRank, Dehomogenization. 
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ Cone := record[ integral_closure := mat([[1,2],[2,1]]),
/**/                 grading := mat([[2,1]])];
/**/ NC2 := NmzComputation(Cone, ["HilbertBasis", "SupportHyperplanes", "HilbertSeries"]);
/**/ indent(NC2);

record[
  Congruences := [],
  Deg1Elements := [],
  EmbeddingDim := 2,
  Equations := [],
  ExtremeRays := [[1, 2], [2, 1]],
  Generators := [[1, 2], [2, 1]],
  Grading := [2, 1],
  HilbertBasis := [[1, 1], [1, 2], [2, 1]],
  HilbertSeries := record[DenFactors := record[RemainingFactor := 1, factors := [-t +1, -t^20 +1], multiplicities := [1, 1]], num := t^18 -t^17 +t^15 +t^10 -t^9 +t^8 +t^3 -t +1],
  IsDeg1HilbertBasis := false,
  IsInhomogeneous := false,
  IsIntegrallyClosed := false,
  IsPointed := true,
  Multiplicity := 3/20,
  Rank := 2,
  SupportHyperplanes := [[-1, 2], [2, -1]]
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NmzIntClosureToricRing(\ref{NmzIntClosureToricRing} pg.\pageref{NmzIntClosureToricRing}), 
    NmzNormalToricRing(\ref{NmzNormalToricRing} pg.\pageref{NmzNormalToricRing}), 
    NmzIntClosureMonIdeal(\ref{NmzIntClosureMonIdeal} pg.\pageref{NmzIntClosureMonIdeal}), 
    NmzEhrhartRing(\ref{NmzEhrhartRing} pg.\pageref{NmzEhrhartRing}), 
    NmzTorusInvariants(\ref{NmzTorusInvariants} pg.\pageref{NmzTorusInvariants}), 
    NmzFiniteDiagInvariants(\ref{NmzFiniteDiagInvariants} pg.\pageref{NmzFiniteDiagInvariants}), 
    NmzDiagInvariants(\ref{NmzDiagInvariants} pg.\pageref{NmzDiagInvariants}), 
    NmzIntersectionValRings(\ref{NmzIntersectionValRings} pg.\pageref{NmzIntersectionValRings}), 
    NmzSetVerbosityLevel(\ref{NmzSetVerbosityLevel} pg.\pageref{NmzSetVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{NmzDiagInvariants}
\label{NmzDiagInvariants}
\begin{command} % -- COMMAND: NmzDiagInvariants ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NmzDiagInvariants(M: MAT, N: MAT, R: Ring): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

This function computes the ring of invariants of a diagonalizable
group $D = T x G$ where T is a torus and G is a finite abelian
group, both acting diagonally on the polynomial
ring $K[X_1,...,X_n]$.
\par 
The group actions are specified by the input matrices ``\verb&M&'' and ``\verb&N&''. The
first matrix specifies the torus action, the second the action of the
finite group.  See NmzTorusInvariants or NmzFiniteDiagInvariants for more
detail.  The output is the monomial subalgebra of invariants in ``\verb&R&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/     use R::=QQ[x,y,z,w];
/**/     T := matrix([[-1,-1,2,0],[1,1,-2,-1]]);
/**/     U := matrix([[1,1,1,1,5],[1,0,2,0,7]]);
/**/     NmzDiagInvariants(T,U,R);
[x^4*y^6*z^5, x^15*y^5*z^10, x*y^19*z^10, x^26*y^4*z^15, x^37*y^3*z^20, x^48*y^2*z^25, x^59*y*z^30, x^70*z^35, y^70*z^35]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NmzComputation(\ref{NmzComputation} pg.\pageref{NmzComputation}), 
    NmzTorusInvariants(\ref{NmzTorusInvariants} pg.\pageref{NmzTorusInvariants}), 
    NmzFiniteDiagInvariants(\ref{NmzFiniteDiagInvariants} pg.\pageref{NmzFiniteDiagInvariants}), 
    NmzSetVerbosityLevel(\ref{NmzSetVerbosityLevel} pg.\pageref{NmzSetVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{NmzEhrhartRing}
\label{NmzEhrhartRing}
\begin{command} % -- COMMAND: NmzEhrhartRing ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NmzEhrhartRing(L: LIST of RINGELEM, s: RINGELEM): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

The exponent vectors of the given monomials are considered as vertices
of a lattice polytope ``\verb&P&''.  The Ehrhart ring of a (lattice)
polytope ``\verb&P&'' is the monoid algebra defined by the monoid of
lattice points in the cone over the polytope ``\verb&P&''; see the book
by Bruns and Gubeladze, \textit{Polytopes, Rings, and K-theory}, publ.
Springer 2009, pp. 228--229.
\par 
The function returns the generators of the Ehrhart ring.  It uses the
indeterminate in the second argument as auxiliary indeterminate of the
Ehrhart ring.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/     use R::=QQ[x,y,z,t];
/**/     NmzEhrhartRing([x^2,y^2,z^3],t);
[x^2*t, z^3*t, x*y*t, y^2*t]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NmzComputation(\ref{NmzComputation} pg.\pageref{NmzComputation}), 
    NmzHilbertBasis(\ref{NmzHilbertBasis} pg.\pageref{NmzHilbertBasis}), 
    NmzNormalToricRing(\ref{NmzNormalToricRing} pg.\pageref{NmzNormalToricRing}), 
    NmzIntClosureMonIdeal(\ref{NmzIntClosureMonIdeal} pg.\pageref{NmzIntClosureMonIdeal}), 
    NmzSetVerbosityLevel(\ref{NmzSetVerbosityLevel} pg.\pageref{NmzSetVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{NmzFiniteDiagInvariants}
\label{NmzFiniteDiagInvariants}
\begin{command} % -- COMMAND: NmzFiniteDiagInvariants ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NmzFiniteDiagInvariants(M: MAT, M: Ring): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

This function computes the ring of invariants of a finite abelian
group $G$ acting diagonally on the surrounding polynomial
ring $K[X_1,...,X_n]$.
\par 
The group is the direct product of cyclic groups generated by finitely
many elements $g_1,...,g_w$.  The element $g_i$ acts on the
indeterminate $X_j$ by $g_i(X_j)= l_i^{u_{ij}} X_j$ where $l_i$
is a primitive root of unity of order equal to $ord(g_i)$.
\par 
The ring of invariants is generated by all monomials satisfying the
system $u_{i1} a_1+...+u_{in}$ and congruent
to $0 mod ord(g_i) i=1,...,w$.
\par 
The input to the function is the w times (n+1) matrix
``\verb&U&'' with rows $u_{i1} ...u_{in} ord(g_i), i=1,...,w$.
The output is the monomial subalgebra of invariants
$R^G = {f in R : g_i f = f for all i=1,...,w}$.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/     use R::=QQ[x,y,z,w];
/**/     U := matrix([[1,1,1,1,3],[1,0,2,0,4]]);
/**/     NmzFiniteDiagInvariants(U,R);
[x^2*z, z^2*w, y*z^2, x^12, y^3, z^6, w^3, x^8*w, x^4*w^2, y*w^2, x^8*y, x^4*y*w, y^2*w, x^4*y^2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NmzComputation(\ref{NmzComputation} pg.\pageref{NmzComputation}), 
    NmzTorusInvariants(\ref{NmzTorusInvariants} pg.\pageref{NmzTorusInvariants}), 
    NmzDiagInvariants(\ref{NmzDiagInvariants} pg.\pageref{NmzDiagInvariants}), 
    NmzSetVerbosityLevel(\ref{NmzSetVerbosityLevel} pg.\pageref{NmzSetVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{NmzHilbertBasis}
\label{NmzHilbertBasis}
\begin{command} % -- COMMAND: NmzHilbertBasis ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NmzHilbertBasis(M: MAT): MAT
\end{Verbatim}


\subsection*{Description}

Given a matrix ``\verb&M&'', this function returns a matrix whose rows represent
the Hilbert-Gordan Basis for the monoid generated by the rows of ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/     M := matrix([[0,1],[3,1]]);
/**/     NmzHilbertBasis(M);
--the Hilbert basis of the monoid generated by the vectors [0,1] and [3,1] is...
matrix(QQ,
 [[3, 1],
  [0, 1]])
-- ... ([3,1], [0,1])

-- CAREFUL!! Different result from...
/**/     HilbertBasisKer(M);
-- which is the Hilbert basis of the monoid of the kernel of M:
[]
-- ...no elements! (except the zero-element)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  HilbertBasisKer(\ref{HilbertBasisKer} pg.\pageref{HilbertBasisKer}), 
    NmzComputation(\ref{NmzComputation} pg.\pageref{NmzComputation}), 
    NmzNormalToricRing(\ref{NmzNormalToricRing} pg.\pageref{NmzNormalToricRing}), 
    NmzIntClosureMonIdeal(\ref{NmzIntClosureMonIdeal} pg.\pageref{NmzIntClosureMonIdeal}), 
    NmzSetVerbosityLevel(\ref{NmzSetVerbosityLevel} pg.\pageref{NmzSetVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{NmzHilbertBasisKer}
\label{NmzHilbertBasisKer}
\begin{command} % -- COMMAND: NmzHilbertBasisKer ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
HilbertBasisKer(M: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns a matrix representing the Hilbert basis for the monoid
of elements with non-negative coordinates in the kernel of ``\verb&M&'',
matrix over ``\verb&ZZ&''.
\par 
NOTE: use with care!  Interface might change in the next releases to
make it compatible with ``\verb&LinKer&'' (\ref{LinKer} pg.\pageref{LinKer}) or ``\verb&HilbertBasisKer&'' (\ref{HilbertBasisKer} pg.\pageref{HilbertBasisKer}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,-2,3,4], [1, 0, 0, -1]]);
/**/  NmzHilbertBasisKer(M);
matrix(QQ,
 [[0, 3, 2, 0],
  [1, 4, 1, 1],
  [2, 5, 0, 2]])

/**/  M * transposed(It);
matrix(QQ,
 [[0, 0, 0],
  [0, 0, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  LinKerBasis(\ref{LinKerBasis} pg.\pageref{LinKerBasis}), 
    NmzHilbertBasis(\ref{NmzHilbertBasis} pg.\pageref{NmzHilbertBasis})
\end{command} % -- end command --------------------------------

\section{NmzIntClosureMonIdeal}
\label{NmzIntClosureMonIdeal}
\begin{command} % -- COMMAND: NmzIntClosureMonIdeal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NmzIntClosureMonIdeal(L: LIST of RINGELEM): LIST of RINGELEM
NmzIntClosureMonIdeal(L: LIST of RINGELEM, s: RINGELEM): LIST of RINGELEM,
\end{Verbatim}


\subsection*{Description}

Given a list ``\verb&L&'' of power-products in a ring ``\verb&R&'', the function returns the
generators of the integral closure of the ideal generated by ``\verb&L&''.

As second argument you can specify an indeterminate of the ring which is
not used in the power-products.  In this case the result is the
normalisation of its Rees algebra (or Rees ring); see Bruns and Herzog,
\textit{Cohen-Macaulay Rings}, Cambridge University Press 1998, p. 182.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/     use R::=QQ[x,y,z,t];
/**/     NmzIntClosureMonIdeal([x^2,y^2,z^3]);
-- the integral closure of the ideal generated by x^2,y^2 and z^3 is...
[y^2, x^2, x*y, z^3, y*z^2, x*z^2]
-- ...the ideal generated by y^2, x^2, x*y, z^3, y*z^2 and x*z^2
/**/     NmzIntClosureMonIdeal([x^2,y^2,z^3],t);
-- and the complete rees algebra is generated by
[z, z^3*t, y, y*z^2*t, y^2*t, x, x*z^2*t, x*y*t, x^2*t]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NmzComputation(\ref{NmzComputation} pg.\pageref{NmzComputation}), 
    NmzHilbertBasis(\ref{NmzHilbertBasis} pg.\pageref{NmzHilbertBasis}), 
    NmzNormalToricRing(\ref{NmzNormalToricRing} pg.\pageref{NmzNormalToricRing}), 
    NmzEhrhartRing(\ref{NmzEhrhartRing} pg.\pageref{NmzEhrhartRing}), 
    NmzSetVerbosityLevel(\ref{NmzSetVerbosityLevel} pg.\pageref{NmzSetVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{NmzIntClosureToricRing}
\label{NmzIntClosureToricRing}
\begin{command} % -- COMMAND: NmzIntClosureToricRing ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NmzIntClosureToricRing(L: LIST of RINGELEM): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

Given a list ``\verb&L&'' of power-products in a ring R, the function returns the
generators of the integral closure of the algebra generated by the list.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/     use R::=QQ[x,y,t];
/**/     NmzIntClosureToricRing([x^3,x^2*y,y^3]);
-- the integral closure of QQ[x^3, x^2*y, y^3] is...
[y,x]
-- ... QQ[y, x]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NmzComputation(\ref{NmzComputation} pg.\pageref{NmzComputation}), 
    NmzHilbertBasis(\ref{NmzHilbertBasis} pg.\pageref{NmzHilbertBasis}), 
    NmzNormalToricRing(\ref{NmzNormalToricRing} pg.\pageref{NmzNormalToricRing}), 
    NmzIntClosureMonIdeal(\ref{NmzIntClosureMonIdeal} pg.\pageref{NmzIntClosureMonIdeal}), 
    NmzEhrhartRing(\ref{NmzEhrhartRing} pg.\pageref{NmzEhrhartRing}), 
    NmzSetVerbosityLevel(\ref{NmzSetVerbosityLevel} pg.\pageref{NmzSetVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{NmzIntersectionValRings}
\label{NmzIntersectionValRings}
\begin{command} % -- COMMAND: NmzIntersectionValRings ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NmzIntersectionValRings(M: MAT, M: Ring): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

A discrete monomial valuation $v$ on $R=K[X_1,...,X_n]$
is determined by the values $v(X_j)$ of the indeterminates.
This function computes the subalgebra
$S = {f in R: v_i(f) >= 0, i=1,...,r}$
that is the intersection of the valuation rings of the given
valuations $v_1, ...,v_r$, \textit{i.e.} it consists of all
elements of R that have a nonnegative value for all r valuations.
It takes as input the matrix $V=(v_i(X_j))$ whose
rows correspond to the values of the indeterminates.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/     use R::=QQ[x,y,z,w];
/**/     V := matrix([[0,1,2,3],[-1,1,2,1]]);
/**/     NmzIntersectionValRings(V,R);
[y, z, w, x*y, x^2*z, x*w, x*z]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NmzComputation(\ref{NmzComputation} pg.\pageref{NmzComputation}), 
    NmzSetVerbosityLevel(\ref{NmzSetVerbosityLevel} pg.\pageref{NmzSetVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{NmzNormalToricRing}
\label{NmzNormalToricRing}
\begin{command} % -- COMMAND: NmzNormalToricRing ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NmzNormalToricRing(L: LIST of RINGELEM): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

Given a list ``\verb&L&'' of power-products in a ring R, the function returns the
generators of the normalization of the algebra generated by the list.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/     use R::=QQ[x,y,t];
-- We compute the normalization of QQ[x^3, x^2*y, y^3]
/**/     NmzNormalToricRing([x^3, x^2*y, y^3]);
[y^3, x^2*y, x^3, x*y^2]
--> answer is QQ[y^3, x^2*y, x^3, x*y^2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NmzComputation(\ref{NmzComputation} pg.\pageref{NmzComputation}), 
    NmzHilbertBasis(\ref{NmzHilbertBasis} pg.\pageref{NmzHilbertBasis}), 
    NmzIntClosureToricRing(\ref{NmzIntClosureToricRing} pg.\pageref{NmzIntClosureToricRing}), 
    NmzIntClosureMonIdeal(\ref{NmzIntClosureMonIdeal} pg.\pageref{NmzIntClosureMonIdeal}), 
    NmzSetVerbosityLevel(\ref{NmzSetVerbosityLevel} pg.\pageref{NmzSetVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{NmzSetVerbosityLevel}
\label{NmzSetVerbosityLevel}
\begin{command} % -- COMMAND: NmzSetVerbosityLevel ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NmzSetVerbosityLevel(v: INT)
\end{Verbatim}


\subsection*{Description}

Set the verbosity level for the external library Normaliz: level 0
means no "verbosity", any positive value activates "verbosity".
\par 
NOTE: this is completely independent of CoCoA's own verbosity level!
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  NmzSetVerbosityLevel(1);
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  SetVerbosityLevel(\ref{SetVerbosityLevel} pg.\pageref{SetVerbosityLevel}), 
    NmzVerbosityLevel(\ref{NmzVerbosityLevel} pg.\pageref{NmzVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{NmzTorusInvariants}
\label{NmzTorusInvariants}
\begin{command} % -- COMMAND: NmzTorusInvariants ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NmzTorusInvariants(M: MAT, R: Ring): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

Let ``\verb&T=(K^*)^r&'' be the r-dimensional torus acting on the polynomial ring
``\verb&R=K[X_1,...,X_n]&'' diagonally.  Such an action can be described as follows:
there are integers $a_ij, i=1,...,r, j=1,...,n$ such that $(l_1,...,l_r)$ in ``\verb&T&''
acts by the substitution  $X_j$ maps to $l_1^{a_{1j}} * ... * l_r^{a_{rj}} * Xj$ for j=1,...,n.

The function takes the matrix $M = (a_{ij})$ and the ring ``\verb&R&'' as input.
It computes the ring of invariants $R^T = {f in R | lf = f for all l in T}$.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/     use R::=QQ[x,y,z,w];
/**/     T := matrix([[-1,-1,2,0],[1,1,-2,-1]]);
/**/     NmzTorusInvariants(T,R);
[x^2*z, x*y*z, y^2*z]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NmzComputation(\ref{NmzComputation} pg.\pageref{NmzComputation}), 
    NmzDiagInvariants(\ref{NmzDiagInvariants} pg.\pageref{NmzDiagInvariants}), 
    NmzFiniteDiagInvariants(\ref{NmzFiniteDiagInvariants} pg.\pageref{NmzFiniteDiagInvariants}), 
    NmzSetVerbosityLevel(\ref{NmzSetVerbosityLevel} pg.\pageref{NmzSetVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{NmzVerbosityLevel}
\label{NmzVerbosityLevel}
\begin{command} % -- COMMAND: NmzVerbosityLevel ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NmzVerbosityLevel(): INT
\end{Verbatim}


\subsection*{Description}

Returns the verbosity level for the external library Normaliz:
value is 0 or 1 according as Normaliz verbosity was inactive or active.
\par 
NOTE: this is completely independent of CoCoA's own verbosity level!
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  NmzVerbosityLevel();
0
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  VerbosityLevel(\ref{VerbosityLevel} pg.\pageref{VerbosityLevel}), 
    NmzSetVerbosityLevel(\ref{NmzSetVerbosityLevel} pg.\pageref{NmzSetVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{NonZero}
\label{NonZero}
\begin{command} % -- COMMAND: NonZero ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NonZero(L: LIST|MODULEELEM): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the list obtained by removing the zeroes from L.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  NonZero([0,0,3, ideal(y),0]);
[3, ideal(y)]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  FirstNonZero(\ref{FirstNonZero} pg.\pageref{FirstNonZero}), 
    FirstNonZeroPosn(\ref{FirstNonZeroPosn} pg.\pageref{FirstNonZeroPosn}), 
    IsZero(\ref{IsZero} pg.\pageref{IsZero})
\end{command} % -- end command --------------------------------

\section{not}
\label{not}
\begin{command} % -- COMMAND: not ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
not(A: BOOL): BOOL
\end{Verbatim}


\subsection*{Description}

This function negates a boolean: \textit{i.e.} if ``\verb&A&'' gives ``\verb&true&''
then ``\verb&not(A)&'' gives ``\verb&false&'', and vice versa.
\par 
NOTE: from CoCoA-5.1 ``\verb&not&'' is a function, so its argument must be
between round brackets!
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  [n in 1..10 | not(IsPrime(n))];
[1,4,6,8,9]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  and(\ref{and} pg.\pageref{and}), 
    or(\ref{or} pg.\pageref{or})
\end{command} % -- end command --------------------------------

\section{NR}
\label{NR}
\begin{command} % -- COMMAND: NR ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NR(X: RINGELEM, L: LIST of RINGELEM): RINGELEM
NR(X: MODULEELEM, L: LIST of MODULEELEM): MODULEELEM
\end{Verbatim}


\subsection*{Description}

This function returns the normal remainder of ``\verb&X&'' with respect to ``\verb&L&'',
\textit{i.e.}, it returns the remainder from the division algorithm.  To get
both the quotients and the remainder, use ``\verb&DivAlg&'' (\ref{DivAlg} pg.\pageref{DivAlg}).
\par 
NOTE: this function does not compute a Groebner basis.  If the
list ``\verb&L&'' does not form a Groebner basis then the remainder may
not be zero even if ``\verb&X&'' is in the ideal or module generated by ``\verb&L&''
(use ``\verb&NF&'' (\ref{NF} pg.\pageref{NF}) instead, or possibly ``\verb&GenRepr&'' (\ref{GenRepr} pg.\pageref{GenRepr})).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  F := x^2*y +x*y^2 +y^2;
/**/  NR(F, [x*y-1, y^2-1]);
x +y +1

// NOT YET IMPLEMENTED for MODULEELEM
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  DivAlg(\ref{DivAlg} pg.\pageref{DivAlg}), 
    GenRepr(\ref{GenRepr} pg.\pageref{GenRepr}), 
    NF(\ref{NF} pg.\pageref{NF})
\end{command} % -- end command --------------------------------

\section{num}
\label{num}
\begin{command} % -- COMMAND: num ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
num(N: INT): INT
num(N: RAT): INT
num(N: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the numerator of ``\verb&N&''.
\par 
The OBSOLETE fragile syntax in CoCoA 4 ``\verb&N.Num&'' and ``\verb&N.Den&'' is no
longer supported.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  num(3);
3

/**/  P ::= QQ[x,y];
/**/  F := NewFractionField(P);
/**/  use F;
/**/  num(x/(x+y));
x
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  den(\ref{den} pg.\pageref{den})
\end{command} % -- end command --------------------------------

\section{NumBChambers}
\label{NumBChambers}
\begin{command} % -- COMMAND: NumBChambers ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NumBChambers(A: LIST): INT 
\end{Verbatim}


\subsection*{Description}

This function returns the number of bounded chambers from the list A of hyperplanes in the arrangement.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, x-y, y];
/**/ NumBChambers(A);
0
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NumChambers(\ref{NumChambers} pg.\pageref{NumChambers})
\end{command} % -- end command --------------------------------

\section{NumChambers}
\label{NumChambers}
\begin{command} % -- COMMAND: NumChambers ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NumChambers(A: LIST): INT 
\end{Verbatim}


\subsection*{Description}

This function returns the number of chambers from the list A of hyperplanes in the arrangement.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, x-y, y];
/**/ NumChambers(A);
6
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NumBChambers(\ref{NumBChambers} pg.\pageref{NumBChambers})
\end{command} % -- end command --------------------------------

\section{NumCols}
\label{NumCols}
\begin{command} % -- COMMAND: NumCols ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NumCols(M: MAT): INT
\end{Verbatim}


\subsection*{Description}

This function returns the number of columns in a matrix.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,2,3], [4,5,6]]);
/**/  NumCols(M);
3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  matrix(\ref{matrix} pg.\pageref{matrix}), 
    NumRows(\ref{NumRows} pg.\pageref{NumRows})
\end{command} % -- end command --------------------------------

\section{NumCompts}
\label{NumCompts}
\begin{command} % -- COMMAND: NumCompts ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NumCompts(X: MODULEELEM|MODULE): INT
\end{Verbatim}


\subsection*{Description}

If ``\verb&X&'' is a MODULEELEM, it returns the number of components of ``\verb&X&''.
If ``\verb&X&'' is a MODULE, it returns the rank of the free module in which ``\verb&X&'' is
defined.
\par 
This function used to be called ``\verb&NumComps&'' in CoCoA-4.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  R2 := NewFreeModule(R, 3);
/**/  M := SubmoduleRows(R2, matrix(R, mat([[x,0,y], [x^2+y^2,x^2,3]])));
/**/  NumCompts(M);
3
/**/  NumCompts(gens(M)[1]);
3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  len(\ref{len} pg.\pageref{len})
\end{command} % -- end command --------------------------------

\section{NumGens}
\label{NumGens}
\begin{command} % -- COMMAND: NumGens ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NumGens(I: IDEAL): INT
\end{Verbatim}


\subsection*{Description}

This function returns the number of generators of``\verb&I&''.
This is more direct, therefore efficient, than writing ``\verb&len(gens(I))&'',
because it does not create the temporary list ``\verb&gens(I)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(indets(R))^40;
/**/  NumGens(I);
861
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  len(\ref{len} pg.\pageref{len})
\end{command} % -- end command --------------------------------

\section{NumIndets}
\label{NumIndets}
\begin{command} % -- COMMAND: NumIndets ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NumIndets(R: RING): INT
\end{Verbatim}


\subsection*{Description}

This function returns the number of indeterminates of the ring ``\verb&R&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  S ::= QQ[x,y];
/**/  R ::= QQ[x,y,z];
/**/  NumIndets(R);
3
/**/  NumIndets(S);
2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  indet(\ref{indet} pg.\pageref{indet}), 
    IndetSubscripts(\ref{IndetSubscripts} pg.\pageref{IndetSubscripts}), 
    IndetIndex(\ref{IndetIndex} pg.\pageref{IndetIndex}), 
    IndetName(\ref{IndetName} pg.\pageref{IndetName}), 
    indets(\ref{indets} pg.\pageref{indets})
\end{command} % -- end command --------------------------------

\section{NumPartitions}
\label{NumPartitions}
\begin{command} % -- COMMAND: NumPartitions ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NumPartitions(N: INT): INT
\end{Verbatim}


\subsection*{Description}

This function returns the number of partitions of a non-negative integer,
\textit{i.e.} the number of distinct ways of writing ``\verb&N&'' as a sum of positive integers.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  NumPartitions(2); -- 2 and 1+1
2
/**/  NumPartitions(5);
7
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{NumRealRoots}
\label{NumRealRoots}
\begin{command} % -- COMMAND: NumRealRoots ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NumRealRoots(F: RINGELEM): INT
\end{Verbatim}


\subsection*{Description}

This function returns the number of real roots the polynomial ``\verb&F&'' has.
The coefficients of ``\verb&F&'' must be rational.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x];
/**/  NumRealRoots(x^10 - (10^10*x-1)^2);
4
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  SturmSeq(\ref{SturmSeq} pg.\pageref{SturmSeq}), 
    RealRoots(\ref{RealRoots} pg.\pageref{RealRoots})
\end{command} % -- end command --------------------------------

\section{NumRows}
\label{NumRows}
\begin{command} % -- COMMAND: NumRows ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NumRows(M: MAT): INT
\end{Verbatim}


\subsection*{Description}

This function returns the number of rows in a matrix.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,2,3], [4,5,6]]);
/**/  NumRows(M);
2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  matrix(\ref{matrix} pg.\pageref{matrix}), 
    NumCols(\ref{NumCols} pg.\pageref{NumCols})
\end{command} % -- end command --------------------------------

\section{NumTerms}
\label{NumTerms}
\begin{command} % -- COMMAND: NumTerms ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
NumTerms(F: RINGELEM): INT
\end{Verbatim}


\subsection*{Description}

This function returns the number of terms in a polynomial.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  NumTerms((x+y+z)^5) = binomial(3+5-1, 5);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  support(\ref{support} pg.\pageref{support}), 
    coefficients(\ref{coefficients} pg.\pageref{coefficients}), 
    monomials(\ref{monomials} pg.\pageref{monomials}), 
    Tutorial: polynomials(\ref{Tutorial: polynomials} pg.\pageref{Tutorial: polynomials}), 
    len(\ref{len} pg.\pageref{len})
\end{command} % -- end command --------------------------------

\chapter{O}  %----=== CHAPTER LETTER ===----
\label{O}

\section{one}
\label{one}
\begin{command} % -- COMMAND: one ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
one(R: RING): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the multiplicative identity of a ring.
For when you want to force the integer ``\verb&1&'' to be a RINGELEM.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ P ::= ZZ/(101)[x,y,z];
/**/ N := 1;  Print N, " of type ",  type(N);
1 of type INT
/**/ N := one(P);  Print N, " of type ",  type(N);
1 of type RINGELEM
/**/ N := 300*1;  Print N, " of type ",  type(N);
300 of type INT
/**/ N := 300*one(P);  Print N, " of type ",  type(N);
-3 of type RINGELEM
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  zero(\ref{zero} pg.\pageref{zero})
\end{command} % -- end command --------------------------------

\section{OpenIFile}
\label{OpenIFile}
\begin{command} % -- COMMAND: OpenIFile ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
OpenIFile(S: STRING): ISTREAM
\end{Verbatim}


\subsection*{Description}

This function opens the file with name ``\verb&S&'' for input.
Input from that file can then be read with ``\verb&GetLine&'' (\ref{GetLine} pg.\pageref{GetLine}).
\par 
NOTE: it is better to use ``\verb&source&'' (\ref{source} pg.\pageref{source}) to read CoCoA commands from a file.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  D := OpenOFile("my-test");  -- open "my-test" for output from CoCoA
/**/  Print "hello world\nhello!!!" On D;   -- print string into "mytest"
/**/  Close(D);
/**/  D := OpenIFile("my-test");  -- open "my-test" for input to CoCoA
/**/  GetLine(D);
hello world
/**/  GetLine(D);
hello!!!
/**/  Close(D);
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  close(\ref{close} pg.\pageref{close}), 
    Introduction to IO(\ref{Introduction to IO} pg.\pageref{Introduction to IO}), 
    OpenOFile(\ref{OpenOFile} pg.\pageref{OpenOFile}), 
    OpenIString(\ref{OpenIString} pg.\pageref{OpenIString}), 
    OpenOString(\ref{OpenOString} pg.\pageref{OpenOString}), 
    OpenSocket(\ref{OpenSocket} pg.\pageref{OpenSocket}), 
    source(\ref{source} pg.\pageref{source})
\end{command} % -- end command --------------------------------

\section{OpenIString}
\label{OpenIString}
\begin{command} % -- COMMAND: OpenIString ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
OpenIString(S: STRING): ISTREAM
OpenOString(S: STRING): OSTREAM
\end{Verbatim}


\subsection*{Description}

This function open strings for input.
``\verb&OpenIString&'' is used to read input from the
string ``\verb&S&'' with the help of ``\verb&GetLine&'' (\ref{GetLine} pg.\pageref{GetLine}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  S := "hello world\n1!\n2!\n3!";
/**/  D := OpenIString(S);
/**/  GetLine(D);
hello world
/**/  GetLine(D);
1!
/**/  GetLine(D);
2!
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  close(\ref{close} pg.\pageref{close}), 
    Introduction to IO(\ref{Introduction to IO} pg.\pageref{Introduction to IO}), 
    OpenOString(\ref{OpenOString} pg.\pageref{OpenOString}), 
    OpenIFile(\ref{OpenIFile} pg.\pageref{OpenIFile}), 
    OpenOFile(\ref{OpenOFile} pg.\pageref{OpenOFile}), 
    source(\ref{source} pg.\pageref{source}), 
    sprint(\ref{sprint} pg.\pageref{sprint})
\end{command} % -- end command --------------------------------

\section{OpenLog}
\label{OpenLog}
\begin{command} % -- COMMAND: OpenLog ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
OpenLog(D: DEVICE)
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function opens the output device D and starts to record the
output from a CoCoA session on D.  The ``\verb&CloseLog&'' (\ref{CloseLog} pg.\pageref{CloseLog}) closes the
device D and stops recording the CoCoA session on D.
\par 
At present the choices for the device D are an output file (see
``\verb&OpenOFile&'' (\ref{OpenOFile} pg.\pageref{OpenOFile})) or an output string (see ``\verb&OpenOString&'' (\ref{OpenOString} pg.\pageref{OpenOString})).  Several output
devices may be open at a time.  If the panel option ``\verb&Echo&'' is set to
``\verb&true&'', both the input and output of the CoCoA session are logged;
otherwise, just the output is logged.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  D := OpenOFile("MySession");
  OpenLog(D);
  1+1;
2
-------------------------------
  G := 1;
  Set Echo;
  2+2;
2 + 2
4
-------------------------------
  F := 2;
F := 2
  CloseLog(D);
CloseLog(D)
  UnSet Echo;
SET(Echo, false)

-- The contents of "MySession":
2
-------------------------------
2 + 2
4
-------------------------------
F := 2
CloseLog(D)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Introduction to IO(\ref{Introduction to IO} pg.\pageref{Introduction to IO}), 
    OpenIFile(\ref{OpenIFile} pg.\pageref{OpenIFile}), 
    OpenOFile(\ref{OpenOFile} pg.\pageref{OpenOFile}), 
    OpenIString(\ref{OpenIString} pg.\pageref{OpenIString}), 
    OpenOString(\ref{OpenOString} pg.\pageref{OpenOString})
\end{command} % -- end command --------------------------------

\section{OpenOFile}
\label{OpenOFile}
\begin{command} % -- COMMAND: OpenOFile ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
OpenOFile(S: STRING): OSTREAM
OpenOFile(S: STRING,"w" or "W"): OSTREAM
\end{Verbatim}


\subsection*{Description}

This function opens the file with name ``\verb&S&''---creating it if it
does not already exist---for output.
It immediately erases the file with name ``\verb&S&''.  Then the function
``\verb&print on&'' (\ref{print on} pg.\pageref{print on}) is then used for appending output to ``\verb&S&''
until it is closed.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  file := OpenOFile("my-test");  -- open "my-test" for output from CoCoA
/**/  print "hello world! " on file; -- print string into "my-test"
/**/  print " test" on file;         -- append to the file "my-test"
/**/  close(file);  -- close the file
/**/  file := OpenOFile("my-test");  -- clear "my-test" and re-open it
/**/  print "goodbye" on file; -- "mytest" now consists only of the string "goodbye"
/**/  close(file);
/**/  file := OpenIFile("my-test");  -- open "my-test" for input
/**/  GetLine(file);
goodbye
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  close(\ref{close} pg.\pageref{close}), 
    Introduction to IO(\ref{Introduction to IO} pg.\pageref{Introduction to IO}), 
    OpenIFile(\ref{OpenIFile} pg.\pageref{OpenIFile}), 
    OpenIString(\ref{OpenIString} pg.\pageref{OpenIString}), 
    OpenOString(\ref{OpenOString} pg.\pageref{OpenOString}), 
    source(\ref{source} pg.\pageref{source})
\end{command} % -- end command --------------------------------

\section{OpenOString}
\label{OpenOString}
\begin{command} % -- COMMAND: OpenOString ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
OpenOString(): OSTREAM
\end{Verbatim}


\subsection*{Description}

This function opens strings for output.  ``\verb&OpenOString&'' is used to write to a
string with the help of ``\verb&print on&'' (\ref{print on} pg.\pageref{print on}).  use ``\verb&close&'' (\ref{close} pg.\pageref{close}) to obtain
the string of characters "printed on" the ostream.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  str := OpenOString();  -- open a string for output from CoCoA
/**/  L := [1,2,3]; -- a list
/**/  print L on str;  -- print to str
/**/  str;
<out-stream>
-------------------------------
/**/  close(str);  -- gives a string containing the output sent to str
[1, 2, 3]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  close(\ref{close} pg.\pageref{close}), 
    Introduction to IO(\ref{Introduction to IO} pg.\pageref{Introduction to IO}), 
    OpenIFile(\ref{OpenIFile} pg.\pageref{OpenIFile}), 
    OpenOFile(\ref{OpenOFile} pg.\pageref{OpenOFile}), 
    OpenIString(\ref{OpenIString} pg.\pageref{OpenIString}), 
    source(\ref{source} pg.\pageref{source}), 
    sprint(\ref{sprint} pg.\pageref{sprint})
\end{command} % -- end command --------------------------------

\section{OpenSocket}
\label{OpenSocket}
\begin{command} % -- COMMAND: OpenSocket ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
OpenSocket(HostName: STRING, PortNum: INT): RECORD
\end{Verbatim}


\subsection*{Description}

This function opens a client socket (I/O) connection to port ``\verb&PortNum&''
on the computer ``\verb&HostName&''; to make a connection to the same computer
CoCoA is running on specify the host name ``\verb&localhost&''.
\par 
The result is a ``\verb&RECORD&'' where the field ``\verb&send&'' is an ``\verb&out-stream&'',
and the field ``\verb&recv&'' is an ``\verb&in-stream&''.  The expectation is that a
\textit{remote procedure call} is sent on ``\verb&send&'', and the result is read from
``\verb&recv&'' using the function ``\verb&GetLine&'' (\ref{GetLine} pg.\pageref{GetLine}).
\par 
The first arg ``\verb&HostName&'' is a string containing the name of the
computer which is waiting for a connection; the second arg ``\verb&PortNum&''
is the \textit{port number} at which the server is waiting.
\par 
An error will be signalled if the computer ``\verb&HostName&'' is not waiting
for a connection to port ``\verb&PortNum&''.  The obsolete CoCoAServer waits for
a connection on the port number 49344 (which is ``\verb&c0c0&'' in hexadecimal).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ -->  assuming an echo server is waiting on port 50000...
/**/ IOPair := OpenSocket("localhost", 50000);
/**/ PrintLn 123+456 On IOPair.send;
/**/ str := GetLine(IOPair.recv);
/**/ str;
579
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Introduction to IO(\ref{Introduction to IO} pg.\pageref{Introduction to IO}), 
    OpenIFile(\ref{OpenIFile} pg.\pageref{OpenIFile}), 
    OpenOFile(\ref{OpenOFile} pg.\pageref{OpenOFile}), 
    OpenIString(\ref{OpenIString} pg.\pageref{OpenIString}), 
    OpenOString(\ref{OpenOString} pg.\pageref{OpenOString})
\end{command} % -- end command --------------------------------

\section{Option [OBSOLETE]}
\label{Option [OBSOLETE]}
\begin{command} % -- COMMAND: Option [OBSOLETE] ------------



\subsection*{Description}

[OBSOLETE]

\end{command} % -- end command --------------------------------

\section{or}
\label{or}
\begin{command} % -- COMMAND: or ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
A or B
where A, B: BOOL; return BOOL
\end{Verbatim}


\subsection*{Description}

This operator represents the logical disjunction of ``\verb&A&'' and ``\verb&B&''.
CoCoA first evaluates ``\verb&A&''; if that gives ``\verb&true&'' then the result is
``\verb&true&'', and ``\verb&B&'' is not evaluated.  Otherwise, if ``\verb&A&'' gives
``\verb&false&'' then ``\verb&B&'' is evaluated, and its value is the final result.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Define IsUnsuitable(X)
/**/    Return X < 0 or FloorSqrt(X) >= 2^16;
/**/  EndDefine;
/**/  IsUnsuitable(-9);
true
/**/  IsUnsuitable(9);
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  and(\ref{and} pg.\pageref{and}), 
    not(\ref{not} pg.\pageref{not})
\end{command} % -- end command --------------------------------

\section{Order Comparison Operators}
\label{Order Comparison Operators}
\begin{command} % -- COMMAND: Order Comparison Operators ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
A < B       less than
A > B       greater than
A <= B      less than or equal
A >= B      greater than or equal
  return BOOL
\end{Verbatim}


\subsection*{Description}

These ordering operators perform the corresponding comparison between
``\verb&A&'' and ``\verb&B&''.  They will signal an error if ``\verb&A&'' and ``\verb&B&'' are not comparable
(\textit{e.g.} of different types, or if the type does not have a natural
ordering).  Polynomials which are just power-products are ordered using
the power-product ordering.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ 1 > 1/2;
true
/**/  "abc" < "def"; -- lex ordering for strings
true
/**/  use QQ[x,y];
/**/  x < y;   -- x and y are viewed as power-products
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Equality Operator(\ref{Equality Operator} pg.\pageref{Equality Operator}), 
    operators, shortcuts(\ref{operators, shortcuts} pg.\pageref{operators, shortcuts})
\end{command} % -- end command --------------------------------

\section{OrdMat}
\label{OrdMat}
\begin{command} % -- COMMAND: OrdMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
OrdMat(R: RING): MAT
\end{Verbatim}


\subsection*{Description}

This function returns a matrix which describes the term-ordering
of the ring ``\verb&R&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use S ::= QQ[x,y,z];
/**/  M := mat([ [1,2,3], [3,4,5], [0,0,1]]);
/**/  P := NewPolyRing(CoeffRing(S), IndetSymbols(S), M, 2);
/**/  GradingDim(P);
2
/**/  OrdMat(P);
matrix(QQ,
 [[1, 2, 3],
  [3, 4, 5],
  [0, 0, 1]])

/**/  GradingDim(S);
1
/**/  OrdMat(S);
matrix(QQ,
 [[1, 1, 1],
  [0, 0, -1],
  [0, -1, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing}), 
    MakeTermOrdMat(\ref{MakeTermOrdMat} pg.\pageref{MakeTermOrdMat}), 
    GradingDim(\ref{GradingDim} pg.\pageref{GradingDim}), 
    StdDegLexMat(\ref{StdDegLexMat} pg.\pageref{StdDegLexMat}), 
    StdDegRevLexMat(\ref{StdDegRevLexMat} pg.\pageref{StdDegRevLexMat}), 
    LexMat(\ref{LexMat} pg.\pageref{LexMat}), 
    RevLexMat(\ref{RevLexMat} pg.\pageref{RevLexMat}), 
    XelMat(\ref{XelMat} pg.\pageref{XelMat}), 
    elim(\ref{elim} pg.\pageref{elim}), 
    Term Orderings(\ref{Term Orderings} pg.\pageref{Term Orderings})
\end{command} % -- end command --------------------------------

\section{OrlikTeraoIdeal}
\label{OrlikTeraoIdeal}
\begin{command} % -- COMMAND: OrlikTeraoIdeal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
OrlikTeraoIdeal(A: LIST): IDEAL 
\end{Verbatim}


\subsection*{Description}

This function returns the Orlik-Terao ideal of the list A of hyperplanes of an arrangement.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, y, x-y];
/**/ OrlikTeraoIdeal(A);
ideal(y[1]*y[2] +y[1]*y[3] -y[2]*y[3])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  SolomonTeraoIdeal(\ref{SolomonTeraoIdeal} pg.\pageref{SolomonTeraoIdeal}), 
    ArtinianOrlikTeraoIdeal(\ref{ArtinianOrlikTeraoIdeal} pg.\pageref{ArtinianOrlikTeraoIdeal})
\end{command} % -- end command --------------------------------

\chapter{P}  %----=== CHAPTER LETTER ===----
\label{P}

\section{package}
\label{package}
\begin{command} % -- COMMAND: package ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
package PkgName: STRING);
\end{Verbatim}


\subsection*{Description}

This is for more advanced use of CoCoA-5, when you have several
functions for closely related operations.
\par 
We recommend putting all functions belonging together in a package
into a single file (whose name should indicate the purpose of the
package).  Inside the file, at the start write ``\verb&package&''
followed by the package name (usu. the same as as the file name);
at the end of the file put ``\verb&EndPackage;&''.
\par 
See the entry ``\verb&First Example of a Package&'' (\ref{First Example of a Package} pg.\pageref{First Example of a Package}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ package $demo;
/**/   export MyFunc;
/**/   define MyFunc(N) return N+1; enddefine;
/**/ EndPackage;
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CoCoA Packages(\ref{CoCoA Packages} pg.\pageref{CoCoA Packages}), 
    export(\ref{export} pg.\pageref{export}), 
    First Example of a Package(\ref{First Example of a Package} pg.\pageref{First Example of a Package})
\end{command} % -- end command --------------------------------

\section{PackageOf}
\label{PackageOf}
\begin{command} % -- COMMAND: PackageOf ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PackageOf(S: STRING): STRING
\end{Verbatim}


\subsection*{Description}

If ``\verb&S&'' contains the name of an identifier defined and exported from
a package, it returns the name of that package; otherwise it returns a
string saying it is not a package-exported name.
\par 
Consult also the documentation for the function ``\verb&starting&'' (\ref{starting} pg.\pageref{starting}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ PackageOf("starting");
$coclib
/**/ PackageOf("deg");
<not a package-exported name>
/**/ starting("star");
[record[IsExported := true, name := "$coclib.starting"]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  starting(\ref{starting} pg.\pageref{starting}), 
    print(\ref{print} pg.\pageref{print}), 
    describe(\ref{describe} pg.\pageref{describe}), 
    Introduction to Packages(\ref{Introduction to Packages} pg.\pageref{Introduction to Packages}), 
    Supported Packages(\ref{Supported Packages} pg.\pageref{Supported Packages})
\end{command} % -- end command --------------------------------

\section{packages}
\label{packages}
\begin{command} % -- COMMAND: packages ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
packages(): LIST of STRING
\end{Verbatim}


\subsection*{Description}

This function returns the names of the loaded packages as a list of
strings.
\par 
The old CoCoA-4 names ``\verb&$user&'' and ``\verb&$builtin&'' are no
longer used.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  packages();
["$BackwardCompatible", "$BringIn", (...) ]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Introduction to Packages(\ref{Introduction to Packages} pg.\pageref{Introduction to Packages}), 
    Supported Packages(\ref{Supported Packages} pg.\pageref{Supported Packages})
\end{command} % -- end command --------------------------------

\section{panel [OBSOLETE]}
\label{panel [OBSOLETE]}
\begin{command} % -- COMMAND: panel [OBSOLETE] ------------



\subsection*{Description}

[OBSOLETE]

\end{command} % -- end command --------------------------------

\section{panels [OBSOLETE]}
\label{panels [OBSOLETE]}
\begin{command} % -- COMMAND: panels [OBSOLETE] ------------



\subsection*{Description}

[OBSOLETE]

\end{command} % -- end command --------------------------------

\section{partitions}
\label{partitions}
\begin{command} % -- COMMAND: partitions ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
partitions(N: INT): LIST
\end{Verbatim}


\subsection*{Description}

These function returns all integer partitions of N, positive integer
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  partitions(3);
[[3], [1, 2], [1, 1, 1]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  subsets(\ref{subsets} pg.\pageref{subsets}), 
    tuples(\ref{tuples} pg.\pageref{tuples})
\end{command} % -- end command --------------------------------

\section{permutations}
\label{permutations}
\begin{command} % -- COMMAND: permutations ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
permutations(L: LIST): LIST
\end{Verbatim}


\subsection*{Description}

This function computes all permutations of the entries of a list (set).
If ``\verb&L&'' has repeated elements it will return repeated elements.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  permutations(3..5);
[[3, 4, 5], [3, 5, 4], [4, 3, 5], [4, 5, 3], [5, 3, 4], [5, 4, 3]]

/**/  permutations([2, 2, 5]);
[[2, 2, 5], [2, 5, 2], [2, 2, 5], [2, 5, 2], [5, 2, 2], [5, 2, 2]]

/**/  MakeSet(permutations([2, 2, 5]));
[[2, 2, 5], [2, 5, 2], [5, 2, 2]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  subsets(\ref{subsets} pg.\pageref{subsets}), 
    tuples(\ref{tuples} pg.\pageref{tuples})
\end{command} % -- end command --------------------------------

\section{PerpIdealOfForm}
\label{PerpIdealOfForm}
\begin{command} % -- COMMAND: PerpIdealOfForm ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PerpIdealOfForm(F: RINGELEM): IDEAL
\end{Verbatim}


\subsection*{Description}

Thanks to Enrico Carlini.
\par 
Given a form ``\verb&F&'' computes the ideal of derivations killing it.
\par 
For the sake of simplicity Forms/Polynomials and Derivations live in
the same ring, the distinction between them is purely formal.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  PerpIdealOfForm(x^3+x*y*z);
ideal(z^2, y^2, x^2 -6*y*z)

/**/  HilbertFn(R/It);
H(0) = 1
H(1) = 3
H(2) = 3
H(3) = 1
H(t) = 0   for t >= 4
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  InverseSystem(\ref{InverseSystem} pg.\pageref{InverseSystem}), 
    DerivationAction(\ref{DerivationAction} pg.\pageref{DerivationAction})
\end{command} % -- end command --------------------------------

\section{pfaffian}
\label{pfaffian}
\begin{command} % -- COMMAND: pfaffian ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
pfaffian(M: MAT): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the Pfaffian of M.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  pfaffian(mat([[0,y],[-y,0]]));
y
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  det(\ref{det} pg.\pageref{det})
\end{command} % -- end command --------------------------------

\section{PkgName}
\label{PkgName}
\begin{command} % -- COMMAND: PkgName ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PkgName(): STRING
S.PkgName(): STRING

where S is the identifier or alias for a package.
\end{Verbatim}


\subsection*{Description}

This function returns the (long) name of a package.  The first form
returns ``\verb&$coclib&'' and the second returns the name of the package
whose name or alias is S.  This function is useful as a shorthand,
when S is an alias, for the full name of a package.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
  GB.PkgName();
$gb
-------------------------------
  $gb.PkgName();
$gb
-------------------------------
  PkgName();
$coclib
-------------------------------
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{PlayCantStop}
\label{PlayCantStop}
\begin{command} % -- COMMAND: PlayCantStop ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PlayCantStop(Player1: STRING, Player2: STRING, ...)
\end{Verbatim}


\subsection*{Description}

This is an interactive game!  (see ``\verb&GetLine&'' (\ref{GetLine} pg.\pageref{GetLine})).
\par 
Rules at ``\verb&https://boardgamegeek.com/boardgame/41/cant-stop&''
In brief, this is actually in the \textbf{mountain} scenario:
you have 3 sherpas which are climbing a mountain.
After each 4-die roll, if you can, you move your sherpas up.
Then you decide if you stop and estabish your base camps for following turns, 
or if you chance your luck, and roll the 4 dice again and again.
If you cannot move, your sherpas fall off the mountain, and that ends
your turn.
\par 
The game can be played with human players and/or computer players.
The computer players are:
``\verb&ComputerTest&'': stupid strategy;
``\verb&ComputerAnna1&'': close to 7 and 50% strategy;
``\verb&ComputerAnna&'': more human-like choices ;-).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
--  PlayCantStop("Dave", "Diane", "Joy", "Cole");
--  4 humans
--  PlayCantStop("ComputerAnna", "ComputerTest", "Anna");
--  2 computer2 + 1 human
--  PlayCantStop("ComputerAnna", "ComputerTest", "ComputerAnna1");
--  3 computers ;-)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  SleepFor(\ref{SleepFor} pg.\pageref{SleepFor}), 
    GetLine(\ref{GetLine} pg.\pageref{GetLine})
\end{command} % -- end command --------------------------------

\section{PlotPoints}
\label{PlotPoints}
\begin{command} % -- COMMAND: PlotPoints ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PlotPoints(L: LIST of points)
\end{Verbatim}


\subsection*{Description}

This function outputs the coordinates of the points (with two
components) to a file called "CoCoAPlot".
See ``\verb&PlotPointsOn&'' (\ref{PlotPointsOn} pg.\pageref{PlotPointsOn}) for outputting to another file.
\par 
This result can be plotted using your preferred plotting program.
For example, start "gnuplot" and then give it the command
\begin{verbatim}  plot "CoCoAPlot"\end{verbatim}
to see the plot.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  PlotPoints([ [X, X^2-X+14] | X in -10..10]);
Plotting points...100%
21 plotted points have been placed in the file CoCoAPlot
\end{Verbatim}



\SeeAlso %---- SEE ALSO ----
  ImplicitPlot(\ref{ImplicitPlot} pg.\pageref{ImplicitPlot}), 
    PlotPointsOn(\ref{PlotPointsOn} pg.\pageref{PlotPointsOn})
\end{command} % -- end command --------------------------------

\section{PlotPointsOn}
\label{PlotPointsOn}
\begin{command} % -- COMMAND: PlotPointsOn ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PlotPointsOn(L: LIST of points, S: STRING)
\end{Verbatim}


\subsection*{Description}

This function is the same as ``\verb&PlotPoints&'' (\ref{PlotPoints} pg.\pageref{PlotPoints}) with a second
argument giving the name of the file to print on.
\par 
NOTE: the last argument is a ``\verb&STRING&'', the name of the file, and not
an ``\verb&OSTREAM&'', as for ``\verb&print on&'' (\ref{print on} pg.\pageref{print on}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  PlotPointsOn([ [1/(X+1/2), X^2-X+14] | X in -10..10], "PLOT-points");
Plotting points...100%
21 plotted points have been placed in the file points

/**/  use QQ[x,y];
/**/  ImplicitPlotOn(x^2*y -(59/4)*x^2 +2*x -1, [-3,3], [0,250], "PLOT-curve");
Plotting points...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
735 plotted points have been placed in the file "PLOT-curve"
\end{Verbatim}

After having produced the plot files using CoCoA,
start "gnuplot" and then give it the following commands:
\begin{verbatim}  plot "PLOT-curve"
  replot "points"
\end{verbatim}

\SeeAlso %---- SEE ALSO ----
  ImplicitPlot(\ref{ImplicitPlot} pg.\pageref{ImplicitPlot}), 
    PlotPoints(\ref{PlotPoints} pg.\pageref{PlotPoints})
\end{command} % -- end command --------------------------------

\section{poincare [OBSOLESCENT]}
\label{poincare [OBSOLESCENT]}
\begin{command} % -- COMMAND: poincare [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&HilbertSeries&'' (\ref{HilbertSeries} pg.\pageref{HilbertSeries}).

\end{command} % -- end command --------------------------------

\section{PoincareMultiDeg [OBSOLETE]}
\label{PoincareMultiDeg [OBSOLETE]}
\begin{command} % -- COMMAND: PoincareMultiDeg [OBSOLETE] ------------



\subsection*{Description}

Renamed ``\verb&HilbertSeriesMultiDeg&'' (\ref{HilbertSeriesMultiDeg} pg.\pageref{HilbertSeriesMultiDeg}).

\end{command} % -- end command --------------------------------

\section{PoincareShifts [OBSOLETE]}
\label{PoincareShifts [OBSOLETE]}
\begin{command} % -- COMMAND: PoincareShifts [OBSOLETE] ------------



\subsection*{Description}

Renamed ``\verb&HilbertSeriesShifts&'' (\ref{HilbertSeriesShifts} pg.\pageref{HilbertSeriesShifts}).

\end{command} % -- end command --------------------------------

\section{PolyAlgebraHom}
\label{PolyAlgebraHom}
\begin{command} % -- COMMAND: PolyAlgebraHom ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PolyAlgebraHom(Domain: RING, Codomain: RING, images: LIST): RINGHOM
PolyAlgebraHom(Domain: RING, Codomain: RING, images: STRING): RINGHOM
\end{Verbatim}


\subsection*{Description}

These functions create the homomorphism of (polynomial) algebras from
``\verb&R&'' to ``\verb&S&'' with the same ring of coefficients.  This is
uniquely defined by the images of the indeterminates of ``\verb&R&'' which
are specified by the entries of ``\verb&images&''.  If the rings of coefficients
are not the same, consider using ``\verb&PolyRingHom&'' (\ref{PolyRingHom} pg.\pageref{PolyRingHom}).
\par 
This is a cleaner mathematical implementation of the function
``\verb&image [OBSOLESCENT]&'' (\ref{image [OBSOLESCENT]} pg.\pageref{image [OBSOLESCENT]}) in CoCoA-4.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  S ::= QQ[x[1..3]];
/**/  phi := PolyAlgebraHom(R, S, indets(S));
/**/  phi(x^2-y);
x[1]^2 -x[2]

/**/  S ::= QQ[a];
/**/  phi := PolyAlgebraHom(R, S, "a,1,0");
/**/  phi(x^2-y);
a^2 -1

/**/  phi := PolyAlgebraHom(R, QQ, "2,1,0"); --> evaluate at [2,1,0]
/**/  phi(x^2-y);
3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Introduction to RINGHOM(\ref{Introduction to RINGHOM} pg.\pageref{Introduction to RINGHOM}), 
    CanonicalHom(\ref{CanonicalHom} pg.\pageref{CanonicalHom}), 
    PolyRingHom(\ref{PolyRingHom} pg.\pageref{PolyRingHom})
\end{command} % -- end command --------------------------------

\section{PolyRingHom}
\label{PolyRingHom}
\begin{command} % -- COMMAND: PolyRingHom ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PolyRingHom(R: RING, S: RING, CoeffHom: RINGHOM, images: LIST): RINGHOM
PolyRingHom(R: RING, S: RING, CoeffHom: RINGHOM, images: STRING): RINGHOM
\end{Verbatim}


\subsection*{Description}

These functions create the homomorphism of (polynomial) algebras between
``\verb&R&'' and ``\verb&S&''.  The homomorphism is uniquely defined by the images
of the indeterminates of ``\verb&R&'' and the homomorphism mapping ``\verb&CoeffRing(R)&'' into ``\verb&S&''.
If ``\verb&CoeffHom&'' is trivial, consider using ``\verb&PolyAlgebraHom&'' (\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}) instead.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ R ::= QQ[x,y];
/**/ S ::= QQ[a,b,c];
/**/ SmodJ := NewQuotientRing(S, "a^2-1");

/**/ phi := PolyRingHom(R, SmodJ, CanonicalHom(QQ,SmodJ), "a,b");
/**/ use R;
/**/ phi(x); --> round brackets in output indicate class in SmodJ
(a)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Introduction to RINGHOM(\ref{Introduction to RINGHOM} pg.\pageref{Introduction to RINGHOM}), 
    CanonicalHom(\ref{CanonicalHom} pg.\pageref{CanonicalHom}), 
    PolyAlgebraHom(\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom})
\end{command} % -- end command --------------------------------

\section{PosetCharPoly}
\label{PosetCharPoly}
\begin{command} % -- COMMAND: PosetCharPoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PosetCharPoly(relP: LIST): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the characteristic polynomial from the list relP
of the strict relations in a graded poset in the variable t.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
// POSET:
//         3   4
//          \ /
//           2
//           |
//           1
/**/ relP := [[1,  2], [2, 3],  [2,  4]];
/**/ PosetCharPoly(relP);
t^2 -t
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PosetPoincarePoly(\ref{PosetPoincarePoly} pg.\pageref{PosetPoincarePoly}), 
    ArrCharPoly(\ref{ArrCharPoly} pg.\pageref{ArrCharPoly})
\end{command} % -- end command --------------------------------

\section{PosetDual}
\label{PosetDual}
\begin{command} % -- COMMAND: PosetDual ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PosetDual(relP: LIST): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the dual from the list relP of the strict relations in a poset.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
// POSET:
//         3   4
//          \ /
//           2
//           |
//           1
/**/ relP := [[1,  2], [2, 3],  [2,  4]];
/**/ PosetDual(relP);
[[2,  1],  [3,  2],  [4,  2]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PosetJoin(\ref{PosetJoin} pg.\pageref{PosetJoin}), 
    PosetMeet(\ref{PosetMeet} pg.\pageref{PosetMeet})
\end{command} % -- end command --------------------------------

\section{PosetJoin}
\label{PosetJoin}
\begin{command} % -- COMMAND: PosetJoin ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PosetJoin(relP: LIST, N: INT,  M: INT): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the join (\textit{i.e.} the least upper bound)
between the two elements ``\verb&N&'', ``\verb&M&'' in the poset ``\verb&P&''
from the list ``\verb&relP&'' of its strict relations.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
// POSET:
//         3   4
//          \ /
//           2
//           |
//           1
/**/ relP := [[1,  2], [2, 3],  [2,  4]];
/**/ PosetJoin(relP, 3, 4);
[] --> if it does not exist!

/**/ PosetJoin(relP, 2, 4);
[4]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PosetDual(\ref{PosetDual} pg.\pageref{PosetDual}), 
    PosetMeet(\ref{PosetMeet} pg.\pageref{PosetMeet})
\end{command} % -- end command --------------------------------

\section{PosetMeet}
\label{PosetMeet}
\begin{command} % -- COMMAND: PosetMeet ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PosetMeet(relP: LIST, N: INT,  M: INT): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the meet (\textit{i.e.} the greatest lower bound)
between the two elements ``\verb&N&'', ``\verb&M&'' in the poset ``\verb&P&''
from the list ``\verb&relP&'' of its strict relations.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
// POSET:
//         3   4
//          \ /  \
//           2    5
//           |
//           1
/**/ relP := [[1,  2], [2, 3],  [2,  4], [5,4]];
/**/ PosetMeet(relP, 3, 4);
[2]

/**/ PosetMeet(relP, 2, 5);
[] --> if it does not exist!
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PosetDual(\ref{PosetDual} pg.\pageref{PosetDual}), 
    PosetJoin(\ref{PosetJoin} pg.\pageref{PosetJoin})
\end{command} % -- end command --------------------------------

\section{PosetNRank}
\label{PosetNRank}
\begin{command} % -- COMMAND: PosetNRank ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PosetNRank(relP: LIST, N: INT): INT
\end{Verbatim}


\subsection*{Description}

This function returns the rank of the node ``\verb&N&'' from the list ``\verb&relP&''
of the strict relations in a graded poset.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
// POSET:
//         3   4
//          \ /
//           2
//           |
//           1
/**/ relP := [[1,  2], [2, 3],  [2,  4]];
/**/ PosetNRank(relP, 2);
1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PosetRank(\ref{PosetRank} pg.\pageref{PosetRank}), 
    MaxChains(\ref{MaxChains} pg.\pageref{MaxChains})
\end{command} % -- end command --------------------------------

\section{PosetPoincarePoly}
\label{PosetPoincarePoly}
\begin{command} % -- COMMAND: PosetPoincarePoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PosetPoincarePoly(relP: LIST): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the Poincare polynomial from the list relP of the strict relations in a graded poset in the variable t.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
// POSET:
//         3   4
//          \ /
//           2
//           |
//           1
/**/ relP := [[1,  2], [2, 3],  [2,  4]];
/**/ PosetPoincarePoly(relP);
t +1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PosetCharPoly(\ref{PosetCharPoly} pg.\pageref{PosetCharPoly}), 
    ArrPoincarePoly(\ref{ArrPoincarePoly} pg.\pageref{ArrPoincarePoly})
\end{command} % -- end command --------------------------------

\section{PosetRank}
\label{PosetRank}
\begin{command} % -- COMMAND: PosetRank ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PosetRank(relP: LIST): INT
\end{Verbatim}


\subsection*{Description}

This function returns the rank of a poset from the list relP of its strict relations.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
// POSET:
//         3   4
//          \ /
//           2
//           |
//           1
/**/ relP := [[1,  2], [2, 3],  [2,  4]];
/**/ PosetRank(relP);
2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PosetNRank(\ref{PosetNRank} pg.\pageref{PosetNRank}), 
    MaxChains(\ref{MaxChains} pg.\pageref{MaxChains})
\end{command} % -- end command --------------------------------

\section{power}
\label{power}
\begin{command} % -- COMMAND: power ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
power(X: INT, E: INT): INT
power(X: RAT, E: INT): RAT
power(X: RINGELEM, E: INT): RINGELEM
power(X: MAT, E: INT): MAT
\end{Verbatim}


\subsection*{Description}

This function calculates powers; it is the same as the infix "hat" operator.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  power(2,3);
8
/**/  use QQ[x];
/**/  power(x+1,2);
x^2 +2*x +1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PowerMod(\ref{PowerMod} pg.\pageref{PowerMod}), 
    operators, shortcuts(\ref{operators, shortcuts} pg.\pageref{operators, shortcuts})
\end{command} % -- end command --------------------------------

\section{PowerMod}
\label{PowerMod}
\begin{command} % -- COMMAND: PowerMod ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PowerMod(A: INT, B: INT, M: INT): INT
\end{Verbatim}


\subsection*{Description}

This function calculates efficiently an integer power modulo a given
modulus.  Thus ``\verb&PowerMod(A, B, M)&'' is equal to ``\verb&mod(A^B, M)&'', but the former
is computed faster.  ``\verb&B&'' must be non-negative.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  PowerMod(12345,41041,41041); -- 41041 is a Carmichael number
12345

/**/  PowerMod(123456789,987654321,32003); -- cannot compute 123456789^987654321 directly
2332
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{PreImage [OBSOLESCENT]}
\label{PreImage [OBSOLESCENT]}
\begin{command} % -- COMMAND: PreImage [OBSOLESCENT] ------------



\subsection*{Description}

Changed into ``\verb&preimage0&'' (\ref{preimage0} pg.\pageref{preimage0}).

\SeeAlso %---- SEE ALSO ----
  preimage0(\ref{preimage0} pg.\pageref{preimage0})
\end{command} % -- end command --------------------------------

\section{preimage0}
\label{preimage0}
\begin{command} % -- COMMAND: preimage0 ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
preimage0(phi: RINGHOM, f: RINGELEM): RECORD
\end{Verbatim}


\subsection*{Description}

This function returns a preimage of ``\verb&f&'' via ``\verb&phi&''; if ``\verb&f&'' is
not in the image of ``\verb&phi&'', the function returns 0.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  QQxyz ::= QQ[x,y,z];
/**/  QQab  ::= QQ[a,b];

/**/  use QQab;
/**/  phi := PolyAlgebraHom(QQxyz, QQab, [a+1, a*b+3, b^2]);
/**/  IsInjective(phi);
false
/**/  ker(phi);
ideal(-x^2*z +y^2 +2*x*z -6*y -z +9)
/**/  IsSurjective(phi);
false

/**/  use QQab;
/**/  preimage0(phi, b);
0

/**/  preimage0(phi, a^2);
x^2 -2*x +1
/**/  phi(It);
a^2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ker(\ref{ker} pg.\pageref{ker}), 
    IsSurjective(\ref{IsSurjective} pg.\pageref{IsSurjective})
\end{command} % -- end command --------------------------------

\section{PreprocessPts}
\label{PreprocessPts}
\begin{command} % -- COMMAND: PreprocessPts ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PreprocessPts(Pts: MAT, Toler: MAT): RECORD
PreprocessPtsGrid(Pts: MAT, Toler: MAT): RECORD
PreprocessPtsAggr(Pts: MAT, Toler: MAT): RECORD
PreprocessPtsSubDiv(Pts: MAT, Toler: MAT): RECORD
\end{Verbatim}


\subsection*{Description}

Thanks to Maria-Laura Torrente.
\par 
These functions detect groupings of close points, and choose a single
representative for them (which lies within the given tolerance of each
original point); the result is the list of these representatives, and
the number of original points associated to each representative.
\par 
The first argument is a matrix whose rows represent a set of points in
k-dimensional space, and the second argument is row-matrix of k positive
tolerances (one for each dimension).
\par 
The return value is a record containing two fields: ``\verb&NewPoints&'' contains
a matrix whose rows represent a list of \textbf{well-separated} points, and
``\verb&weights&'' which contains the number of input points associated to each
output point.
\par 
There are three underlying algorithms: ``\verb&Grid&'' is fast but crude;
``\verb&Subdiv&'' works best when the original points are densely packed
(so the result will be a small list); finally ``\verb&Aggr&'' is best
suited to situations where the original points are less densely packed.
\par 
The function ``\verb&PreprocessPts&'' automatically chooses between ``\verb&Subdiv&''
and ``\verb&Aggr&'' with the aim of minimising computation time.  Note that the
``\verb&Aggr&'' and ``\verb&Subdiv&'' methods regard the tolerances as being slightly
flexible.
\par 
For a full description of the algorithms we refer to the paper
J.Abbott, C.Fassino, L.Torrente
\textbf{Thinning Out Redundant Empirical Data} (published in
Mathematics in Computer Science, 2007).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Pts := matrix([[-1,0],[0,0],[1,0],[99,1],[99,0],[99,-1]]);
/**/  Toler := RowMat([3,3]);
/**/  PreprocessPts(Pts, Toler);
record[NewPoints := matrix(QQ,
 [[99, 0],
  [0, 0]]), weights := [3, 3]]

/**/  PreprocessPts(Pts, RowMat([0.8,0.8]));
record[NewPoints := matrix(QQ,
 [[-1/2, 0],
  [1, 0],
  [99, 1/2],
  [99, -1]]), weights := [2, 1, 2, 1]]

/**/  PreprocessPtsAggr(Pts, RowMat([0.9,0.9])); -- exhibits tolerance flex
record[NewPoints := matrix(QQ,
 [[0, 0],
  [99, 0]], weights := [3, 3]]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{PrevPrime, PrevProbPrime}
\label{PrevPrime, PrevProbPrime}
\begin{command} % -- COMMAND: PrevPrime, PrevProbPrime ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PrevPrime(N: INT): INT
PrevProbPrime(N: INT): INT
\end{Verbatim}


\subsection*{Description}

The first function computes the largest prime number smaller than ``\verb&N&''.
If ``\verb&N&'' is too large then an error is signalled.  The upper
limit depends on the computer you are using; it is probably $2^31$
or $2^63$.
\par 
The second function computes the largest probable prime number greater than ``\verb&N&''.  
To be absolutely certain the number produced is prime,
you must call ``\verb&IsPrime&'' (\ref{IsPrime} pg.\pageref{IsPrime}) on it, but this may be very costly.
\par 
Both functions throw errors if given negative arguments.  They also
throw errors if given arguments 0, 1 or 2.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  PrevPrime(1000);
997
/**/  PrevProbPrime(10^50);
99999999999999999999999999999999999999999999999943
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsPrime(\ref{IsPrime} pg.\pageref{IsPrime}), 
    IsProbPrime(\ref{IsProbPrime} pg.\pageref{IsProbPrime}), 
    NextPrime, NextProbPrime(\ref{NextPrime, NextProbPrime} pg.\pageref{NextPrime, NextProbPrime})
\end{command} % -- end command --------------------------------

\section{prim}
\label{prim}
\begin{command} % -- COMMAND: prim ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
prim(f: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the "primitive part" of a polynomial with
rational coefficients: scaled by a rational so that the coefficients
are integer and coprime.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  f := 2*x+4/7;
/**/  prim(f);
7*x +2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  content(\ref{content} pg.\pageref{content}), 
    CommonDenom(\ref{CommonDenom} pg.\pageref{CommonDenom}), 
    ClearDenom(\ref{ClearDenom} pg.\pageref{ClearDenom}), 
    monic(\ref{monic} pg.\pageref{monic})
\end{command} % -- end command --------------------------------

\section{PrimaryDecomposition}
\label{PrimaryDecomposition}
\begin{command} % -- COMMAND: PrimaryDecomposition ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PrimaryDecomposition(I: IDEAL): LIST of IDEAL
\end{Verbatim}


\subsection*{Description}

This function returns the primary decomposition of the ideal I.
Currently it responds ONLY for zero-dimensional ideals
(Abbott, Bigatti, Palezzato, Robbiano
"Computing and Using Minimal Polynomials"
``\verb&https://arxiv.org/abs/1702.07262&''
-- implemented by E.Palezzato and A.Bigatti),
or squarefree monomial ideals (using the Alexander dual technique).
See ``\verb&FrbPrimaryDecomposition&'' (\ref{FrbPrimaryDecomposition} pg.\pageref{FrbPrimaryDecomposition}) for monomial ideals.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  PrimaryDecomposition(ideal(x*y, y*z, z*x));
[ideal(y, z), ideal(x, z), ideal(x, y)]

/**/  PD := PrimaryDecomposition(ideal(x -z,  y^2 -1,  z^2));  PD;
[ideal(y +1,  x -z,  y^2 -1,  z^2),  ideal(y -1,  x -z,  y^2 -1,  z^2)]

/**/ [IdealOfGBasis(Q) | Q in PD];  // remove some redundant generators
[ideal(y +1,  x -z,  z^2),  ideal(y -1,  x -z,  z^2)]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PrimaryDecompositionGTZ0(\ref{PrimaryDecompositionGTZ0} pg.\pageref{PrimaryDecompositionGTZ0}), 
    FrbPrimaryDecomposition(\ref{FrbPrimaryDecomposition} pg.\pageref{FrbPrimaryDecomposition}), 
    EquiIsoDec(\ref{EquiIsoDec} pg.\pageref{EquiIsoDec})
\end{command} % -- end command --------------------------------

\section{PrimaryDecomposition0 [OBSOLETE]}
\label{PrimaryDecomposition0 [OBSOLETE]}
\begin{command} % -- COMMAND: PrimaryDecomposition0 [OBSOLETE] ------------



\subsection*{Description}

Automatically called by ``\verb&PrimaryDecomposition&'' (\ref{PrimaryDecomposition} pg.\pageref{PrimaryDecomposition}) when appropriate.

\SeeAlso %---- SEE ALSO ----
  PrimaryDecomposition(\ref{PrimaryDecomposition} pg.\pageref{PrimaryDecomposition})
\end{command} % -- end command --------------------------------

\section{PrimaryDecompositionGTZ0}
\label{PrimaryDecompositionGTZ0}
\begin{command} % -- COMMAND: PrimaryDecompositionGTZ0 ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PrimaryDecompositionGTZ0(I: IDEAL): LIST of IDEAL
\end{Verbatim}


\subsection*{Description}

This function, alternative to ``\verb&PrimaryDecomposition&'' (\ref{PrimaryDecomposition} pg.\pageref{PrimaryDecomposition}),
returns the primary decomposition of the 0-dimensional
ideal ``\verb&I&'' using the GTZ algorithm (implemented by Luis David
Garcia -- updated to CoCoA-5 by Anna M. Bigatti).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  PD := PrimaryDecompositionGTZ0(ideal(x-z, y^2-z^2, z^2));
/**/  indent(PD);
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PrimaryDecomposition(\ref{PrimaryDecomposition} pg.\pageref{PrimaryDecomposition})
\end{command} % -- end command --------------------------------

\section{PrimaryHilbertSeries}
\label{PrimaryHilbertSeries}
\begin{command} % -- COMMAND: PrimaryHilbertSeries ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PrimaryHilbertSeries(I: IDEAL, Q: IDEAL): TAGGED("PSeries")
\end{Verbatim}


\subsection*{Description}

Let ``\verb&P&'' be a polynomial ring,
``\verb&M&'' the maximal ideal in ``\verb&P&'' generated by the indeterminates,
and ``\verb&(Q+I)/I&'' a primary ideal for ``\verb&M/I&''.
This function computes the Hilbert-Poincare series of ``\verb&(P/I)/((Q+I)/I)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use S ::= QQ[x,y,z];
/**/  I := ideal(x^3-y*z, y^2-x*z, z^2-x^2*y);
/**/  Q := ideal(y, z);
/**/  PS := PrimaryHilbertSeries(I, Q); PS;

/**/  use S ::= QQ[x,y,z,w];
/**/  I := ***Ideal(
/**/    x^5 - yz, y^4 - xz^2, xy^3 - zw, x^2z - yw,
/**/    y^2z^2 - w^3, y^3z - x^2w^2, x^3w - z^2, xyw^2 - z^3,
/**/    x^3y^2 - w^2, xz^4 - y^2w^3, yz^5 - xw^5, y^3w^5 - z^7,
/**/    x^2w^7 - z^8, z^9 - yw^8)***;
/**/  Q  := ideal(x, y, z);
/**/  PS := PrimaryHilbertSeries(I, Q); PS;
/**/  $hp.PSerToHilbert(PS);

/**/  use S ::= ZZ/(32003)[x,y,z];
/**/  I  := ideal(S, []);  -- ideal in S with no generators
/**/  Q  := ideal(x, y, z^2);
/**/  PS := PrimaryHilbertSeries(I, Q); PS;
/**/  $hp.PSerToHilbert(PS);
/**/  HV := $hp.PSerHVector(PS); -- the H-vector associated to PS

/**/  use S ::= ZZ/(32003)[x,y,z,w];
/**/  I  := ***Ideal(-yz + xw, z^3 - yw^2, -xz^2 + y^2w, -y^3 + x^2z)***;
/**/  Q  := ideal(x, y, z^2, w^3);
/**/  PS := PrimaryHilbertSeries(I, Q); PS;
/**/  $hp.PSerToHilbert(PS);
/**/  HV := $hp.PSerHVector(PS);
/**/  $primary.E(0, HV);
/**/  [ $primary.E(J,HV) | J in 0..($hp.PSerDim(PS)-2) ];
/**/  [ $primary.E(J,HV) | J in 0..(len(HV)-1) ];

/**/  use S ::= ZZ/(32003)[x,y,z,w];
/**/  I  := ***Ideal(x^3-y^7, x^2y - xw^3-z^6)***;
/**/  Q  := ideal(x, y, z, w);
/**/  PS := PrimaryHilbertSeries(I, Q); PS;
/**/  $hp.PSerToHilbert(PS);
/**/  HV := $hp.PSerHVector(PS);
/**/  [ $primary.E(J,HV) | J in 0..($hp.PSerDim(PS)-2) ];
/**/  [ $primary.E(J,HV) | J in 0..(len(HV)-1) ];

/**/  use S ::= ZZ/(32003)[x,y,z];
/**/  I  := ideal(z^3);
/**/  Q  := ideal(x^2, y^2, x*z, y*z);
/**/  PS := PrimaryHilbertSeries(I, Q); PS;
/**/  $hp.PSerToHilbert(PS);
/**/  HV := $hp.PSerHVector(PS);
/**/  [ $primary.E(J,HV) | J in 0..($hp.PSerDim(PS)-2) ];
/**/  [ $primary.E(J,HV) | J in 0..(len(HV)-1) ];
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  InitialIdeal(\ref{InitialIdeal} pg.\pageref{InitialIdeal}), 
    TgCone(\ref{TgCone} pg.\pageref{TgCone})
\end{command} % -- end command --------------------------------

\section{PrimaryPoincare [OBSOLESCENT]}
\label{PrimaryPoincare [OBSOLESCENT]}
\begin{command} % -- COMMAND: PrimaryPoincare [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&PrimaryHilbertSeries&'' (\ref{PrimaryHilbertSeries} pg.\pageref{PrimaryHilbertSeries}).

\SeeAlso %---- SEE ALSO ----
  PrimaryHilbertSeries(\ref{PrimaryHilbertSeries} pg.\pageref{PrimaryHilbertSeries})
\end{command} % -- end command --------------------------------

\section{PrimitiveRoot}
\label{PrimitiveRoot}
\begin{command} % -- COMMAND: PrimitiveRoot ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PrimitiveRoot(P: INT): INT
\end{Verbatim}


\subsection*{Description}

Find a primitive root modulo the prime ``\verb&P&'', \textit{i.e.} a generator of
the cyclic multiplicative group of non-zero integers mod ``\verb&P&''.
\par 
Currently, the function produces the least positive primitive root.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  PrimitiveRoot(17551561);
97
/**/  PrimitiveRoot(4111);
12;
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsPrime(\ref{IsPrime} pg.\pageref{IsPrime})
\end{command} % -- end command --------------------------------

\section{primorial}
\label{primorial}
\begin{command} % -- COMMAND: primorial ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
primorial(N: INT): INT
    \end{Verbatim}


\subsection*{Description}

This function returns the "primorial" of ``\verb&N&'', the product of all
positive primes less than or equal to ``\verb&N&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  primorial(5);
30

/**/  primorial(21);
9699690
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  factorial(\ref{factorial} pg.\pageref{factorial})
\end{command} % -- end command --------------------------------

\section{print}
\label{print}
\begin{command} % -- COMMAND: print ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
print E_1, ..., E_n
\end{Verbatim}


\subsection*{Description}

This command displays the value of each of the expressions ``\verb&E_i&''.
To insert a newline write ``\verb&\n&''.
\par 
The similar command ``\verb&println&'' (\ref{println} pg.\pageref{println}) is equivalent to ``\verb&print&''
followed by a newline.
\par 
See ``\verb&print on&'' (\ref{print on} pg.\pageref{print on}) for printing on file.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  for I := 1 To 10 Do  print I^2, " ";  endfor;
1 4 9 16 25 36 49 64 81 100

/**/  print "a\nb";
a
b
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  print on(\ref{print on} pg.\pageref{print on}), 
    println(\ref{println} pg.\pageref{println}), 
    format(\ref{format} pg.\pageref{format}), 
    indent(\ref{indent} pg.\pageref{indent}), 
    latex(\ref{latex} pg.\pageref{latex}), 
    sprint(\ref{sprint} pg.\pageref{sprint}), 
    All CoCoA commands(\ref{All CoCoA commands} pg.\pageref{All CoCoA commands})
\end{command} % -- end command --------------------------------

\section{print on}
\label{print on}
\begin{command} % -- COMMAND: print on ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
print  E: OBJECT  on  OUT: OSTREAM
\end{Verbatim}


\subsection*{Description}

This command prints the value of expression ``\verb&E&'' to the output stream ``\verb&OUT&''.
Currently, the command can be used to print to files, strings, or the
CoCoA window.  In the first two cases, the appropriate device must be
opened with ``\verb&OpenOFile&'' (\ref{OpenOFile} pg.\pageref{OpenOFile}) or ``\verb&OpenOString&'' (\ref{OpenOString} pg.\pageref{OpenOString}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  file := OpenOFile("my-test");  -- open "my-test" for output from CoCoA
/**/  println "hello world" on file;   -- print string into "mytest"
/**/  close(file);  -- close the file
\end{Verbatim}

See ``\verb&OpenOFile&'' (\ref{OpenOFile} pg.\pageref{OpenOFile}) for an example using output strings.
For printing to the CoCoA window, just use ``\verb&println E&''.

\SeeAlso %---- SEE ALSO ----
  Introduction to IO(\ref{Introduction to IO} pg.\pageref{Introduction to IO}), 
    OpenIFile(\ref{OpenIFile} pg.\pageref{OpenIFile}), 
    OpenOFile(\ref{OpenOFile} pg.\pageref{OpenOFile}), 
    OpenIString(\ref{OpenIString} pg.\pageref{OpenIString}), 
    OpenOString(\ref{OpenOString} pg.\pageref{OpenOString}), 
    print(\ref{print} pg.\pageref{print}), 
    println(\ref{println} pg.\pageref{println}), 
    All CoCoA commands(\ref{All CoCoA commands} pg.\pageref{All CoCoA commands})
\end{command} % -- end command --------------------------------

\section{PrintBettiDiagram}
\label{PrintBettiDiagram}
\begin{command} % -- COMMAND: PrintBettiDiagram ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PrintBettiDiagram(X: IDEAL or (quotient)RING or MODULE)
PrintBettiDiagram(X: LIST(res) or RECORD(diagram))
\end{Verbatim}


\subsection*{Description}

This function prints the ("Macaulay-style") Betti diagram for ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[t,x,y,z];
/**/  I := ideal(x^2-y*t, x*y-z*t, x*y);
/**/  RES := res(I);
/**/  PrintRes(RES);
0 --> R(-5)^2 --> R(-4)^4 --> R(-2)^3
/**/  B := BettiDiagram(RES);  indent(B);
record[
  Diagram := matrix(ZZ,
 [[3, 0, 0],
  [0, 4, 2]]),
  FirstShift := 2
]
/**/  PrintBettiDiagram(RES); -- same as PrintBettiDiagram(I or B)
        0    1    2
--------------------
 2:     3    -    -
 3:     -    4    2
--------------------
Tot:    3    4    2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BettiDiagram(\ref{BettiDiagram} pg.\pageref{BettiDiagram}), 
    BettiMatrix(\ref{BettiMatrix} pg.\pageref{BettiMatrix}), 
    PrintRes(\ref{PrintRes} pg.\pageref{PrintRes}), 
    PrintBettiMatrix(\ref{PrintBettiMatrix} pg.\pageref{PrintBettiMatrix})
\end{command} % -- end command --------------------------------

\section{PrintBettiMatrix}
\label{PrintBettiMatrix}
\begin{command} % -- COMMAND: PrintBettiMatrix ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PrintBettiMatrix(M: IDEAL|MODULE|Resolution)
\end{Verbatim}


\subsection*{Description}

This function prints the Betti matrix for M.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[t,x,y,z];
/**/  I := ideal(x^2-y*t, x*y-z*t, x*y);
/**/  PrintRes(I);
0 --> R^2(-5) --> R^4(-4) --> R^3(-2)
-------------------------------
/**/  PrintBettiMatrix(I);
   0    0    0
   0    0    3
   0    0    0
   0    4    0
   2    0    0
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PrintRes(\ref{PrintRes} pg.\pageref{PrintRes}), 
    PrintBettiDiagram(\ref{PrintBettiDiagram} pg.\pageref{PrintBettiDiagram}), 
    PrintBettiNumbers(\ref{PrintBettiNumbers} pg.\pageref{PrintBettiNumbers})
\end{command} % -- end command --------------------------------

\section{PrintBettiNumbers}
\label{PrintBettiNumbers}
\begin{command} % -- COMMAND: PrintBettiNumbers ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PrintBettiNumbers(M: IDEAL|MODULE|Resolution)
\end{Verbatim}


\subsection*{Description}

This function prints the Betti numbers for ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ M := MakeTermOrdMat(matrix([[5,5,5,1,1], [1,1,1,0,0]]));
/**/ P := NewPolyRing(QQ, "t[1],t[2],t[3],x,y", M, 2); -- ZZ^2-grading
/**/ use P;
/**/ I := ideal(t[1]^6 -t[3]^6, t[2]^6 -t[1]^5*t[3], t[1]*t[3]*x^8 -t[2]^2*y^8);
/**/ RES := res(P/I);
/**/ PrintRes(RES);
0 --> R[-78,-14] --> R[-48,-8]^2(+)R[-60,-12] --> R[-18,-2](+)R[-30,-6]^2 --> R

/**/ PrintBettiNumbers(RES);  --> just prints in a readable way
----- 1 -----------
----- 2 -----------
  [18,  2]: 1
  [30,  6]: 2
----- 3 -----------
  [48,  8]: 2
  [60,  12]: 1
----- 4 -----------
  [78,  14]: 1
-------------------

/**/ BettiNumbers(RES);  --> returns the value for further computations
[[],  [[[18,  2],  1],  [[30,  6],  2]],  [[[48,  8],  2],
 [[60,  12],  1]],  [[[78,  14],  1]]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PrintRes(\ref{PrintRes} pg.\pageref{PrintRes}), 
    PrintBettiDiagram(\ref{PrintBettiDiagram} pg.\pageref{PrintBettiDiagram}), 
    PrintBettiMatrix(\ref{PrintBettiMatrix} pg.\pageref{PrintBettiMatrix}), 
    BettiNumbers(\ref{BettiNumbers} pg.\pageref{BettiNumbers})
\end{command} % -- end command --------------------------------

\section{println}
\label{println}
\begin{command} % -- COMMAND: println ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
println E_1,...,E_n
PrintLn E_1,...,E_n
\end{Verbatim}


\subsection*{Description}

This command is equivalent to ``\verb&print&'' (\ref{print} pg.\pageref{print}) with a final newline;
in other words, it prints the values of its arguments, then moves the
cursor to the next line.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  for i := 1 to 3 do  print i;  endfor;
123

/**/  for i := 1 to 3 do  println i;  endfor;
1
2
3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  format(\ref{format} pg.\pageref{format}), 
    indent(\ref{indent} pg.\pageref{indent}), 
    latex(\ref{latex} pg.\pageref{latex}), 
    print(\ref{print} pg.\pageref{print}), 
    print on(\ref{print on} pg.\pageref{print on}), 
    All CoCoA commands(\ref{All CoCoA commands} pg.\pageref{All CoCoA commands})
\end{command} % -- end command --------------------------------

\section{PrintRes}
\label{PrintRes}
\begin{command} % -- COMMAND: PrintRes ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PrintRes(M)
\end{Verbatim}


\subsection*{Description}

This function prints the minimal free resolution of ``\verb&M&''.
(see ``\verb&res&'' (\ref{res} pg.\pageref{res})).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x, y, z^2);
/**/  RES := res(I);
/**/  PrintRes(I);   -- recomputes resolution
0 --> R(-4) --> R(-2)(+)R(-3)^2 --> R(-1)^2(+)R(-2)
/**/  PrintRes(RES); -- just prints RES
0 --> R(-4) --> R(-2)(+)R(-3)^2 --> R(-1)^2(+)R(-2)
/**/  PrintBettiDiagram(RES); -- just prints the BettiDiagram for RES
        0    1    2
--------------------
  1:    2    1    -
  2:    1    2    1
--------------------
Tot:    3    3    1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PrintBettiDiagram(\ref{PrintBettiDiagram} pg.\pageref{PrintBettiDiagram}), 
    PrintBettiMatrix(\ref{PrintBettiMatrix} pg.\pageref{PrintBettiMatrix}), 
    res(\ref{res} pg.\pageref{res})
\end{command} % -- end command --------------------------------

\section{PrintSectionalMatrix}
\label{PrintSectionalMatrix}
\begin{command} % -- COMMAND: PrintSectionalMatrix ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PrintSectionalMatrix(I: IDEAL): MAT
PrintSectionalMatrix(P/I: RING): MAT
\end{Verbatim}


\subsection*{Description}

This function prints the sectional matrix of ``\verb&I&'' or ``\verb&P/I&''.
See ``\verb&SectionalMatrix&'' (\ref{SectionalMatrix} pg.\pageref{SectionalMatrix}) for more information.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use P ::= QQ[x,y,z];
/**/ I := ideal(x^4 -x*y^3,  x*y -z^2,  x*z^2 -y^3);
/**/ SectionalMatrix(P/I);
matrix(ZZ,
 [[1, 1, 0, 0, 0, 0, 0, 0],
  [1, 2, 2, 1, 0, 0, 0, 0],
  [1, 3, 5, 6, 5, 3, 2, 2]])

/**/ PrintSectionalMatrix(P/I);
  0  1  2  3  4  5  6  7
  -  -  -  -  -  -  -  -
  1  1  0  0  0  0  0  0
  1  2  2  1  0  0  0  0
  1  3  5  6  5  3  2  2

/**/ PrintSectionalMatrix(I);
  0  1  2  3   4   5   6   7
  -  -  -  -   -   -   -   -
  0  0  1  1   1   1   1   1
  0  0  1  3   5   6   7   8
  0  0  1  4  10  18  26  34
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  SectionalMatrix(\ref{SectionalMatrix} pg.\pageref{SectionalMatrix})
\end{command} % -- end command --------------------------------

\section{product}
\label{product}
\begin{command} % -- COMMAND: product ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
product(L: LIST): OBJECT
product(L: LIST, InitVal: OBJECT): OBJECT
\end{Verbatim}


\subsection*{Description}

This function returns the product of the objects in the list ``\verb&L&'' (together
with rightmost factor ``\verb&InitVal&'', if specified).  If the list ``\verb&L&'' may be
empty, you must specify also ``\verb&InitVal&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  product([3, x, y^2]);
3*x*y^2

/**/  product(1..40) = factorial(40);
true

/**/  product([], y);
y
/**/  product([3, x], y);
3*x*y
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Algebraic Operators(\ref{Algebraic Operators} pg.\pageref{Algebraic Operators}), 
    sum(\ref{sum} pg.\pageref{sum})
\end{command} % -- end command --------------------------------

\section{protect}
\label{protect}
\begin{command} % -- COMMAND: protect ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
protect X;
protect X : reason;
  where reason: STRING
\end{Verbatim}


\subsection*{Description}

This command protects the variable ``\verb&X&'' from being assigned to.
Attempting to assign to it will produce an error; if a ``\verb&reason&''
(STRING) was given it is printed in the error message.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  MaxSize := 99;
/**/  protect MaxSize : "size limit for fast computation";
-- /**/  MaxSize := 1000; --> !!! ERROR !!! as expected: Cannot set "MaxSize"

/**/  unprotect MaxSize;  --> remove protection, X may be assigned to now
/**/  MaxSize := 1000; --> OK
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  unprotect(\ref{unprotect} pg.\pageref{unprotect})
\end{command} % -- end command --------------------------------

\section{PthRoot}
\label{PthRoot}
\begin{command} % -- COMMAND: PthRoot ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
PthRoot(X: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the p-th root of a polynomial over a finite
field.  If no p-th root exists then an error is signalled.  p is
the characteristic of the field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= ZZ/(7)[x,y];
/**/  F := x^7-y^14+3;
/**/  PthRoot(F);
-y^2+x+3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsFiniteField(\ref{IsFiniteField} pg.\pageref{IsFiniteField}), 
    IsPthPower(\ref{IsPthPower} pg.\pageref{IsPthPower})
\end{command} % -- end command --------------------------------

\chapter{Q}  %----=== CHAPTER LETTER ===----
\label{Q}

\section{QQ}
\label{QQ}
\begin{command} % -- COMMAND: QQ ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
QQ: RING
\end{Verbatim}


\subsection*{Description}

This system variable is constant; its value is the field of rationals.
Its name is protected so that it cannot be re-assigned to any other
value.
\par 
NOTE: this is a (protected) \textbf{variable}, so in ``\verb&define/endefine&'' 
use ``\verb&RingQQ&'' (\ref{RingQQ} pg.\pageref{RingQQ}) instead (or import it with ``\verb&TopLevel&'' (\ref{TopLevel} pg.\pageref{TopLevel})).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ;

/**/  type(5);
INT
/**/  type(RingElem(QQ, 5));
RINGELEM

/**/  QQ = RingQQ();
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ZZ(\ref{ZZ} pg.\pageref{ZZ}), 
    NewQuotientRing(\ref{NewQuotientRing} pg.\pageref{NewQuotientRing}), 
    RingQQ(\ref{RingQQ} pg.\pageref{RingQQ}), 
    TopLevel(\ref{TopLevel} pg.\pageref{TopLevel})
\end{command} % -- end command --------------------------------

\section{QQEmbeddingHom}
\label{QQEmbeddingHom}
\begin{command} % -- COMMAND: QQEmbeddingHom ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
QQEmbeddingHom(R: RING): RINGHOM
\end{Verbatim}


\subsection*{Description}

This function returns the homomorphism ``\verb&QQ --> R&''.
This is useful for changing the ring of coefficients.
\par 
NOTE: this is a partial homomorphism when ``\verb&R&'' has finite characteristic.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQxy ::= QQ[x,y];
/**/  f := (2/3)*x +5*y;

/**/  FFpxy ::= ZZ/(101)[x,y];
/**/  QQEmbeddingHom(FFpxy) (LC(f));
-33
/**/  phi := PolyRingHom(QQxy, FFpxy, QQEmbeddingHom(FFpxy), indets(FFpxy));
/**/  phi(f);
-33*x +5*y

/**/  RRxy := NewPolyRing(NewRingTwinFloat(64), "x,y");
/**/  phi := PolyRingHom(QQxy, RRxy, QQEmbeddingHom(RRxy), indets(RRxy));
/**/  phi(f);
2/3*x +5*y
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CanonicalHom(\ref{CanonicalHom} pg.\pageref{CanonicalHom})
\end{command} % -- end command --------------------------------

\section{quit}
\label{quit}
\begin{command} % -- COMMAND: quit ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
quit
\end{Verbatim}


\subsection*{Description}

This command is used to quit CoCoA.  It may be used only at top level.

\SeeAlso %---- SEE ALSO ----
  ciao(\ref{ciao} pg.\pageref{ciao}), 
    exit(\ref{exit} pg.\pageref{exit})
\end{command} % -- end command --------------------------------

\section{QuotientBasis}
\label{QuotientBasis}
\begin{command} % -- COMMAND: QuotientBasis ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
QuotientBasis(I: IDEAL): LIST
\end{Verbatim}


\subsection*{Description}

This function determines a vector space basis (of power products)
for the quotient space associated to a zero-dimensional ideal.
That is, if R is a polynomial ring with field of coefficients k, and
I is a zero-dimensional ideal in R then QuotientBasis(I) is a set of
power products forming a k-vector space basis of R/I.
\par 
The actual set of power products chosen depends on the term ordering
in the ring R: the power products chosen are those not divisible by
the leading term of any member of the reduced Groebner basis of I
(and consequently they form a factor-closed set).
\par 
The power-products in the result are sorted in increasing lex ordering.  
See ``\verb&QuotientBasisSorted&'' (\ref{QuotientBasisSorted} pg.\pageref{QuotientBasisSorted}) for sorting them according to the 
term-ordering of the ring.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  I := intersection(ideal(x,y,z)^2, ideal(x-1, y+1, z)^2);
/**/  QB := QuotientBasis(I);
/**/  QB; -- power-products underneath the reduced GBasis of I
[1, z, y, y*z, y^2, y^3, x, x*y]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IdealOfPoints(\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}), 
    IsFactorClosed(\ref{IsFactorClosed} pg.\pageref{IsFactorClosed})
\end{command} % -- end command --------------------------------

\section{QuotientBasisSorted}
\label{QuotientBasisSorted}
\begin{command} % -- COMMAND: QuotientBasisSorted ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
QuotientBasisSorted(I: IDEAL): LIST
\end{Verbatim}


\subsection*{Description}

This function determines a vector space basis (of power products)
for the quotient space associated to a zero-dimensional ideal.
It is the same as ``\verb&QuotientBasis&'' (\ref{QuotientBasis} pg.\pageref{QuotientBasis}), but sorted
in increasing order according to the  term-ordering of the ring.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  I := intersection(ideal(x,y,z)^2, ideal(x-1, y+1, z)^2);
/**/  QBS := QuotientBasisSorted(I);   QBS;
[1, z, y, x, y*z, y^2, x*y, y^3]

/**/  QB := QuotientBasis(I);   QB;
[1, z, y, y*z, y^2, y^3, x, x*y]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  QuotientBasis(\ref{QuotientBasis} pg.\pageref{QuotientBasis})
\end{command} % -- end command --------------------------------

\section{QuotientingHom}
\label{QuotientingHom}
\begin{command} % -- COMMAND: QuotientingHom ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
QuotientingHom(P: RING): RINGHOM
\end{Verbatim}


\subsection*{Description}

This function returns the projection homomorphism of a ring ``\verb&R&'' into 
a quotient ring ``\verb&R/I&''.
\par 
It is equivalent to calling ``\verb&CanonicalHom(BaseRing(RModI), RModI)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[i];
/**/  f := i^3;
/**/  K := P/ideal(i^2+1);
/**/  phi := QuotientingHom(K);  -- phi: P -> K
/**/  RingOf(phi(f));
/**/  phi(f); --> round brackets indicate it is the class of -i in K = P/I
(-i)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CanonicalHom(\ref{CanonicalHom} pg.\pageref{CanonicalHom})
\end{command} % -- end command --------------------------------

\section{QZP}
\label{QZP}
\begin{command} % -- COMMAND: QZP ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
QZP(F: RINGELEM): RINGELEM
QZP(F: LIST of POLY): LIST of POLY
QZP(I: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
See example below
\par 
The functions ``\verb&QZP&'' and ``\verb&ZPQ&'' (\ref{ZPQ} pg.\pageref{ZPQ}) map polynomials and
ideals of other rings into ones of the current ring.
When mapping from one ring to another, one of the rings must have
coefficients in the rational numbers and the other must have
coefficients in a finite field.  The indeterminates in both
rings must be identical.
\par 
The function ``\verb&QZP&'' maps polynomials with rational coefficients to
polynomials with coefficients in a finite field; the function ``\verb&ZPQ&'' (\ref{ZPQ} pg.\pageref{ZPQ})
does the reverse, mapping a polynomial with finite field coefficients
into one with rational (actually, integer) coefficients.  The function
``\verb&ZPQ&'' (\ref{ZPQ} pg.\pageref{ZPQ}) is not uniquely defined mathematically, and currently for each
coefficient the least non-negative equivalent integer is chosen.
Users should not rely on this choice, though any change will be
documented.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  F := 1/2*x^3 + (34/567)*x*y*z - 890; -- a poly with rational coefficients
/**/  use S ::= ZZ/(101)[x,y,z];
/**/  -- this is the clean way to do it!
/**/  phi := PolyRingHom(R, S, QQEmbeddingHom(S), indets(S));
/**/  phi(F);
-50*x^3 -19*x*y*z +19
***** NOT YET IMPLEMENTED *****
  QZP(F);                            -- compute its image with coeffs in ZZ/(101)
-50x^3 - 19xyz + 19
-------------------------------
  G := It;
  use R;
  ZPQ(G);                      -- now map that result back to QQ[x,y,z]
                               -- it is NOT the same as F...
51x^3 + 82xyz + 19
-------------------------------
  H := It;
  F - H;                       -- ... but the difference is divisible by 101
-101/2x^3 - 46460/567xyz - 909
-------------------------------
  use S;
  QZP(H) - G;                  -- F and H have the same image in ZZ/(101)[x,y,z]
0
-------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Introduction to RINGHOM(\ref{Introduction to RINGHOM} pg.\pageref{Introduction to RINGHOM}), 
    BringIn(\ref{BringIn} pg.\pageref{BringIn})
\end{command} % -- end command --------------------------------

\chapter{R}  %----=== CHAPTER LETTER ===----
\label{R}

\section{radical}
\label{radical}
\begin{command} % -- COMMAND: radical ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
radical(N: INT): INT
radical(X: RINGELEM): RINGELEM
radical(I: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

This function computes the radical of its argument.  For integers and
ring elements this means the product of the distinct irreducibles
dividing the argument (sometimes called "square-free").
For ideals it computes the radical ideal using the algorithm described
in the paper
\par 
  M. Caboara, P. Conti and C. Traverso: \textbf{Yet Another Ideal
  Decomposition Algorithm.} Proc. AAECC-12, pp 39-54, 1997, Lecture
  Notes in Computer Science, n.1255 Springer-Verlag.
\par 
NOTE: at the moment, this implementation works only if the coefficient
ring is the rationals or has large enough characteristic.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  radical(99);
33
/**/  use R ::= QQ[x,y];
/**/  radical((x -y)^3 * (x +y));
x^2 -y^2
/**/  I := ideal(x,y)^3;
/**/  radical(I);
ideal(y, x)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsInRadical(\ref{IsInRadical} pg.\pageref{IsInRadical}), 
    EquiIsoDec(\ref{EquiIsoDec} pg.\pageref{EquiIsoDec}), 
    RadicalOfUnmixed(\ref{RadicalOfUnmixed} pg.\pageref{RadicalOfUnmixed}), 
    SqFreeFactor(\ref{SqFreeFactor} pg.\pageref{SqFreeFactor})
\end{command} % -- end command --------------------------------

\section{RadicalOfUnmixed}
\label{RadicalOfUnmixed}
\begin{command} % -- COMMAND: RadicalOfUnmixed ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RadicalOfUnmixed(I: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

This function computes the radical of an unmixed ideal.
\par 
NOTE: at the moment, this implementation works only if the coefficient
ring is the rationals or has large enough characteristic.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  I := ideal(x^2 - y^2 - 4*x + 4*y, x - 2);
/**/  RadicalOfUnmixed(I);
ideal(x^2 -y^2 -4*x +4*y, x -2, y -2)
/**/ interreduced(gens(It)); -- the result may not be in its simplest form
[y -2, x -2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  EquiIsoDec(\ref{EquiIsoDec} pg.\pageref{EquiIsoDec}), 
    radical(\ref{radical} pg.\pageref{radical})
\end{command} % -- end command --------------------------------

\section{random}
\label{random}
\begin{command} % -- COMMAND: random ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
random(X: INT, Y: INT): INT
\end{Verbatim}


\subsection*{Description}

The function returns a random integer between ``\verb&X&'' and ``\verb&Y&'', inclusive.  The range
$|X-Y|$ should be less than $2^33$ to ensure a uniform distribution.
\par 
NOTE: every time you restart CoCoA the sequence of random numbers will
be the same (as happens in many programming languages).  You can change
this by using ``\verb&reseed&'' (\ref{reseed} pg.\pageref{reseed}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  random(1,100);
6

/**/  random(-10^4,0);
-3263
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  RandomSubset(\ref{RandomSubset} pg.\pageref{RandomSubset}), 
    RandomSubsetIndices(\ref{RandomSubsetIndices} pg.\pageref{RandomSubsetIndices}), 
    RandomTuple(\ref{RandomTuple} pg.\pageref{RandomTuple}), 
    RandomTupleIndices(\ref{RandomTupleIndices} pg.\pageref{RandomTupleIndices}), 
    RandomSmallPrime(\ref{RandomSmallPrime} pg.\pageref{RandomSmallPrime}), 
    reseed(\ref{reseed} pg.\pageref{reseed})
\end{command} % -- end command --------------------------------

\section{randomize [OBSOLETE]}
\label{randomize [OBSOLETE]}
\begin{command} % -- COMMAND: randomize [OBSOLETE] ------------



\subsection*{Description}

OBSOLETE:
you can do ``\verb&f := sum([random(-99,99)*t | t in support(f)])&'' instead,
or use ``\verb&RandomLinearForm&'' (\ref{RandomLinearForm} pg.\pageref{RandomLinearForm}).

\SeeAlso %---- SEE ALSO ----
  random(\ref{random} pg.\pageref{random}), 
    RandomLinearForm(\ref{RandomLinearForm} pg.\pageref{RandomLinearForm})
\end{command} % -- end command --------------------------------

\section{randomized [OBSOLETE]}
\label{randomized [OBSOLETE]}
\begin{command} % -- COMMAND: randomized [OBSOLETE] ------------



\subsection*{Description}

OBSOLETE:
you can do ``\verb&f := sum([random(-99,99)*t | t in support(f)])&'' instead,
or use ``\verb&RandomLinearForm&'' (\ref{RandomLinearForm} pg.\pageref{RandomLinearForm}).

\SeeAlso %---- SEE ALSO ----
  random(\ref{random} pg.\pageref{random}), 
    RandomLinearForm(\ref{RandomLinearForm} pg.\pageref{RandomLinearForm})
\end{command} % -- end command --------------------------------

\section{RandomLinearForm}
\label{RandomLinearForm}
\begin{command} % -- COMMAND: RandomLinearForm ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RandomLinearForm(R: RING, n: INT): RINGELEM
RandomLinearForm(R: RING): RINGELEM
\end{Verbatim}


\subsection*{Description}

The first function returns a non-zero random linear form in the polynomial
ring ``\verb&R&'', with integer coefficients in the range ``\verb&-n..n&''.
\par 
The second function is for polynomial rings ``\verb&R&'' with finite characteristic
``\verb&p&'', it returns a random linear form with integer coefficients in the
range ``\verb&0..p-1&''.
\par 
\textbf{NOTE: If the ring has weighted degrees, the weights are ignored:}
consider applying ``\verb&HomogCompt&'' (\ref{HomogCompt} pg.\pageref{HomogCompt}) to the linear form produced.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ R ::= ZZ/(101)[a,b,c,d,e,f];
/**/ RandomLinearForm(R, 1);
-a -c +d -e -f
/**/ RandomLinearForm(R);
49*a +37*b +36*c +12*d -37*e +34*f
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  random(\ref{random} pg.\pageref{random}), 
    HomogCompt(\ref{HomogCompt} pg.\pageref{HomogCompt})
\end{command} % -- end command --------------------------------

\section{RandomPermutation}
\label{RandomPermutation}
\begin{command} % -- COMMAND: RandomPermutation ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RandomPermutation(N: INT): LIST of INT
\end{Verbatim}


\subsection*{Description}

This function returns a random permutation of the integers ``\verb&1..N&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ RandomPermutation(5);
[5,  3,  2,  1,  4]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  random(\ref{random} pg.\pageref{random}), 
    RandomSubsetIndices(\ref{RandomSubsetIndices} pg.\pageref{RandomSubsetIndices}), 
    RandomTupleIndices(\ref{RandomTupleIndices} pg.\pageref{RandomTupleIndices})
\end{command} % -- end command --------------------------------

\section{RandomSmallPrime}
\label{RandomSmallPrime}
\begin{command} % -- COMMAND: RandomSmallPrime ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RandomSmallPrime(N: INT): INT
\end{Verbatim}


\subsection*{Description}

This function returns a random prime in the range 5 to ``\verb&N&'' (incl.).
The distribution is uniform.  ``\verb&N&'' must be between 5 and ``\verb&2^31-1&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ RandomSmallPrime(99);
43
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  random(\ref{random} pg.\pageref{random}), 
    IsPrime(\ref{IsPrime} pg.\pageref{IsPrime}), 
    RandomTupleIndices(\ref{RandomTupleIndices} pg.\pageref{RandomTupleIndices})
\end{command} % -- end command --------------------------------

\section{RandomSparseNonSing01Mat}
\label{RandomSparseNonSing01Mat}
\begin{command} % -- COMMAND: RandomSparseNonSing01Mat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RandomSparseNonSing01Mat(R: RING, N: INT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns a random ``\verb&N&''-by-``\verb&N&'' sparse matrix (with entries
0 or 1) having non-zero determinant.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ RandomSparseNonSing01Mat(ZZ, 3);
matrix(ZZ,
 [[1, 1, 0],
  [0, 1, 0],
  [0, 0, 1]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  random(\ref{random} pg.\pageref{random}), 
    RandomUnimodularMat(\ref{RandomUnimodularMat} pg.\pageref{RandomUnimodularMat})
\end{command} % -- end command --------------------------------

\section{RandomSubset}
\label{RandomSubset}
\begin{command} % -- COMMAND: RandomSubset ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RandomSubset(L: LIST): LIST
RandomSubset(L: LIST, K: INT): LIST
\end{Verbatim}


\subsection*{Description}

This function returns a random subset of ``\verb&L&''; in the second form
it ensures that the cardinality of the subset is ``\verb&K&''.
\par 
The function can be quite useful for testing properties on some
subsets of a large list when testing on all of them would be
unfeasible in time and memory (see also ``\verb&subsets&'' (\ref{subsets} pg.\pageref{subsets})).
\par 
NOTE: the resulting list is sorted as in ``\verb&L&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ RandomSubset(["a","b","c","d","e","f","g","h"], 5);
["a", "c", "d", "f", "h"]

/**/ indent([RandomSubset(1..1000, 10) | i in 1..4]);
[
  [160, 182, 215, 219, 349, 588, 628, 811, 886, 905],
  [23, 103, 315, 451, 531, 539, 571, 846, 858, 876],
  [24, 230, 240, 278, 380, 421, 495, 505, 665, 788],
  [81, 274, 299, 378, 414, 616, 828, 844, 870, 946]
]
/**/ binomial(1000, 10);  --> too many to fit in memory ;-)
263409560461970212832400
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  random(\ref{random} pg.\pageref{random}), 
    subsets(\ref{subsets} pg.\pageref{subsets}), 
    RandomSubsetIndices(\ref{RandomSubsetIndices} pg.\pageref{RandomSubsetIndices}), 
    RandomTuple(\ref{RandomTuple} pg.\pageref{RandomTuple}), 
    RandomTupleIndices(\ref{RandomTupleIndices} pg.\pageref{RandomTupleIndices})
\end{command} % -- end command --------------------------------

\section{RandomSubsetIndices}
\label{RandomSubsetIndices}
\begin{command} % -- COMMAND: RandomSubsetIndices ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RandomSubsetIndices(N: INT): LIST
RandomSubsetIndices(N: INT, K: INT): LIST
\end{Verbatim}


\subsection*{Description}

These functions return a random subset of ``\verb&1..N&''; the second form
ensures that the cardinality is ``\verb&K&''.  See also ``\verb&RandomSubset&'' (\ref{RandomSubset} pg.\pageref{RandomSubset}).
\par 
NOTE: the resulting list is sorted.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ RandomSubsetIndices(10);
[1, 3, 4, 5, 8, 10]
/**/ RandomSubsetIndices(10, 3);
[2,  3,  6]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  random(\ref{random} pg.\pageref{random}), 
    subsets(\ref{subsets} pg.\pageref{subsets}), 
    RandomPermutation(\ref{RandomPermutation} pg.\pageref{RandomPermutation}), 
    RandomSubset(\ref{RandomSubset} pg.\pageref{RandomSubset}), 
    RandomTuple(\ref{RandomTuple} pg.\pageref{RandomTuple}), 
    RandomTupleIndices(\ref{RandomTupleIndices} pg.\pageref{RandomTupleIndices})
\end{command} % -- end command --------------------------------

\section{RandomTuple}
\label{RandomTuple}
\begin{command} % -- COMMAND: RandomTuple ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RandomTuple(L: LIST, K: INT): LIST
\end{Verbatim}


\subsection*{Description}

The function returns a random tuple of ``\verb&L&'' of cardinality ``\verb&K&''.
This function can be quite useful for testing properties on some
tuples of a large list when testing on all of them would be
unfeasible in time and memory (see also ``\verb&tuples&'' (\ref{tuples} pg.\pageref{tuples})).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ RandomTuple(["a","b","c","d","e","f","g","h"], 5);
["b", "b", "h", "g", "e"]

/**/ indent([RandomTuple(-9..9, 10) | i in 1..4]);
[
  [-5, -3, 1, 8, -4, 6, -5, -7, -1, 1],
  [-5, -8, 0, -9, -2, -1, 3, -6, 6, -3],
  [-2, -2, -9, -5, 0, -6, 2, -6, -5, -8],
  [-2, -4, 4, 3, -3, 5, 3, -1, 8, -7]
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  random(\ref{random} pg.\pageref{random}), 
    subsets(\ref{subsets} pg.\pageref{subsets}), 
    RandomSubset(\ref{RandomSubset} pg.\pageref{RandomSubset}), 
    RandomSubsetIndices(\ref{RandomSubsetIndices} pg.\pageref{RandomSubsetIndices}), 
    RandomTupleIndices(\ref{RandomTupleIndices} pg.\pageref{RandomTupleIndices})
\end{command} % -- end command --------------------------------

\section{RandomTupleIndices}
\label{RandomTupleIndices}
\begin{command} % -- COMMAND: RandomTupleIndices ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RandomTupleIndices(N: INT, K: INT): LIST
\end{Verbatim}


\subsection*{Description}

The function returns a random tuple of ``\verb&1..N&'' of
cardinality ``\verb&K&''.  See also ``\verb&RandomTuple&'' (\ref{RandomTuple} pg.\pageref{RandomTuple}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ RandomTupleIndices(32003, 10);
[4987, 13034, 10044, 7148, 11122, 1144, 21264, 5379, 2934, 7015]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  random(\ref{random} pg.\pageref{random}), 
    subsets(\ref{subsets} pg.\pageref{subsets}), 
    RandomSubset(\ref{RandomSubset} pg.\pageref{RandomSubset}), 
    RandomSubsetIndices(\ref{RandomSubsetIndices} pg.\pageref{RandomSubsetIndices}), 
    RandomTuple(\ref{RandomTuple} pg.\pageref{RandomTuple})
\end{command} % -- end command --------------------------------

\section{RandomUnimodularMat}
\label{RandomUnimodularMat}
\begin{command} % -- COMMAND: RandomUnimodularMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RandomUnimodularMat(R: RING, N: INT): MAT
RandomUnimodularMat(R: RING, N: INT, Niters: INT): MAT
\end{Verbatim}


\subsection*{Description}

The function returns a random ``\verb&N&''-by-``\verb&N&'' matrix with integer
entries, and determinant +1 or -1.  The matrix is over the ring ``\verb&R&''.
\par 
The optional 3rd argument says how many internal iterations to
perform: the algorithm starts with an identity matrix, then on each
iteration simply adds or substracts one random row to another random
row.  The default number of iterations is currently ``\verb&25*N&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ RandomUnimodularMat(ZZ, 3);
matrix(ZZ,
 [[-684, -2919, -769],
  [1054, 4498, 1185],
  [-519, -2215, -584]])
/**/ det(It);
1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  random(\ref{random} pg.\pageref{random})
\end{command} % -- end command --------------------------------

\section{rank [OBSOLESCENT]}
\label{rank [OBSOLESCENT]}
\begin{command} % -- COMMAND: rank [OBSOLESCENT] ------------



\subsection*{Description}

See ``\verb&rk&'' (\ref{rk} pg.\pageref{rk})

\end{command} % -- end command --------------------------------

\section{RationalSolve}
\label{RationalSolve}
\begin{command} % -- COMMAND: RationalSolve ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RationalSolve(L: LIST of RINGELEM): RECORD
\end{Verbatim}


\subsection*{Description}

This function computes all rational solutions (aka. points)
of a 0-dimensional polynomial system ``\verb&L&''; approximate
real solutions can be computed using ``\verb&ApproxSolve&'' (\ref{ApproxSolve} pg.\pageref{ApproxSolve}).
Projective solutions of a homogenous system can be obtained
using ``\verb&RationalSolveHomog&'' (\ref{RationalSolveHomog} pg.\pageref{RationalSolveHomog}).
\par 
Result is a ``\verb&record&'' saying which indeterminates are "active",
and list of the solution points.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  L := [x^3-y^2+z-1, x-2, (y-3)*(y+2)];
/**/  RationalSolve(L);
record[AffinePts := [[2, -2, -3], [2, 3, 2]],  indets := [x, y, z]]

/**/  L := [x^2+y^2-1, x*y-1];  -- indet z not used
/**/  RationalSolve(L);
record[AffinePts := [],  indets := [x, y]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ApproxSolve(\ref{ApproxSolve} pg.\pageref{ApproxSolve}), 
    LinSolve(\ref{LinSolve} pg.\pageref{LinSolve}), 
    RationalSolveHomog(\ref{RationalSolveHomog} pg.\pageref{RationalSolveHomog})
\end{command} % -- end command --------------------------------

\section{RationalSolveHomog}
\label{RationalSolveHomog}
\begin{command} % -- COMMAND: RationalSolveHomog ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RationalSolveHomog(L: LIST of RINGELEM): RECORD
\end{Verbatim}


\subsection*{Description}

This function computes all rational solutions (aka. projective points)
of a 1-dimensional homogeneous polynomial system ``\verb&L&''.  See
also ``\verb&RationalSolve&'' (\ref{RationalSolve} pg.\pageref{RationalSolve}) for solving 0-dimensional systems.
\par 
Result is a ``\verb&record&'' saying which indeterminates are "active",
and list of the solution points.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y,z];
/**/  L := [x^3-y^2*x, x-2*z];
/**/  RationalSolveHomog(L);
record[ProjectivePts := [[0, 1, 0], [1, -1, 1/2], [1, 1, 1/2]],  indets := [x, y, z]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  RationalSolve(\ref{RationalSolve} pg.\pageref{RationalSolve}), 
    LinSolve(\ref{LinSolve} pg.\pageref{LinSolve})
\end{command} % -- end command --------------------------------

\section{RatReconstructByContFrac}
\label{RatReconstructByContFrac}
\begin{command} % -- COMMAND: RatReconstructByContFrac ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RatReconstructByContFrac(X: INT, M: INT): RECORD
RatReconstructByContFrac(X: INT, M: INT, LogToler: INT): RECORD
\end{Verbatim}


\subsection*{Description}

These functions attempt to reconstruct rational numbers from a modular
image ``\verb&X mod M&''.
The result is a record: the boolean field ``\verb&failed&'' is ``\verb&true&''
if no \textbf{convincing} result was found; otherwise that field is ``\verb&false&'',
and a second field, called ``\verb&ReconstructedRat&'', contains the
value reconstructed.
\par 
The algorithms are \textbf{fault-tolerant}: they will succeed provided that
``\verb&X&'' is correct modulo a sufficiently large factor of ``\verb&M&''.
\par 
An optional third argument determines what \textbf{convincing} means: a higher
value gives a more reliable answer, but may need a larger modulus before the
answer is found.
\par 
There are two different underlying heuristic algorithms: a faster one
based on continued fractions, and a slower one based on 2-dimensional
lattice reduction (``\verb&RatReconstructByLattice&'' (\ref{RatReconstructByLattice} pg.\pageref{RatReconstructByLattice})).  
See the JSC paper by John Abbott:
"Fault-tolerant modular reconstruction of rational numbers",
``\verb&http://www.sciencedirect.com/science/article/pii/S0747717116300773&'';
a near-final version is at ``\verb&http://arxiv.org/abs/1303.2965&''.
\par 
NOTE: so that the heuristic can work, the modulus must be a bit larger
than strictly necessary; indeed, reconstruction will always fail if ``\verb&M&''
is too small.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  X := 3333333333;
/**/  M := 10^10;
/**/  RatReconstructByContFrac(X,M);
record[ReconstructedRat := -1/3, failed := false]

/**/  X := 3141592654;
/**/  M := 10^10;
/**/  RatReconstructByContFrac(X,M);
record[failed := true]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  RatReconstructWithBounds(\ref{RatReconstructWithBounds} pg.\pageref{RatReconstructWithBounds}), 
    RatReconstructByLattice(\ref{RatReconstructByLattice} pg.\pageref{RatReconstructByLattice}), 
    CRT(\ref{CRT} pg.\pageref{CRT})
\end{command} % -- end command --------------------------------

\section{RatReconstructByLattice}
\label{RatReconstructByLattice}
\begin{command} % -- COMMAND: RatReconstructByLattice ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RatReconstructByLattice(X: INT, M: INT): RECORD
RatReconstructByLattice(X: INT, M: INT, threshold: INT): RECORD
\end{Verbatim}


\subsection*{Description}

Same as ``\verb&RatReconstructByContFrac&'' (\ref{RatReconstructByContFrac} pg.\pageref{RatReconstructByContFrac}) but with a different
underlying heuristic algorithms, based on 2-dimensional lattice reduction.  
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  X := 3333333333;
/**/  M := 10^10;
/**/  RatReconstructByLattice(X,M);
record[ReconstructedRat := -1/3, failed := false]

/**/  X := 3141592654;
/**/  M := 10^10;
/**/  RatReconstructByLattice(X,M);
record[failed := true]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  RatReconstructWithBounds(\ref{RatReconstructWithBounds} pg.\pageref{RatReconstructWithBounds}), 
    RatReconstructByContFrac(\ref{RatReconstructByContFrac} pg.\pageref{RatReconstructByContFrac}), 
    CRT(\ref{CRT} pg.\pageref{CRT})
\end{command} % -- end command --------------------------------

\section{RatReconstructPoly}
\label{RatReconstructPoly}
\begin{command} % -- COMMAND: RatReconstructPoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RatReconstructPoly(f1: RINGELEM, M1: INT): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function attempts to reconstruct the rational coefficents of a
polynomial ``\verb&f&'' from a modular image ``\verb&f mod M&''.  
The algorithm is fault-tolerant: it will succeed provided
that the coefficients in ``\verb&f&'' are correct modulo a sufficiently
large factor of ``\verb&M&''.
\par 
NOTE: so that the heuristic can work, the modulus must be larger than
strictly necessary; indeed, reconstruction always fails if ``\verb&M&'' is small.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x,y];
/**/  RatReconstructPoly(10923689802589*x^2 +8192767351939*y, 32771069407757);
(10/3)*x^2 +(-1/4)*y

-- input comes from CTR computation:
/**/ RingElem(NewPolyRing(NewZZmod(32003),"x,y"), "(10/3)*x^2 +(-1/4)*y");
10671*x^2 -8001*y
/**/ RingElem(NewPolyRing(NewZZmod(31991),"x,y"), "(10/3)*x^2 +(-1/4)*y");
10667*x^2 -7998*y
/**/ RingElem(NewPolyRing(NewZZmod(32009),"x,y"), "(10/3)*x^2 +(-1/4)*y");
10673*x^2 +8002*y

/**/ CRTPoly(10671*x^2 -8001*y, 32003,    10667*x^2 -7998*y, 31991);
record[modulus := 1023807973, residue := -341269321*x^2 +255951993*y]
/**/ CRTPoly(It.residue, It.modulus,    10673*x^2 +8002*y, 32009);
record[modulus := 32771069407757,
      residue := 10923689802589*x^2 +8192767351939*y]
/**/ RatReconstructPoly(It.residue, It.modulus);
(10/3)*x^2 +(-1/4)*y
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CRTPoly(\ref{CRTPoly} pg.\pageref{CRTPoly}), 
    RatReconstructByContFrac(\ref{RatReconstructByContFrac} pg.\pageref{RatReconstructByContFrac}), 
    RatReconstructByLattice(\ref{RatReconstructByLattice} pg.\pageref{RatReconstructByLattice})
\end{command} % -- end command --------------------------------

\section{RatReconstructWithBounds}
\label{RatReconstructWithBounds}
\begin{command} % -- COMMAND: RatReconstructWithBounds ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RatReconstructWithBounds(e: INT, P: INT, Q: INT, res: LIST of INT, mod: LIST of INT): RECORD
\end{Verbatim}


\subsection*{Description}

This function attempts to reconstruct a rational number from a
collection of residue-modulus pairs ``\verb&(res[i],mod[i])&''.  The function
also requires the input of three bounds: ``\verb&e&'' is an upper bound on the
number of bad moduli, and ``\verb&P&'' and ``\verb&Q&'' are upper bounds for
(respectively the numerator and denominator of) the rational to be
reconstructed.
\par 
The result is a record: the boolean field ``\verb&failed&'' is ``\verb&true&''
if no result exists; otherwise it is ``\verb&false&'', and a second field,
called ``\verb&ReconstructedRat&'', contains the value reconstructed.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  moduli := [11,13,15,17,19];
/**/  residues := [-2, -5, 0, 7, 4];
/**/  RatReconstructWithBounds(1,10,10,residues,moduli);
record[ReconstructedRat := 1/5, failed := false]

/**/  RatReconstructWithBounds(0,10,10,residues,moduli);
record[failed := true]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CRT(\ref{CRT} pg.\pageref{CRT}), 
    RatReconstructByContFrac(\ref{RatReconstructByContFrac} pg.\pageref{RatReconstructByContFrac}), 
    RatReconstructByLattice(\ref{RatReconstructByLattice} pg.\pageref{RatReconstructByLattice})
\end{command} % -- end command --------------------------------

\section{ReadExpr [OBSOLESCENT]}
\label{ReadExpr [OBSOLESCENT]}
\begin{command} % -- COMMAND: ReadExpr [OBSOLESCENT] ------------



\subsection*{Description}

[OBSOLESCENT]
from version 5.2.0 ``\verb&RingElem&'' (\ref{RingElem} pg.\pageref{RingElem}) does the same, and more.

\end{command} % -- end command --------------------------------

\section{RealRootRefine}
\label{RealRootRefine}
\begin{command} % -- COMMAND: RealRootRefine ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RealRootRefine(Root: RECORD, Precision: RAT): RECORD
\end{Verbatim}


\subsection*{Description}

This function computes a refinement of a real root of a univariate
polynomial over ``\verb&QQ&'' to the desired precision (width of isolating
interval).  The starting root must be a record produced by ``\verb&RealRoots&'' (\ref{RealRoots} pg.\pageref{RealRoots}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x];
/**/  RR := RealRoots(x^2-2);
/**/  RealRootRefine(RR[1], 1/2);
record[CoeffList := [-1, 0, 2], inf := -3/2, sup := -5/4]

/**/  RR := [RealRootRefine(Root, 10^(-20)) | Root in RR];
/**/  FloatStr(RR[1].inf);
-1.414213562*10^0
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  RealRoots(\ref{RealRoots} pg.\pageref{RealRoots}), 
    RealRootsApprox(\ref{RealRootsApprox} pg.\pageref{RealRootsApprox}), 
    RootBound(\ref{RootBound} pg.\pageref{RootBound})
\end{command} % -- end command --------------------------------

\section{RealRoots}
\label{RealRoots}
\begin{command} % -- COMMAND: RealRoots ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RealRoots(F: RINGELEM): LIST
RealRoots(F: RINGELEM, Precision: RAT): LIST
RealRoots(F: RINGELEM, Precision: RAT, Interval:[RAT, RAT]): LIST
\end{Verbatim}


\subsection*{Description}

This function computes isolating intervals for the real roots of a
non-zero univariate polyomial over ``\verb&QQ&''.  It returns the list of the
real roots, where a root is represented as a record containing either
the exact root (if the fields ``\verb&inf&'' and ``\verb&sup&'' are equal), or an open
interval ``\verb&(inf, sup)&'' containing the root.  There is a third field
(called ``\verb&CoeffList&'') not intended for "public use".
\par 
An optional second argument specifies the maximum width an isolating
interval may have.  An optional third argument specifies a closed
interval in which to search for roots.
\par 
The interval represented by a root record may be refined by using the
function ``\verb&RealRootRefine&'' (\ref{RealRootRefine} pg.\pageref{RealRootRefine}).
\par 
The function ``\verb&RealRootsApprox&'' (\ref{RealRootsApprox} pg.\pageref{RealRootsApprox}) may be easier to use:
it produces rational approximations to the real roots (but these
cannot later be refined).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x];
/**/  indent(RealRoots(x^2-2));
[
  record[CoeffList := [-1, 0, 2], inf := -4, sup := 0],
  record[CoeffList := [1, 0, -2], inf := 0, sup := 4]
]

/**/  RR := RealRoots((x^2-2)*(x-1), 10^(-5));
/**/  FloatStr(RR[1].inf,10);  -- left end of interval
-1.414213562*10^0

/**/  FloatStr(RR[1].sup,10);  -- right end of interval
-1.414213561*10^0

/**/  RR := RealRoots(x^2-2, 10^(-20), [0, 2]);
/**/  FloatStr(RR[1].inf, 20);  -- print rational RR[1].inf in a comprehensible way
1.4142135623730950488*10^0
/**/  RR[1].inf;                -- actual raional is rather incomprehensible
60153992292001127886258443119406264231/42535295865117307932921825928971026432
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NumRealRoots(\ref{NumRealRoots} pg.\pageref{NumRealRoots}), 
    RealRootRefine(\ref{RealRootRefine} pg.\pageref{RealRootRefine}), 
    RealRootsApprox(\ref{RealRootsApprox} pg.\pageref{RealRootsApprox}), 
    RootBound(\ref{RootBound} pg.\pageref{RootBound})
\end{command} % -- end command --------------------------------

\section{RealRootsApprox}
\label{RealRootsApprox}
\begin{command} % -- COMMAND: RealRootsApprox ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RealRootsApprox(F: RINGELEM): LIST
RealRootsApprox(F: RINGELEM, Precision: RAT): LIST
RealRootsApprox(F: RINGELEM, Precision: RAT, Interval:[RAT, RAT]): LIST
\end{Verbatim}


\subsection*{Description}

This function computes rational approximations to the real roots of a
univariate polyomial (with rational coefficients).
\par 
An optional second argument specifies the maximum separation between
the approximations produced and the corresponding exact root.  An
optional third argument specifies a closed interval in which to search
for roots.
\par 
NOTE: the value of ``\verb&F&'' at an approximate root may not be small;
see also ``\verb&ApproxSolve&'' (\ref{ApproxSolve} pg.\pageref{ApproxSolve}) which uses a heuristic to produce approximate
roots such that the evaluation is also "small".
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x];
/**/  RealRootsApprox(x^2-2);
[-3037000499/2147483648, 3037000499/2147483648]

/**/  RR := RealRootsApprox(x^2-2, 10^(-15), [0, 2]);
/**/  FloatStr(RR[1], 15); --> print as a decimal, easier to read
1.41421356237310*10^0
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ApproxSolve(\ref{ApproxSolve} pg.\pageref{ApproxSolve}), 
    RealRoots(\ref{RealRoots} pg.\pageref{RealRoots}), 
    RootBound(\ref{RootBound} pg.\pageref{RootBound})
\end{command} % -- end command --------------------------------

\section{record}
\label{record}
\begin{command} % -- COMMAND: record ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
record[F_1 := OBJECT,..., F_n := OBJECT]
  where each F_i is a field name
  returns RECORD
\end{Verbatim}


\subsection*{Description}

This constructor creates a record with fields called ``\verb&F_1&'',...,``\verb&F_n&''.
The empty record is given by ``\verb&record[]&''.

Records in CoCoA are \textbf{open} in the sense that new fields may be
added after the record is first defined.  The names allowed for the
fields are the same as those allowed for variables.
\par 
The dot operator is used to access the fields in a record.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  P := record[height := 10, width := 5];
/**/  P.height * P.width;
50

/**/  P.area := It;  --> creates a new field called "area"
/**/  P;
record[area := 50, height := 10, width := 5]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  record field selector(\ref{record field selector} pg.\pageref{record field selector}), 
    fields(\ref{fields} pg.\pageref{fields})
\end{command} % -- end command --------------------------------

\section{record field selector}
\label{record field selector}
\begin{command} % -- COMMAND: record field selector ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
R.FieldName
R["FieldName"]
  where R is a RECORD
\end{Verbatim}


\subsection*{Description}

A record is a data structure containing named entries.  They are created
using the command ``\verb&record&'' (\ref{record} pg.\pageref{record}).  Each entry may be selected
using the "dot operator", or equivalently via a string index.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  rec := record[name := "David", year := 1961];
/**/  rec.name;
David

/**/  rec.year := 1849;             --> change value of a field
/**/  rec.surname := "Copperfield"; --> create a new field
/**/  rec["year"];  -- alternative syntax
1849

/**/  foreach F in fields(rec) do print rec[F]; endforeach;
DavidCopperfield1849
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  record(\ref{record} pg.\pageref{record}), 
    fields(\ref{fields} pg.\pageref{fields})
\end{command} % -- end command --------------------------------

\section{ReducedGBasis}
\label{ReducedGBasis}
\begin{command} % -- COMMAND: ReducedGBasis ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ReducedGBasis(I: IDEAL): LIST of RINGELEM
ReducedGBasis(I: MODULE): LIST of MODULEELEM
\end{Verbatim}


\subsection*{Description}

This function returns a list whose elements form a reduced Groebner
basis for the ideal (or module) ``\verb&I&'' with respect to the term-ordering
of the polynomial ring of ``\verb&I&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  I := ideal(x^4-x^2, x^3-y);
/**/  ReducedGBasis(I);
[x*y -y^2, x^2 -y^2, y^3 -y]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GBasis(\ref{GBasis} pg.\pageref{GBasis})
\end{command} % -- end command --------------------------------

\section{ref}
\label{ref}
\begin{command} % -- COMMAND: ref ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ref X
  where X is the identifier of a CoCoA variable.
\end{Verbatim}


\subsection*{Description}

The keyword ``\verb&ref&'' is used to pass a parameter "by reference" to a
function which may modify its value (\textit{e.g.} ``\verb&append&'' (\ref{append} pg.\pageref{append})).
The keyword ``\verb&ref&'' alerts the programmer to the possibility that the
value may be changed during the call.
\par 
To write a new function which can modify some parameters use the same
keyword ``\verb&ref&'' to identify which formal parameters are to be passed
by reference.  The following example illustrates the difference between
passing by reference and passing by value.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ Define CallByRef(ref L)  -- "call by reference": The variable referred
/**/   L := "new value";       -- to by L is changed.
/**/ EndDefine;
/**/ M := "old value";
/**/ CallByRef(ref M);  -- here "ref" recalls that M might change
/**/ PrintLn M;
new value

/**/ Define CallByVal(L)  -- "call by value": The value of L is passed to
/**/   L := "new value";  -- the function.
/**/   Return L;
/**/ EndDefine;
/**/ L := "old value";
/**/ CallByVal(L);
new value

/**/  PrintLn L;
old value
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  define(\ref{define} pg.\pageref{define})
\end{command} % -- end command --------------------------------

\section{RefineGCDFreeBasis [OBSOLETE]}
\label{RefineGCDFreeBasis [OBSOLETE]}
\begin{command} % -- COMMAND: RefineGCDFreeBasis [OBSOLETE] ------------



\subsection*{Description}

OBSOLETE.  Just build a new list and call ``\verb&CoprimeFactorBasis&'' (\ref{CoprimeFactorBasis} pg.\pageref{CoprimeFactorBasis}).

\SeeAlso %---- SEE ALSO ----
  CoprimeFactorBasis(\ref{CoprimeFactorBasis} pg.\pageref{CoprimeFactorBasis})
\end{command} % -- end command --------------------------------

\section{reg}
\label{reg}
\begin{command} % -- COMMAND: reg ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
reg(I: IDEAL): INT
reg(R: (Quotient)RING): INT
\end{Verbatim}


\subsection*{Description}

These functions compute the Castelnuovo-Mumford regularity of an ideal.
The implementation of ``\verb&Reg&'' using Bermejo-Gimenez Algorithm.
\par 
Implemented by Eduardo Saenz-de-Cabezon (updated to CoCoA-5 by Anna M. Bigatti).
\par 
NOTE: this is different from ``\verb&RegularityIndex&'' (\ref{RegularityIndex} pg.\pageref{RegularityIndex}), the regularity
of a Hilbert Function.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x^3, y^2);
/**/  reg(I);
4
/**/  reg(R/I);
3
/**/  PrintRes(I);
0 --> R(-5) --> R(-2)(+)R(-3)

/**/  PrintBettiDiagram(I);
        0    1
---------------
  2:    1    -
  3:    1    -
  4:    -    1
---------------
Tot:    2    1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  res(\ref{res} pg.\pageref{res}), 
    PrintRes(\ref{PrintRes} pg.\pageref{PrintRes}), 
    PrintBettiDiagram(\ref{PrintBettiDiagram} pg.\pageref{PrintBettiDiagram}), 
    PrintBettiMatrix(\ref{PrintBettiMatrix} pg.\pageref{PrintBettiMatrix}), 
    RegularityIndex(\ref{RegularityIndex} pg.\pageref{RegularityIndex})
\end{command} % -- end command --------------------------------

\section{RegularityIndex}
\label{RegularityIndex}
\begin{command} % -- COMMAND: RegularityIndex ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RegularityIndex(R: (Poly or Quotient)RING): INT
\end{Verbatim}


\subsection*{Description}

This function computes the regularity index of a Hilbert function.
The input might be expressed as a Hilbert function or as the
corresponding Hilbert series (computed with standard weights).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  Quot := R/ideal(x^3, y^2);
/**/  HilbertFn(Quot);
H(0) = 1
H(1) = 3
H(2) = 5
H(t) = 6   for t >= 3
/**/  RegularityIndex(HilbertFn(Quot));
3
/**/  RegularityIndex(HilbertSeries(Quot));
3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  HilbertFn(\ref{HilbertFn} pg.\pageref{HilbertFn}), 
    HilbertSeries(\ref{HilbertSeries} pg.\pageref{HilbertSeries})
\end{command} % -- end command --------------------------------

\section{RelNotes}
\label{RelNotes}
\begin{command} % -- COMMAND: RelNotes ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RelNotes()
RelNotes(N: INT)
\end{Verbatim}


\subsection*{Description}

This function prints the release notes of the version you are running,
of all versions, or of last ``\verb&N&'' versions.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ RelNotes();  --> last version
/**/ RelNotes(1); --> last version
/**/ RelNotes(3); --> last 3 versions
/**/ RelNotes(0); --> all versions
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  VersionInfo(\ref{VersionInfo} pg.\pageref{VersionInfo})
\end{command} % -- end command --------------------------------

\section{ReloadMan}
\label{ReloadMan}
\begin{command} % -- COMMAND: ReloadMan ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ReloadMan()
ReloadMan(ListOfFiles: LIST)
\end{Verbatim}


\subsection*{Description}

This function reloads the xml source of the manual ``\verb&CoCoAHelp.xml&''
(in directory ``\verb&CoCoAManual&'') and the optional list of manual extensions:
it recreates the internal manual \textbf{index} in a running CoCoA-5.
\par 
Some details: after adding a new entry, the \textbf{index} needs updating.
But if the change is just in the description of an existing entry (so the
internal \textbf{index} is still valid) there is no need to reload the manual
because the descriptions are always read from disk.
\par 
NOTE: This function is useful for those who develop a CoCoA package
and want to test/add/offer its manual in proper CoCoA style.  Such
manual extensions will be included in ``\verb&CoCoAHelp.xml&'' if the
package is generously offered for distribution with CoCoA :-)
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ ReloadMan();  // reloads the official manual only
/**/ // for loading manual extensions, official manual+ file1 + file2:
/**/ ReloadMan(["path1/file1.xml", "path2/file2.xml"]);
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{remove}
\label{remove}
\begin{command} % -- COMMAND: remove ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
remove(ref L: LIST, N: INT)
\end{Verbatim}


\subsection*{Description}

This function removes the ``\verb&N&''-th component from ``\verb&L&''; it changes the value of ``\verb&L&''.
Use the function ``\verb&WithoutNth&'' (\ref{WithoutNth} pg.\pageref{WithoutNth}) to create a new list containing the
elements of ``\verb&L&'' except the ``\verb&N&''-th (without changing ``\verb&L&'').
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  L := indets(R);
/**/  L;
[x, y, z]

/**/  remove(ref L,2);
/**/  L;
[x, z]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  diff(\ref{diff} pg.\pageref{diff}), 
    WithoutNth(\ref{WithoutNth} pg.\pageref{WithoutNth})
\end{command} % -- end command --------------------------------

\section{repeat}
\label{repeat}
\begin{command} % -- COMMAND: repeat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
repeat C until B
repeat C endrepeat
(where C is a sequence of commands and B is BOOL)
\end{Verbatim}


\subsection*{Description}

In the first form, the command sequence ``\verb&C&'' is repeated until ``\verb&B&''
evaluates to ``\verb&false&''.
Unlike the ``\verb&while&'' (\ref{while} pg.\pageref{while}) command, ``\verb&C&'' is executed at least once.
\par 
NOTE: there is no ``\verb&endrepeat&'' following the condition ``\verb&B&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/      Define GCD_Euclid(A, B)
/**/        Repeat
/**/          R := mod(A, B);
/**/          A := B;
/**/          B := R;
/**/         Until B = 0;
/**/        Return A;
/**/      EndDefine;

/**/  GCD_Euclid(6,15);
3

/**/  N := 0;
/**/  repeat
/**/    N := N+1;
/**/    PrintLn N;
/**/    If N > 5 Then Break; EndIf;
/**/  endrepeat;
1
2
3
4
5
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  for(\ref{for} pg.\pageref{for}), 
    foreach(\ref{foreach} pg.\pageref{foreach}), 
    All CoCoA commands(\ref{All CoCoA commands} pg.\pageref{All CoCoA commands}), 
    while(\ref{while} pg.\pageref{while})
\end{command} % -- end command --------------------------------

\section{res}
\label{res}
\begin{command} % -- COMMAND: res ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
res(M: IDEAL): LIST
res(M: MODULE): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the minimal free resolution of ``\verb&M&''.
``\verb&res&'' only works in the homogeneous context, and the coefficient ring
must be a field.
\par 
NOTE: the current implementation (CoCoA-5.1.0) is very naive so it
might be very slow (better slow than nothing?).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x, y, z^2);
/**/  PrintRes(R/I);
0 --> R(-4) --> R(-2)(+)R(-3)^2 --> R(-1)^2(+)R(-2) --> R
/**/  indent(Res(R/I),2);
[
  RingWithID(20, "RingWithID(3)/ideal(x, y, z^2)"),
  ideal(
    y,
    x,
    z^2
  ),
  SubmoduleRows(F, matrix([
    [x, -y, 0],
    [0, z^2, -x],
    [z^2, 0, -y]
  ])),
  SubmoduleRows(F, matrix([
    [z^2, y, -x]
  ]))
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PrintBettiDiagram(\ref{PrintBettiDiagram} pg.\pageref{PrintBettiDiagram}), 
    PrintBettiMatrix(\ref{PrintBettiMatrix} pg.\pageref{PrintBettiMatrix}), 
    PrintRes(\ref{PrintRes} pg.\pageref{PrintRes})
\end{command} % -- end command --------------------------------

\section{reseed}
\label{reseed}
\begin{command} % -- COMMAND: reseed ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
reseed(N: INT): VOID
\end{Verbatim}


\subsection*{Description}

CoCoA offers a pseudo-random number generator (see ``\verb&random&'' (\ref{random} pg.\pageref{random})); however,
each time you start CoCoA it will produce the same random values.  The
procedure ``\verb&reseed&'' puts the pseudo-random number generator into a state
determined solely by the given seed value ``\verb&N&''.  This procedure can be
used to make CoCoA generate different random values on different runs,
\textit{e.g.} if reseeded with a value which depends on the current time.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  reseed(123);
/**/  random(0,9);
7
/**/  reseed(1000000*date()+TimeOfDay());   --> time-dependent seed value
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  random(\ref{random} pg.\pageref{random})
\end{command} % -- end command --------------------------------

\section{Reset [OBSOLETE]}
\label{Reset [OBSOLETE]}
\begin{command} % -- COMMAND: Reset [OBSOLETE] ------------



\subsection*{Description}

[OBSOLETE]

\end{command} % -- end command --------------------------------

\section{ResetPanels [OBSOLETE]}
\label{ResetPanels [OBSOLETE]}
\begin{command} % -- COMMAND: ResetPanels [OBSOLETE] ------------



\subsection*{Description}

[OBSOLETE]

\end{command} % -- end command --------------------------------

\section{resultant}
\label{resultant}
\begin{command} % -- COMMAND: resultant ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
resultant(F: RINGELEM, G: RINGELEM): RINGELEM
resultant(F: RINGELEM, G: RINGELEM, X: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

These functions compute the resultant of the polynomials ``\verb&F&'' and ``\verb&G&'' with
respect to the indeterminate ``\verb&X&''; in the first form ``\verb&F&'' and ``\verb&G&''
must be univariate, and ``\verb&X&'' is taken to be their common indeterminate. 
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[p,q,x];
/**/  F := x^3+p*x-q;   G := deriv(F, x);
/**/  resultant(F, G, x);
4*p^3 +27*q^2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  discriminant(\ref{discriminant} pg.\pageref{discriminant}), 
    SylvesterMat(\ref{SylvesterMat} pg.\pageref{SylvesterMat})
\end{command} % -- end command --------------------------------

\section{return}
\label{return}
\begin{command} % -- COMMAND: return ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
return
return E
\end{Verbatim}


\subsection*{Description}

This command is used to exit from a procedure/function.  The
second form returns the value of the expression E to the user.
As a safety measure all ``\verb&return&''s in a function/procedure must
be of the same kind: either they all return a value (function)
or none of them returns a value (procedure).

``\verb&return&'' has immediate effect even inside loops; compare with ``\verb&break&'' (\ref{break} pg.\pageref{break}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Define Rev(L) -- reverse a list
/**/    If len(L) < 2 Then Return L; EndIf;
/**/    M := Rev(Tail(L)); -- recursive function call
/**/    append(ref M, L[1]);
/**/    Return M;
/**/  EndDefine;

/**/  Rev([1,2,3,4]);
[4, 3, 2, 1]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  break(\ref{break} pg.\pageref{break}), 
    define(\ref{define} pg.\pageref{define}), 
    All CoCoA commands(\ref{All CoCoA commands} pg.\pageref{All CoCoA commands})
\end{command} % -- end command --------------------------------

\section{reverse, reversed}
\label{reverse, reversed}
\begin{command} % -- COMMAND: reverse, reversed ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
reverse(ref L: LIST)
reversed(L: LIST): LIST
\end{Verbatim}


\subsection*{Description}

The function ``\verb&reverse&'' reverses the order of the elements of the
list ``\verb&L&''; it changes the value of ``\verb&L&'' and returns nothing.
The function ``\verb&reversed&'' returns the reversed list without changing ``\verb&L&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [1,2,3,4];
/**/  reverse(ref L);
/**/  L;  -- L has been modified
[4, 3, 2, 1]

/**/  M := [1,2,3,4];
/**/  reversed(M);  -- the reversed list is returned
[4, 3, 2, 1]

/**/  M;  -- M has not been modified
[1, 2, 3, 4]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  sort(\ref{sort} pg.\pageref{sort}), 
    sorted(\ref{sorted} pg.\pageref{sorted})
\end{command} % -- end command --------------------------------

\section{RevLexMat}
\label{RevLexMat}
\begin{command} % -- COMMAND: RevLexMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RevLexMat(N: INT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the matrix defining a standard ordering (which is
not a term-ordering!).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  RevLexMat(3);
matrix(ZZ,
 [[0, 0, -1],
  [0, -1, 0],
  [-1, 0, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  OrdMat(\ref{OrdMat} pg.\pageref{OrdMat}), 
    Term Orderings(\ref{Term Orderings} pg.\pageref{Term Orderings}), 
    StdDegRevLexMat(\ref{StdDegRevLexMat} pg.\pageref{StdDegRevLexMat}), 
    StdDegLexMat(\ref{StdDegLexMat} pg.\pageref{StdDegLexMat}), 
    LexMat(\ref{LexMat} pg.\pageref{LexMat}), 
    XelMat(\ref{XelMat} pg.\pageref{XelMat})
\end{command} % -- end command --------------------------------

\section{rgin}
\label{rgin}
\begin{command} % -- COMMAND: rgin ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
rgin(I: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

These functions return the [probabilistic] rgin
(generic initial ideal wrt StdDegRevLex) of the ideal ``\verb&I&''.
\par 
See ``\verb&gin&'' (\ref{gin} pg.\pageref{gin}) for details and verbosity.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z], DegLex;
/**/  I := ideal(y^2-x*z, x^2*z-y*z^2);
/**/  gin(I);
ideal(x^2, x*y^2, x*y*z^2, x*z^4, y^6)

/**/  rgin(I);  
ideal(x^2, x*y^2, y^4)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  gin(\ref{gin} pg.\pageref{gin}), 
    LT(\ref{LT} pg.\pageref{LT})
\end{command} % -- end command --------------------------------

\section{RingElem}
\label{RingElem}
\begin{command} % -- COMMAND: RingElem ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RingElem(R: RING, E: STRING): RINGELEM
RingElem(R: RING, E: RINGELEM): RINGELEM
RingElem(R: RING, E: INT): RINGELEM
RingElem(R: RING, E: RAT): RINGELEM
RingElem(R: RING, E:[STRING, INT, .., INT]): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function converts the expression ``\verb&E&'' into a RINGELEM in ``\verb&R&'',
if possible.  These functions areuseful for operating with different rings.
\par 
If ``\verb&E&'' is a ``\verb&STRING&'' it evaluates ``\verb&E&'' in ``\verb&R&'',
(with no need for ``\verb&use R&'').  The expression ``\verb&E&'' may contain
arithmetic operations and parentheses (but no programming variables or
function calls).  Use ``\verb&RingElemList, RingElems&'' (\ref{RingElemList, RingElems} pg.\pageref{RingElemList, RingElems}) to read many
(comma-separated) ringelems into a list.
\par 
If ``\verb&E&'' is a RINGELEM it is equivalent to applying the 
``\verb&CanonicalHom&'' (\ref{CanonicalHom} pg.\pageref{CanonicalHom}) from ``\verb&RingOf(E)&'' to ``\verb&R&''
(for other homomorphisms see ``\verb&RINGHOM&'' (\ref{RINGHOM} pg.\pageref{RINGHOM})).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ P ::= ZZ/(5)[x,y];  S ::= QQ[x,y,z[1..4]];  K := NewFractionField(S);
/**/ QR := NewQuotientRing(S, "x^2-3, y^2-5");

/**/  -- STRING
/**/  RingElem(P, "7*x");  --> 7*x as an element of P
2*x
/**/  RingElem(S, "7*x");  --> 7*x as an element of S
7*x
/**/  RingElem(S, "((7/3)*z[2] - 1)^2" ); -- expr without function calls
(49/9)*z[2]^2 +(-14/3)*z[2] +1
/**/  RingElem(K, "(x^2-x*y)/(x*y-y^2)");
x/y
/**/ RingElem(QR, "(x+y)^3");
(18*x +14*y)

/**/  -- RINGELEM (via CanonicalHom)
/**/  use S;
/**/  f := 2*x-3;
-- /**/  1/f; --> !!! ERROR !!! as expected: f in P is not invertible
/**/  1/RingElem(K, f); -- f in K is invertible
1/(2*x -3)

/**/  use P;
/**/  -- INT and RAT
/**/  RingElem(P, 7);
2
/**/  RingElem(P, 3/2);
-1

/**/  -- LIST for indexed indets
/**/  i := 2;  RingElem(S, ["z",i]); 
z[2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  RingElemList, RingElems(\ref{RingElemList, RingElems} pg.\pageref{RingElemList, RingElems}), 
    RingOf(\ref{RingOf} pg.\pageref{RingOf}), 
    AsINT(\ref{AsINT} pg.\pageref{AsINT}), 
    AsRAT(\ref{AsRAT} pg.\pageref{AsRAT}), 
    IndetName(\ref{IndetName} pg.\pageref{IndetName}), 
    IndetSubscripts(\ref{IndetSubscripts} pg.\pageref{IndetSubscripts}), 
    CanonicalHom(\ref{CanonicalHom} pg.\pageref{CanonicalHom}), 
    sprint(\ref{sprint} pg.\pageref{sprint})
\end{command} % -- end command --------------------------------

\section{RingElemList, RingElems}
\label{RingElemList, RingElems}
\begin{command} % -- COMMAND: RingElemList, RingElems ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RingElems(R: RING, S: STRING): LIST of RINGELEM
RingElemList(R: RING, S: STRING): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

These functions convert the string ``\verb&S&'' into a LIST of RINGELEM in ``\verb&R&'';
the only difference is that ``\verb&RingElemList&'' expects the list of values
in the string to be inside square brackets.  The successive values in ``\verb&S&''
must be comma separated.
\par 
The expressions in ``\verb&S&'' may contain arithmetic operations and parentheses
(but no programming variables nor function calls).  These functions are
useful for operating with different rings (without needing to call the
``\verb&use&'' (\ref{use} pg.\pageref{use}) command).
\par 
``\verb&RingElems&'' from version 5.3.0; ``\verb&RingElemList&'' from version 5.4.0.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ P ::= ZZ/(5)[x,y];   S ::= QQ[x,y,z[1..4]];

/**/  RingElems(P, "x^2, (x-3*y)^5");  --> elements of P
[x^2,  x^5 +2*y^5]
/**/  RingElemList(S, "[x^2, (x-3*y)^5]");  --> elements of S
[x^2,  x^5 -15*x^4*y +90*x^3*y^2 -270*x^2*y^3 +405*x*y^4 -243*y^5]

-- even for making ideals in new rings:
/**/  I := ideal(RingElems(NewPolyRing(QQ, "i"), "i^2 +1"));  I;
ideal(i^2 +1)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  RingOf(\ref{RingOf} pg.\pageref{RingOf}), 
    RingElem(\ref{RingElem} pg.\pageref{RingElem}), 
    NewQuotientRing(\ref{NewQuotientRing} pg.\pageref{NewQuotientRing}), 
    PolyAlgebraHom(\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}), 
    sprint(\ref{sprint} pg.\pageref{sprint})
\end{command} % -- end command --------------------------------

\section{RingEnv [OBSOLETE]}
\label{RingEnv [OBSOLETE]}
\begin{command} % -- COMMAND: RingEnv [OBSOLETE] ------------



\subsection*{Description}

See ``\verb&RingOf&'' (\ref{RingOf} pg.\pageref{RingOf}).

\SeeAlso %---- SEE ALSO ----
  RingOf(\ref{RingOf} pg.\pageref{RingOf})
\end{command} % -- end command --------------------------------

\section{RingID}
\label{RingID}
\begin{command} % -- COMMAND: RingID ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RingID(R: RING): INT
\end{Verbatim}


\subsection*{Description}

This function is likely useful only for debugging.  It returns the
identification number of the ring ``\verb&R&''.
\par 
NOTE: that CoCoA considers two rings to be equal if and only if they
have the same ID.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ R ::= QQ[x,y,z];
/**/ S ::= QQ[x,y,z]; // creates a separate copy
/**/ R = S;
false
/**/ RingID(R);
7
/**/ RingID(S);
8
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  print(\ref{print} pg.\pageref{print}), 
    println(\ref{println} pg.\pageref{println}), 
    Evaluation and Assignment(\ref{Evaluation and Assignment} pg.\pageref{Evaluation and Assignment})
\end{command} % -- end command --------------------------------

\section{RingOf}
\label{RingOf}
\begin{command} % -- COMMAND: RingOf ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RingOf(E: RINGELEM|IDEAL|MAT|MODULE): RING
\end{Verbatim}


\subsection*{Description}

This function returns the ring on which the object ``\verb&E&'' is defined.
\par 
NOTE: A ring contains many information and two separate rings, even when
defined with the same commands, are not "equal".  Also, when a ring
is printed only limited information is shown, so different rings might
print out the same
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x,y);
/**/  RingOf(I);
RingWithID(6, "QQ[x,y,z]")

/**/  RingOf(mat([[1,2],[3,4]]));
QQ

/**/  use Qabc ::= QQ[a,b,c];
/**/  F := a^2+b;
/**/  G := a*b+b^2;
/**/  use S ::=ZZ/(3)[x,y];
/**/  RingOf(F+G);  -- F+G is computed in the ring of definition
RingWithID(7, "QQ[a,b,c]")
/**/  indets(RingOf(F));
[a, b, c]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CoeffRing(\ref{CoeffRing} pg.\pageref{CoeffRing}), 
    CurrentRing(\ref{CurrentRing} pg.\pageref{CurrentRing}), 
    RingsOf(\ref{RingsOf} pg.\pageref{RingsOf}), 
    BaseRing(\ref{BaseRing} pg.\pageref{BaseRing})
\end{command} % -- end command --------------------------------

\section{RingQQ}
\label{RingQQ}
\begin{command} % -- COMMAND: RingQQ ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RingQQ(): RING
\end{Verbatim}


\subsection*{Description}

This function returns the ring of rationals.
It is particularly useful when you want to use ``\verb&QQ&''
(which is a pre-defined top-level \textbf{variable}) inside a function.
\par 
NOTE: calling ``\verb&RingQQ&'' twice gives the same identical ring,
whereas calling ``\verb&NewPolyRing&'' (\ref{NewPolyRing} pg.\pageref{NewPolyRing}) and ``\verb&NewFractionField&'' (\ref{NewFractionField} pg.\pageref{NewFractionField})
return each time a new ring.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  QQ = RingQQ();

/**/  Two := RingElem(RingQQ(), 2);   Two;
2
/**/  type(Two);
RINGELEM;
/**/  IsQQ(RingOf(Two));
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  TopLevel(\ref{TopLevel} pg.\pageref{TopLevel}), 
    QQ(\ref{QQ} pg.\pageref{QQ}), 
    RingQQt(\ref{RingQQt} pg.\pageref{RingQQt}), 
    RingZZ(\ref{RingZZ} pg.\pageref{RingZZ})
\end{command} % -- end command --------------------------------

\section{RingQQt}
\label{RingQQt}
\begin{command} % -- COMMAND: RingQQt ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RingQQt(N: INT): RING
\end{Verbatim}


\subsection*{Description}

This function returns a polynomial ring over ``\verb&QQ&'' with indeterminates $t[1]...t[N]$.
In particular ``\verb&RingQQt(1)&'' is the polynomial ring in which Hilbert
polynomials are defined.
\par 
NOTE: calling ``\verb&RingQQt(2)&'' twice gives the same identical ring,
whereas calling ``\verb&NewPolyRing(QQ, "t[1],t[2]");&''
returns each time a new ring (therefore incompatible).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  QQt := RingQQt(3);  use QQt;
/**/  (t[1]+1)^3;
t[1]^3 +3*t[1]^2 +3*t[1] +1
/**/  indets(RingQQt(1));
[t]
/**/  indets(RingQQt(5));
[t[1], t[2], t[3], t[4], t[5]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  TopLevel(\ref{TopLevel} pg.\pageref{TopLevel}), 
    RingQQ(\ref{RingQQ} pg.\pageref{RingQQ}), 
    RingZZ(\ref{RingZZ} pg.\pageref{RingZZ})
\end{command} % -- end command --------------------------------

\section{RingSet [OBSOLETE]}
\label{RingSet [OBSOLETE]}
\begin{command} % -- COMMAND: RingSet [OBSOLETE] ------------



\subsection*{Description}

Renamed ``\verb&RingsOf&'' (\ref{RingsOf} pg.\pageref{RingsOf})

\SeeAlso %---- SEE ALSO ----
  RingsOf(\ref{RingsOf} pg.\pageref{RingsOf})
\end{command} % -- end command --------------------------------

\section{RingsOf}
\label{RingsOf}
\begin{command} % -- COMMAND: RingsOf ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RingsOf(E: LIST|RINGELEM|IDEAL|MAT|MODULE|MODULEELEM): LIST of RING and TYPE
\end{Verbatim}


\subsection*{Description}

This function returns the list of the RINGs (or types, if not
dependent from a RING) on which the object E is dependent.
Similar to ``\verb&RingOf&'' (\ref{RingOf} pg.\pageref{RingOf}), this function also works on lists
and returns the set of ring environments of all entries.
...needless to say that it may be quite slow on big inputs!
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  L1 := [x, y];
/**/  L2 := [x, y, 0, 5/4];
/**/  Z3 := NewZZmod(3);
/**/  use S ::= Z3[a,b];
/**/  RingsOf(L1);
[RingDistrMPolyClean(QQ, 3)]

/**/  RingsOf(L2);
[RingDistrMPolyClean(QQ, 3), INT, RAT]

/**/  RingsOf([L2, a+b]);
[RingDistrMPolyClean(QQ, 3), INT, RAT, RingDistrMPolyClean(FFp(3), 2)]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CurrentRing(\ref{CurrentRing} pg.\pageref{CurrentRing}), 
    RingOf(\ref{RingOf} pg.\pageref{RingOf})
\end{command} % -- end command --------------------------------

\section{RingZZ}
\label{RingZZ}
\begin{command} % -- COMMAND: RingZZ ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RingZZ(): RING
\end{Verbatim}


\subsection*{Description}

This function returns the ring of integers.
It is useful when you want to use ``\verb&ZZ&'' (\ref{ZZ} pg.\pageref{ZZ}) inside ``\verb&define/enddefine&''.
\par 
NOTE: calling ``\verb&RingZZ&'' twice gives the same identical ring,
whereas calling ``\verb&NewPolyRing&'' (\ref{NewPolyRing} pg.\pageref{NewPolyRing}) or ``\verb&NewFractionField&'' (\ref{NewFractionField} pg.\pageref{NewFractionField})
return each time a new ring.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Two := RingElem(RingZZ(), 2);   Two;
2
/**/  type(Two);
RINGELEM;
/**/  IsZZ(RingOf(Two));
true
/**/  IsQQ(RingOf(Two));
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  TopLevel(\ref{TopLevel} pg.\pageref{TopLevel}), 
    RingQQt(\ref{RingQQt} pg.\pageref{RingQQt}), 
    RingQQ(\ref{RingQQ} pg.\pageref{RingQQ}), 
    ZZ(\ref{ZZ} pg.\pageref{ZZ})
\end{command} % -- end command --------------------------------

\section{rk}
\label{rk}
\begin{command} % -- COMMAND: rk ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
rk(M: MAT): INT
rk(M: MODULE): INT
\end{Verbatim}


\subsection*{Description}

This function computes the rank of ``\verb&M&''.  For a module ``\verb&M&'' this is defined
as the vector space dimension of the subspace generated by the generators
of ``\verb&M&'' over the quotient field of the base ring -- contrast this with the
function ``\verb&NumCompts&'' (\ref{NumCompts} pg.\pageref{NumCompts}) which simply counts the number of
components the module has.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  rk(IdentityMat(R, 4));
4

  rk(Module([x,y,z,0])); --***WORK IN PROGRESS***
1
-------------------------------
  rk(Module([[1,2,3],[2,4,6]]));   --***WORK IN PROGRESS***
1
-------------------------------
  rk(Module([[1,2,3],[2,5,6]]));   --***WORK IN PROGRESS***
2
-------------------------------
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{RMap [OBSOLESCENT]}
\label{RMap [OBSOLESCENT]}
\begin{command} % -- COMMAND: RMap [OBSOLESCENT] ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
[OBSOLESCENT] RMap(L: LIST)): TAGGED("RMap")
\end{Verbatim}


\subsection*{Description}

[OBSOLESCENT] related with ``\verb&image [OBSOLESCENT]&'' (\ref{image [OBSOLESCENT]} pg.\pageref{image [OBSOLESCENT]}).
In CoCoA-5 such homomorphisms are properly implemented as ``\verb&PolyAlgebraHom&'' (\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}).

\end{command} % -- end command --------------------------------

\section{RootBound}
\label{RootBound}
\begin{command} % -- COMMAND: RootBound ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RootBound(F: RINGELEM): RAT
RootBound(F: RINGELEM, N: INT): RAT
RootBound_Birkhoff(F: RINGELEM): RAT
RootBound_Cauchy(F: RINGELEM): RAT
RootBound_Lagrange(F: RINGELEM): RAT
RootBound_LMS(F: RINGELEM): RAT
\end{Verbatim}


\subsection*{Description}

The function ``\verb&RootBound&'' computes a bound on the absolute values
of the complex roots of a univariate polynomial with rational
coefficients.  In some cases you may get a better bound by applying
first the transformation produced by the function ``\verb&LinearSimplify&''.
The optional second argument specifies a trade-off between speed and
tightness of the bound (more precisely: it says how many iterations of
Graeffe transformation to apply); higher numbers give better bounds
but can take significantly more time.  With just one argument, the
number of iterations is determined heuristically.
\par 
The functions ``\verb&RootBound_Birkhoff&'', ``\verb&RootBound_Cauchy&'', ``\verb&RootBound_Lagrange&''
and ``\verb&RootBound_LMS&'' compute those bounds directly.  You should normally use
the function ``\verb&RootBound&'' which computes all the bounds, and takes the smallest;
it may also apply some Graeffe transformations.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x];
/**/  RootBound(x^2-2);
363/256
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  graeffe(\ref{graeffe} pg.\pageref{graeffe}), 
    RootBoundTransform(\ref{RootBoundTransform} pg.\pageref{RootBoundTransform}), 
    LinearSimplify(\ref{LinearSimplify} pg.\pageref{LinearSimplify}), 
    RealRootRefine(\ref{RealRootRefine} pg.\pageref{RealRootRefine}), 
    RealRoots(\ref{RealRoots} pg.\pageref{RealRoots})
\end{command} % -- end command --------------------------------

\section{RootBoundTransform}
\label{RootBoundTransform}
\begin{command} % -- COMMAND: RootBoundTransform ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RootBoundTransform(F: RINGELEM): RINGELEM
\end{Verbatim}


\subsection*{Description}

The function ``\verb&RootBoundTransform&'' computes a simple transform of a
univariate polynomial (of degree at least 1) with rational coefficents.
The transform is ``\verb&a[d]*x^d - a[d-1]*x^(d-1) - ... - a[0]&'' where
``\verb&a[k]&'' denotes the absolute value of the coefficient of ``\verb&x^k&'' in ``\verb&F&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x];
/**/  RootBoundTransform(-3*x^3+x^2-2);
3*x^3 -x^2 -2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  graeffe(\ref{graeffe} pg.\pageref{graeffe}), 
    RootBound(\ref{RootBound} pg.\pageref{RootBound})
\end{command} % -- end command --------------------------------

\section{round}
\label{round}
\begin{command} % -- COMMAND: round ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
round(X: RAT): INT
\end{Verbatim}


\subsection*{Description}

This function rounds a rational to the nearest integer; halves are
rounded towards zero.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  round(4.56);
5

/**/  round(-1/2);
0
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  num(\ref{num} pg.\pageref{num}), 
    den(\ref{den} pg.\pageref{den}), 
    floor(\ref{floor} pg.\pageref{floor}), 
    ceil(\ref{ceil} pg.\pageref{ceil}), 
    div(\ref{div} pg.\pageref{div})
\end{command} % -- end command --------------------------------

\section{RowMat}
\label{RowMat}
\begin{command} % -- COMMAND: RowMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
RowMat(L: LIST): MAT
RowMat(R: RING, L: LIST): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the matrix whose only row consists of the
elements of the list ``\verb&L&''.
\par 
The first form produces a matrix over ``\verb&QQ&'' if all entries in
``\verb&L&'' are of type INT or RAT.  If ``\verb&L&'' contains any entries
of type RINGELEM then the matrix is over the ring these elements
belong to.
\par 
The second form produces a matrix over ``\verb&R&'', and requires that
the elements of ``\verb&L&'' be INT, RAT or RINGELEM belonging to ``\verb&R&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  RowMat([3,4,5]);
matrix(QQ,
 [[3, 4, 5]])

/**/  RowMat(QQ,[5,6,7]);
matrix(QQ,
 [[5, 6, 7]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BlockMat(\ref{BlockMat} pg.\pageref{BlockMat}), 
    DiagMat(\ref{DiagMat} pg.\pageref{DiagMat}), 
    ColMat(\ref{ColMat} pg.\pageref{ColMat})
\end{command} % -- end command --------------------------------

\section{rref}
\label{rref}
\begin{command} % -- COMMAND: rref ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
rref(M: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the reduced row echelon form of ``\verb&M&'';
the columns are considered in left-to-right order.  An error is
signalled if the matrix is not over a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,2,3],[2,3,4]]);
/**/  rref(M);
matrix(QQ,
 [[1, 0, -1],
  [0, 1, 2]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  rk(\ref{rk} pg.\pageref{rk})
\end{command} % -- end command --------------------------------

\chapter{S}  %----=== CHAPTER LETTER ===----
\label{S}

\section{saturate}
\label{saturate}
\begin{command} % -- COMMAND: saturate ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
saturate(I: IDEAL, J: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

This function returns the saturation of ``\verb&I&'' with respect to ``\verb&J&'': the
ideal of polynomials $f$ such that $f*g$ is in ``\verb&I&'' for all $g$ in $J^k$
for some positive integer $k$.
\par 
The coefficient ring must be a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x-z, y-2*z);
/**/  J := ideal(x-2*z, y-z);
/**/  K := intersection(I, J); -- ideal of two points in the
                               -- projective plane
/**/  L := intersection(K, ideal(x,y,z)^3); -- add an irrelevant component
/**/  HilbertFn(R/L);
H(0) = 1
H(1) = 3
H(2) = 6
H(t) = 2   for t >= 3

/**/  saturate(L, ideal(x,y,z)) = K; -- saturating gets rid of the
                                     -- irrelevant component
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  colon(\ref{colon} pg.\pageref{colon}), 
    HColon(\ref{HColon} pg.\pageref{HColon}), 
    HSaturation(\ref{HSaturation} pg.\pageref{HSaturation})
\end{command} % -- end command --------------------------------

\section{ScalarProduct}
\label{ScalarProduct}
\begin{command} % -- COMMAND: ScalarProduct ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ScalarProduct(L: LIST, M: LIST): INT, RAT, or RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the sum of the product of the components of ``\verb&L&''
and ``\verb&M&''; precisely (len(L)=len(M)):
\par 
  ScalarProduct(L, M) = sum([ L[I]*M[I] | I in 1..len(L) ]).
\par 
The function works whenever the product of the components of ``\verb&L&'' and ``\verb&M&''
are defined (see ``Algebraic Operators'' (\ref{Algebraic Operators} pg.\pageref{Algebraic Operators})).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  ScalarProduct([1,2,3], [5,0,-1]);
2

/**/  use QQ[x,y,z];
/**/  ScalarProduct([x,y,z], [5,0,-1]);
5*x -z
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Algebraic Operators(\ref{Algebraic Operators} pg.\pageref{Algebraic Operators})
\end{command} % -- end command --------------------------------

\section{ScientificStr}
\label{ScientificStr}
\begin{command} % -- COMMAND: ScientificStr ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ScientificStr(X: INT|RAT|RINGELEM): STRING
ScientificStr(X: INT|RAT|RINGELEM, Prec: INT): STRING
\end{Verbatim}


\subsection*{Description}

This function converts a rational number ``\verb&X&'' into a (decimal)
floating-point string.  The optional second argument ``\verb&Prec&'' says how many
decimal digits to include in the mantissa; the default value is 5.
The exponent is always included (even if it is zero).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  ScientificStr(2/3);       -- last printed digit is rounded
6.6667*10^(-1)

/**/  ScientificStr(7^510);     -- almost no limit on exponent range
1.0000*10^431

/**/  ScientificStr(1/81, 35);  -- specify number of digits
1.2345679012345679012345679012345679*10^(-2)

/**/  ScientificStr(1/2);       -- trailing zeroes are not suppressed
5.0000*10^(-1)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  DecimalStr(\ref{DecimalStr} pg.\pageref{DecimalStr}), 
    FloatStr(\ref{FloatStr} pg.\pageref{FloatStr}), 
    FloatApprox(\ref{FloatApprox} pg.\pageref{FloatApprox}), 
    MantissaAndExponent10(\ref{MantissaAndExponent10} pg.\pageref{MantissaAndExponent10})
\end{command} % -- end command --------------------------------

\section{SectionalMatrix}
\label{SectionalMatrix}
\begin{command} % -- COMMAND: SectionalMatrix ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SectionalMatrix(I: IDEAL): type MAT
SectionalMatrix(PmodI: RING): type MAT
SectionalMatrix(I: IDEAL, bound: INT): type MAT
SectionalMatrix(PmodI: RING, bound: INT): type MAT
\end{Verbatim}


\subsection*{Description}

The definition of Hilbert function was extended in 
"Borel Sets and Sectional Matrices" to the bivariate function
encoding the Hilbert functions of the generic hyperplane sections:
the sectional matrix of ``\verb&I&'' (homogenous ideal)
or ``\verb&PmodI&''.
\par 
The second argument makes a matrix with ``\verb&bound&'' columns.
The default value is ``\verb&reg(I)&'' (since the rest of the matrix is
obtained by the Persistence Theorem).
\par 
See articles Bigatti, Robbiano, 
"Borel Sets and Sectional Matrices", and
Bigatti, Palezzato, Torielli,
"Sectional Matrices" (work in progress).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use P ::= QQ[x,y,z];
/**/ I := ideal(x^4 -x*y^3, x*y -z^2, x*z^2 -y^3);
/**/ SectionalMatrix(I);
matrix(ZZ,
 [[0, 0, 1, 1, 1, 1, 1, 1],
  [0, 0, 1, 3, 5, 6, 7, 8],
  [0, 0, 1, 4, 10, 18, 26, 34]])
/**/ SectionalMatrix(P/I);
matrix(ZZ,
 [[1, 1, 0, 0, 0, 0, 0, 0],
  [1, 2, 2, 1, 0, 0, 0, 0],
  [1, 3, 5, 6, 5, 3, 2, 2]])

/**/ SectionalMatrix(P/I, 10);
matrix(ZZ,
 [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0],
  [1, 3, 5, 6, 5, 3, 2, 2, 2, 2, 2]])
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{seed [OBSOLETE]}
\label{seed [OBSOLETE]}
\begin{command} % -- COMMAND: seed [OBSOLETE] ------------



\subsection*{Description}

Replaced by ``\verb&reseed&'' (\ref{reseed} pg.\pageref{reseed}).

\end{command} % -- end command --------------------------------

\section{SeparatorsOfPoints}
\label{SeparatorsOfPoints}
\begin{command} % -- COMMAND: SeparatorsOfPoints ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SeparatorsOfPoints(Points: LIST): LIST

where Points is a list of lists of coefficients representing a set of
\textbf{distinct} points in affine space.
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function computes separators for the points: that is, for each
point a polynomial is determined whose value is 1 at that point and 0
at all the others.  The separators yielded are reduced with respect to
the reduced Groebner basis which would be found by ``\verb&IdealOfPoints&'' (\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}).
\par 
NOTE:
\par 
 * the current ring must have at least as many indeterminates as the
   dimension of the space in which the points lie;
\par 
 * the base field for the space in which the points lie is taken to be
   the coefficient ring, which should be a field;
\par 
 * in the polynomials returned the first coordinate in the space is
   taken to correspond to the first indeterminate, the second to the
   second, and so on;
\par 
 * the separators are in the same order as the points (\textit{i.e.} the first
   separator is the one corresponding the first point, and so on);
\par 
 * if the number of points is large, say 100 or more, the returned
   value can be very large.  To avoid possible problems when printing
   such values as a single item we recommend printing out the elements
   one at a time as in this example:
\begin{verbatim}
     S := SeparatorsOfPoints(Pts);
     foreach sep in S do
       println sep;
     endforeach;
\end{verbatim}
For separators of points in projective space, see
``\verb&SeparatorsOfProjectivePoints&'' (\ref{SeparatorsOfProjectivePoints} pg.\pageref{SeparatorsOfProjectivePoints}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  use R ::= QQ[x,y];
  Points := [[1, 2], [3, 4], [5, 6]];
  S := SeparatorsOfPoints(Points);  -- compute the separators
  S;
[1/8y^2 - 5/4y + 3, -1/4y^2 + 2y - 3, 1/8y^2 - 3/4y + 1]
-------------------------------
  [[Eval(F, P) | P in Points] | F in S];  -- verify separators
[[1, 0, 0], [0, 1, 0], [0, 0, 1]]
-------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GenericPoints(\ref{GenericPoints} pg.\pageref{GenericPoints}), 
    IdealAndSeparatorsOfPoints(\ref{IdealAndSeparatorsOfPoints} pg.\pageref{IdealAndSeparatorsOfPoints}), 
    IdealAndSeparatorsOfProjectivePoints(\ref{IdealAndSeparatorsOfProjectivePoints} pg.\pageref{IdealAndSeparatorsOfProjectivePoints}), 
    IdealOfPoints(\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}), 
    IdealOfProjectivePoints(\ref{IdealOfProjectivePoints} pg.\pageref{IdealOfProjectivePoints}), 
    Interpolate(\ref{Interpolate} pg.\pageref{Interpolate}), 
    SeparatorsOfProjectivePoints(\ref{SeparatorsOfProjectivePoints} pg.\pageref{SeparatorsOfProjectivePoints})
\end{command} % -- end command --------------------------------

\section{SeparatorsOfProjectivePoints}
\label{SeparatorsOfProjectivePoints}
\begin{command} % -- COMMAND: SeparatorsOfProjectivePoints ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SeparatorsOfProjectivePoints(Points: LIST): LIST

where Points is a list of lists of coefficients representing a set of
\textbf{distinct} points in projective space.
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
This function computes separators for the points: that is, for each
point a homogeneous polynomial is determined whose value is non-zero at
that point and zero at all the others.  (Actually, choosing the values
listed in Points as representatives for the homogeneous coordinates of
the corresponding points in projective space, the non-zero value will
be 1.)  The separators yielded are reduced with respect to the reduced
Groebner basis which would be found by ``\verb&IdealOfProjectivePoints&'' (\ref{IdealOfProjectivePoints} pg.\pageref{IdealOfProjectivePoints}).
\par 
NOTE:
\par 
 * the current ring must have at least one more indeterminate than the
   dimension of the projective space in which the points lie, \textit{i.e.} at
   least as many indeterminates as the length of an element of
   the input, Points;
\par 
 * the base field for the space in which the points lie is taken to be
   the coefficient ring, which should be a field;
\par 
 * in the polynomials returned the first coordinate in the space is
   taken to correspond to the first indeterminate, the second to the
   second, and so on;
\par 
 * the separators are in the same order as the points (\textit{i.e.} the first
   separator is the one corresponding the first point, and so on);
\par 
 * if the number of points is large, say 100 or more, the returned
   value can be very large.  To avoid possible problems when printing
   such values as a single item we recommend printing out the elements
   one at a time as in this example:
\begin{verbatim}
     S := SeparatorsOfProjectivePoints(Pts);
     foreach sep in S do
       println sep;
     endforeach;
\end{verbatim}
For separators of points in affine space, see
``\verb&SeparatorsOfPoints&'' (\ref{SeparatorsOfPoints} pg.\pageref{SeparatorsOfPoints}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  use R ::= QQ[x,y,z];
  Points := [[0,0,1],[1/2,1,1],[0,1,0]];
  S := SeparatorsOfProjectivePoints(Points);
  S;
[-2x + z, 2x, -2x + y]
-------------------------------
  [[Eval(F, P) | P in Points] | F in S];   -- verify separators
[[1, 0, 0], [0, 1, 0], [0, 0, 1]]
-------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GenericPoints(\ref{GenericPoints} pg.\pageref{GenericPoints}), 
    IdealAndSeparatorsOfPoints(\ref{IdealAndSeparatorsOfPoints} pg.\pageref{IdealAndSeparatorsOfPoints}), 
    IdealAndSeparatorsOfProjectivePoints(\ref{IdealAndSeparatorsOfProjectivePoints} pg.\pageref{IdealAndSeparatorsOfProjectivePoints}), 
    IdealOfPoints(\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}), 
    IdealOfProjectivePoints(\ref{IdealOfProjectivePoints} pg.\pageref{IdealOfProjectivePoints}), 
    Interpolate(\ref{Interpolate} pg.\pageref{Interpolate}), 
    SeparatorsOfPoints(\ref{SeparatorsOfPoints} pg.\pageref{SeparatorsOfPoints})
\end{command} % -- end command --------------------------------

\section{SetCol}
\label{SetCol}
\begin{command} % -- COMMAND: SetCol ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SetCol(ref M: MAT, j: INT, L: LIST)
\end{Verbatim}


\subsection*{Description}

This procedure sets the elements in ``\verb&L&'' as entries of the
``\verb&j&''-th column in the matrix ``\verb&M&''; it returns nothing!
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := IdentityMat(QQ, 5);
/**/  SetCol(ref M, 1, [2,3,4,5,6]);
/**/  M;
matrix(QQ,
 [[2, 0, 0, 0, 0],
  [3, 1, 0, 0, 0],
  [4, 0, 1, 0, 0],
  [5, 0, 0, 1, 0],
  [6, 0, 0, 0, 1]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ref(\ref{ref} pg.\pageref{ref}), 
    GetCol(\ref{GetCol} pg.\pageref{GetCol}), 
    SetRow(\ref{SetRow} pg.\pageref{SetRow}), 
    SwapCols(\ref{SwapCols} pg.\pageref{SwapCols})
\end{command} % -- end command --------------------------------

\section{SetEntry}
\label{SetEntry}
\begin{command} % -- COMMAND: SetEntry ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SetEntry(ref M: MAT, i: INT, j: INT, val: RAT)
SetEntry(ref M: MAT, i: INT, j: INT, val: RINGELEM)
\end{Verbatim}


\subsection*{Description}

This procedure sets the value ``\verb&val&'' as i,j-entry in the matrix ``\verb&M&'';
it returns nothing!
It is equivalent to ``\verb&M[i,j] := val;&'', but is offered as the
CoCoA-5 couterpart of the syntax needed in C++ for CoCoALib.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := IdentityMat(QQ, 5);
/**/  SetEntry(ref M, 1, 4, 7/2);
/**/  M;
matrix(QQ,
 [[1, 0, 0, 7/2, 0],
  [0, 1, 0, 0, 0],
  [0, 0, 1, 0, 0],
  [0, 0, 0, 1, 0],
  [0, 0, 0, 0, 1]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ref(\ref{ref} pg.\pageref{ref}), 
    GetCol(\ref{GetCol} pg.\pageref{GetCol}), 
    SetRow(\ref{SetRow} pg.\pageref{SetRow}), 
    SwapCols(\ref{SwapCols} pg.\pageref{SwapCols})
\end{command} % -- end command --------------------------------

\section{SetRow}
\label{SetRow}
\begin{command} % -- COMMAND: SetRow ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SetRow(ref M: MAT, i: INT, L: LIST)
\end{Verbatim}


\subsection*{Description}

This procedure sets the elements in ``\verb&L&'' as entries of the
``\verb&i&''-th row in the matrix ``\verb&M&''; it returns nothing!
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := IdentityMat(QQ, 5);
/**/  SetRow(ref M, 1, [2,3,4,5,6]);
/**/  M;
matrix(QQ,
 [[2, 3, 4, 5, 6],
  [0, 1, 0, 0, 0],
  [0, 0, 1, 0, 0],
  [0, 0, 0, 1, 0],
  [0, 0, 0, 0, 1]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ref(\ref{ref} pg.\pageref{ref}), 
    GetRow(\ref{GetRow} pg.\pageref{GetRow}), 
    SetCol(\ref{SetCol} pg.\pageref{SetCol}), 
    SwapRows(\ref{SwapRows} pg.\pageref{SwapRows})
\end{command} % -- end command --------------------------------

\section{SetStackSize}
\label{SetStackSize}
\begin{command} % -- COMMAND: SetStackSize ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SetStackSize(NewSize: INT)
\end{Verbatim}


\subsection*{Description}

Secret and dangerous.

\end{command} % -- end command --------------------------------

\section{SetVerbosityLevel}
\label{SetVerbosityLevel}
\begin{command} % -- COMMAND: SetVerbosityLevel ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SetVerbosityLevel(N: INT)
\end{Verbatim}


\subsection*{Description}

This function sets the verbosity level: various functions defined in
CoCoALib and in the CoCoA packages print out some internal progress
messages when the global ``\verb&VerbosityLevel&'' (\ref{VerbosityLevel} pg.\pageref{VerbosityLevel}) is higher than some
value (see their specific manual entries for the relevant values, anyway
not less than 10).
\par 
This may also be applied in user defined functions: values 1-9 may
be used without triggering any verbosity from CoCoA.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  SetVerbosityLevel(100);
/**/  use QQ[x,y,z];  GB := GBasis(ideal(x^3 -x*y +1, x*y^2 -y -2));
myDoGBasis[1]: New poly in GB: len(GB) = 1 len(pairs) = 1
myDoGBasis[1]: New poly in GB: len(GB) = 2 len(pairs) = 1
myDoGBasis[1]: New poly in GB: len(GB) = 3 len(pairs) = 2
myDoGBasis[1]: New poly in GB: len(GB) = 4 len(pairs) = 2
myDoGBasis[1]: New poly in GB: len(GB) = 5 len(pairs) = 2

/**/  SetVerbosityLevel(0);  --> unset verbosity
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  VerbosityLevel(\ref{VerbosityLevel} pg.\pageref{VerbosityLevel})
\end{command} % -- end command --------------------------------

\section{shape}
\label{shape}
\begin{command} % -- COMMAND: shape ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
shape(E: LIST): LIST (of TYPE)
shape(E: RECORD): RECORD (of TYPE)
shape(E:OTHER): TYPE
\end{Verbatim}


\subsection*{Description}

``\verb&shape&'' behaves like ``\verb&type&'' (\ref{type} pg.\pageref{type}) except for LIST and RECORD,
where ``\verb&shape&'' recurses into the structure.
\begin{verbatim}
LIST:  gives [shape(obj) | obj in E]

RECORD: gives record[field1 := shape(E.field1), ... ]
        retaining the original field names
\end{verbatim}
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  L := [1,[1,"a"], x^2-x];
/**/  shape(L);
[INT, [INT, STRING], RINGELEM]

/**/  R := record[name := "test", contents := L];
/**/  shape(R);
record[contents := [INT, [INT, STRING], RINGELEM], name := STRING]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  type(\ref{type} pg.\pageref{type})
\end{command} % -- end command --------------------------------

\section{sign}
\label{sign}
\begin{command} % -- COMMAND: sign ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
sign(X: INT|RAT): INT
\end{Verbatim}


\subsection*{Description}

This function returns -1 if X < 0, 0 if X = 0, and 1 if X > 0.
X must be INT or RAT.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  sign(123);
1

/**/  sign(-5/2);
-1
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  abs(\ref{abs} pg.\pageref{abs})
\end{command} % -- end command --------------------------------

\section{SimplestBinaryRatBetween}
\label{SimplestBinaryRatBetween}
\begin{command} % -- COMMAND: SimplestBinaryRatBetween ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SimplestBinaryRatBetween(A: RAT, B: RAT): RAT
\end{Verbatim}


\subsection*{Description}

This function finds the simplest binary rational in the closed interval
with end points ``\verb&A&'' and ``\verb&B&''.  We define the simplest binary rational
to be the rational number of the form ``\verb&N*2^k&'' where the integer ``\verb&N&'' has
the smallest possible absolute value.  See also ``\verb&SimplestRatBetween&'' (\ref{SimplestRatBetween} pg.\pageref{SimplestRatBetween}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  SimplestBinaryRatBetween(0.123, 0.456);
1/4

/**/  SimplestBinaryRatBetween(-3.14159, -2.71828);
-3

/**/  SimplestBinaryRatBetween(5,10); // contrast with SimplestRatBetween!
8
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CFApprox(\ref{CFApprox} pg.\pageref{CFApprox}), 
    FloatApprox(\ref{FloatApprox} pg.\pageref{FloatApprox}), 
    SimplestRatBetween(\ref{SimplestRatBetween} pg.\pageref{SimplestRatBetween})
\end{command} % -- end command --------------------------------

\section{SimplestRatBetween}
\label{SimplestRatBetween}
\begin{command} % -- COMMAND: SimplestRatBetween ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SimplestRatBetween(A: RAT, B: RAT): RAT
\end{Verbatim}


\subsection*{Description}

This function finds the simplest rational in the closed interval with end
points ``\verb&A&'' and ``\verb&B&''.  See also SimplestBinaryRatBetween.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  SimplestRatBetween(0.123, 0.456);
1/3

/**/  SimplestRatBetween(-3.14159, -2.71828);
-3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CFApprox(\ref{CFApprox} pg.\pageref{CFApprox}), 
    FloatApprox(\ref{FloatApprox} pg.\pageref{FloatApprox}), 
    SimplestBinaryRatBetween(\ref{SimplestBinaryRatBetween} pg.\pageref{SimplestBinaryRatBetween})
\end{command} % -- end command --------------------------------

\section{SimplexInfo}
\label{SimplexInfo}
\begin{command} % -- COMMAND: SimplexInfo ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SimplexInfo(A: LIST): RECORD
\end{Verbatim}


\subsection*{Description}

This function compute the Stanley-Reisner ideal, the Alexander Dual
complex and ideal of a simplicial complex described by a list of top
faces.
\par 
Package ``\verb&GeomModelling&'', by Elisa Palezzato.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x[1..5]], DegLex;
/**/  L := [x[1]*x[2]*x[3], x[2]*x[3]*x[4], x[3]*x[4]*x[5]]; -- list top faces
/**/  indent(SimplexInfo(L));
record[
  AlexanderDualCOMPLEX := [x[2]*x[3]*x[5], x[2]*x[3]*x[4], x[1]*x[3]*x[4]],
  AlexanderDualIdeal := ideal(x[4]*x[5], x[1]*x[5], x[1]*x[2]),
  Delta := [x[1]*x[2]*x[3], x[2]*x[3]*x[4], x[3]*x[4]*x[5]],
  StanleyReisnerIdeal := ideal(x[1]*x[4], x[1]*x[5], x[2]*x[5])
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  FVector(\ref{FVector} pg.\pageref{FVector}), 
    SimplicialHomology(\ref{SimplicialHomology} pg.\pageref{SimplicialHomology})
\end{command} % -- end command --------------------------------

\section{SimplicialHomology}
\label{SimplicialHomology}
\begin{command} % -- COMMAND: SimplicialHomology ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SimplicialHomology(A: LIST): RECORD
SimplicialHomology(A: LIST, B: LIST): RECORD
\end{Verbatim}


\subsection*{Description}

This function computes the simplicial homology of a simplicial complex
described by a list of top faces.
With 2nd argument only with the second list of vertices.
\par 
Package GeomModelling, by Elisa Palezzato.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x[1..5]], DegLex;  --> DegLex ?

/**/  L := [x[1]*x[2]*x[3], x[2]*x[3]*x[4], x[3]*x[4]*x[5]]; -- list top faces
/**/  indent(SimplicialHomology(L));
record[
  H_0 := record[betti := 1, lambda := []],
  H_i := [record[betti := 0, lambda := []]],
  H_max := record[betti := 0, lambda := []]
]
-- 1 connected component (betti in H_0)

/**/  L := [x[1]*x[2]*x[3], x[2]*x[3]*x[4]]; -- list top faces
/**/  -- indent(SimplicialHomology(L)); --!!! ERROR !!! as expected: missing x[5]

/**/  L := [x[1]*x[2]*x[3], x[2]*x[3]*x[4], x[5]];
/**/  indent(SimplicialHomology(L));
record[
  H_0 := record[betti := 2, lambda := []],
  H_i := [record[betti := 0, lambda := []]],
  H_max := record[betti := 0, lambda := []]
]
-- 2 connected components

/**/  L := [x[1]*x[2]*x[3], x[2]*x[3]*x[4]];
/**/  indent( SimplicialHomology(L, [x[1], x[2], x[3], x[4]]) );
record[
  H_0 := record[betti := 1, lambda := []],
  H_i := [record[betti := 0, lambda := []]],
  H_max := record[betti := 0, lambda := []]
]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{size [OBSOLETE]}
\label{size [OBSOLETE]}
\begin{command} % -- COMMAND: size [OBSOLETE] ------------



\subsection*{Description}

[OBSOLETE] see ``\verb&len&'' (\ref{len} pg.\pageref{len}).

\SeeAlso %---- SEE ALSO ----
  len(\ref{len} pg.\pageref{len})
\end{command} % -- end command --------------------------------

\section{skip}
\label{skip}
\begin{command} % -- COMMAND: skip ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
skip
\end{Verbatim}


\subsection*{Description}

This command does nothing.  I suppose it might be used to make the
structure of a user-defined function more clear.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  skip;
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{SleepFor}
\label{SleepFor}
\begin{command} % -- COMMAND: SleepFor ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SleepFor(zzz: INT or RAT)
\end{Verbatim}


\subsection*{Description}

This command makes CoCoA sleep for (at least) ``\verb&zzz&'' seconds.
It is an error if the duration is negative or too long
(current limit is about 65000 seconds).
\par 
The command may be useful when developing an interactive program.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  SleepFor(1.23);
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PlayCantStop(\ref{PlayCantStop} pg.\pageref{PlayCantStop})
\end{command} % -- end command --------------------------------

\section{SmallestNonDivisor}
\label{SmallestNonDivisor}
\begin{command} % -- COMMAND: SmallestNonDivisor ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SmallestNonDivisor(N: INT): INT
\end{Verbatim}


\subsection*{Description}

This function finds the smallest prime which does not divide an integer.
It simply tries dividing by all primes in increasing order until it finds
one which does not divide ``\verb&N&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  SmallestNonDivisor(factorial(100));
101

/**/  SmallestNonDivisor(-100);
3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsPrime(\ref{IsPrime} pg.\pageref{IsPrime}), 
    IsProbPrime(\ref{IsProbPrime} pg.\pageref{IsProbPrime}), 
    FactorINT(\ref{FactorINT} pg.\pageref{FactorINT})
\end{command} % -- end command --------------------------------

\section{SmoothFactor [OBSOLESCENT]}
\label{SmoothFactor [OBSOLESCENT]}
\begin{command} % -- COMMAND: SmoothFactor [OBSOLESCENT] ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SmoothFactor(N: INT, MaxP: INT): RECORD
\end{Verbatim}


\subsection*{Description}

Renamed, see ``\verb&FactorINT&'' (\ref{FactorINT} pg.\pageref{FactorINT}) in particular ``\verb&TrialDiv&'' version.

\end{command} % -- end command --------------------------------

\section{SolomonTeraoIdeal}
\label{SolomonTeraoIdeal}
\begin{command} % -- COMMAND: SolomonTeraoIdeal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SolomonTeraoIdeal(A: LIST, f: RINGELEM): IDEAL 
\end{Verbatim}


\subsection*{Description}

This function returns the Solomon-Terao ideal of the list A of hyperplanes of an arrangement respect to a polynomial f.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[x,y];	
/**/ A := [x, y, x-y];
/**/ f := x^2+y^2;
/**/ SolomonTeraoIdeal(A, f);
ideal(2*x^2 +2*y^2,  2*x*y^2 -2*y^3)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  OrlikTeraoIdeal(\ref{OrlikTeraoIdeal} pg.\pageref{OrlikTeraoIdeal}), 
    ArtinianOrlikTeraoIdeal(\ref{ArtinianOrlikTeraoIdeal} pg.\pageref{ArtinianOrlikTeraoIdeal})
\end{command} % -- end command --------------------------------

\section{sort}
\label{sort}
\begin{command} % -- COMMAND: sort ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
sort(ref L: LIST)
\end{Verbatim}


\subsection*{Description}

This procedure sorts the elements of the list in ``\verb&L&'' with respect
to the default comparisons related to their types; it overwrites ``\verb&L&'' and
returns nothing.
\par 
For more on the default comparisons, see ``Relational Operators'' (\ref{Relational Operators} pg.\pageref{Relational Operators})
in the chapter on operators.
For sorting with respect to your own ordering, see ``\verb&SortBy&'' (\ref{SortBy} pg.\pageref{SortBy}), ``\verb&SortedBy&'' (\ref{SortedBy} pg.\pageref{SortedBy}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [3,2,1];
/**/  sort(ref L);  -- this returns nothing and modifies L
/**/  L;
[1, 2, 3]

/**/  use R ::= QQ[x,y,z];
/**/  L := [x,y,z];
/**/  sort(ref L);  -- this returns nothing and modifies L
/**/  L[1];
z

/**/  sorted([y, x, x^2]);   -- this returns the sorted list
[y, x, x^2]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Relational Operators(\ref{Relational Operators} pg.\pageref{Relational Operators}), 
    sorted(\ref{sorted} pg.\pageref{sorted}), 
    SortBy(\ref{SortBy} pg.\pageref{SortBy}), 
    SortedBy(\ref{SortedBy} pg.\pageref{SortedBy})
\end{command} % -- end command --------------------------------

\section{SortBy}
\label{SortBy}
\begin{command} % -- COMMAND: SortBy ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SortBy(ref L: LIST, LessThanFunc: FUNCTION)
\end{Verbatim}


\subsection*{Description}

This procedure sorts the elements of the list in ``\verb&L&'' into
increasing order with respect to the comparisons made by ``\verb&LessThanFunc&'';
it overwrites ``\verb&L&'' and returns nothing.
\par 
The comparison function ``\verb&LessThanFunc&'' takes two arguments
and must return ``\verb&true&'' if the first argument is less than the
second, otherwise it must return ``\verb&false&''.
\par 
If you want to call ``\verb&SortBy(ref L,LessThanFunc)&'' inside a function, and
you have defined ``\verb&LessThanFunc&'' at top level (rather than as an
anonymous function), then you need to ensure that the name ``\verb&LessThanFunc&''
is visible using ``\verb&TopLevel LessThanFunc;&''
\par 
NOTE: if both ``\verb&LessThanFunc(A, B)&'' and ``\verb&LessThanFunc(B, A)&'' return
``\verb&true&'', then ``\verb&A&'' and ``\verb&B&'' are viewed as being equivalent.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Define LessThanLen(S, T)    -- define the sorting function
/**/    Return len(S) < len(T);
/**/  EndDefine;

/**/  L := ["bird", "mouse", "cat", "elephant"];
/**/  SortBy(ref L, LessThanLen);
/**/  L;
["cat", "bird", "mouse", "elephant"]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  func(\ref{func} pg.\pageref{func}), 
    MinBy(\ref{MinBy} pg.\pageref{MinBy}), 
    MaxBy(\ref{MaxBy} pg.\pageref{MaxBy}), 
    sort(\ref{sort} pg.\pageref{sort}), 
    sorted(\ref{sorted} pg.\pageref{sorted}), 
    SortedBy(\ref{SortedBy} pg.\pageref{SortedBy}), 
    TopLevel(\ref{TopLevel} pg.\pageref{TopLevel})
\end{command} % -- end command --------------------------------

\section{sorted}
\label{sorted}
\begin{command} % -- COMMAND: sorted ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
sorted(L: LIST): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the list of the sorted elements of L without
affecting L, itself.
\par 
For more on the default comparisons, see ``Relational Operators'' (\ref{Relational Operators} pg.\pageref{Relational Operators})
in the chapter on operators.
For sorting with respect to your own ordering, see ``\verb&SortBy&'' (\ref{SortBy} pg.\pageref{SortBy}), ``\verb&SortedBy&'' (\ref{SortedBy} pg.\pageref{SortedBy}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [3,2,1];
/**/  sorted(L);
[1, 2, 3]

/**/  use R ::= QQ[x,y,z];
/**/  L := [x,y,z];
/**/  sorted(L);
[z, y, x]

/**/  sorted([y, x, z, x^2]);
[z, y, x, x^2]

/**/  sorted([3, 1, 1, 2]);
[1, 1, 2, 3]

/**/  sorted(["b","c","a"]);
["a", "b", "c"]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Relational Operators(\ref{Relational Operators} pg.\pageref{Relational Operators}), 
    SortBy(\ref{SortBy} pg.\pageref{SortBy}), 
    SortedBy(\ref{SortedBy} pg.\pageref{SortedBy}), 
    sort(\ref{sort} pg.\pageref{sort})
\end{command} % -- end command --------------------------------

\section{SortedBy}
\label{SortedBy}
\begin{command} % -- COMMAND: SortedBy ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SortedBy(L: LIST, LessThanFn: FUNCTION): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the list of the sorted elements of ``\verb&L&'' without
affecting ``\verb&L&'', itself.  As for ``\verb&SortBy&'' (\ref{SortBy} pg.\pageref{SortBy}), the comparison
function ``\verb&LessThanFn&'' takes two arguments and returns ``\verb&true&'' if the first argument
is less than the second, otherwise it returns ``\verb&false&''.  The sorted list
is in increasing order.
\par 
NOTE: if both ``\verb&LessThanFn(A, B)&'' and ``\verb&LessThanFn(B, A)&'' return
``\verb&true&'', then ``\verb&A&'' and ``\verb&B&'' are viewed as being equivalent.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Define LessByLength(S, T)    -- define the sorting function
/**/    Return len(S) < len(T);
/**/  EndDefine;

/**/  L := ["bird","mouse","cat", "elephant"];
/**/  sorted(L);  -- default is alphabetical order
["bird", "cat", "elephant", "mouse"]
/**/  SortedBy(L, LessByLength);
["cat", "bird", "mouse", "elephant"]

/**/  L;  -- L is not changed
["bird", "mouse", "cat", "elephant"]

/**/  SortBy(ref L, LessByLength);  -- sort L in place, changing L
/**/  L;
["cat", "bird", "mouse", "elephant"]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  func(\ref{func} pg.\pageref{func}), 
    MinBy(\ref{MinBy} pg.\pageref{MinBy}), 
    MaxBy(\ref{MaxBy} pg.\pageref{MaxBy}), 
    sort(\ref{sort} pg.\pageref{sort}), 
    sorted(\ref{sorted} pg.\pageref{sorted}), 
    SortBy(\ref{SortBy} pg.\pageref{SortBy})
\end{command} % -- end command --------------------------------

\section{source}
\label{source}
\begin{command} % -- COMMAND: source ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
source S: STRING
\end{Verbatim}


\subsection*{Description}

This command executes all CoCoA commands in the file or device named
S.  A typical use of ``\verb&source&'' is to collect user-defined functions and
variables in a text file, say, ``\verb&MyFile.coc&'' and then execute:
\begin{verbatim}
    source "MyFile.cocoa5";
\end{verbatim}
or, equivalently, the obsolescent
\begin{verbatim}
    << "MyFile.cocoa5";
\end{verbatim}
Functions and variables read in from a file in this way will erase
functions and variables with identical names that may already exist.
This can be avoided by using packages.  Repeatedly used functions can be
read into CoCoA at start-up by using ``\verb&source&'' in the
``\verb&userinit.coc&'' file.

\SeeAlso %---- SEE ALSO ----
  Introduction to IO(\ref{Introduction to IO} pg.\pageref{Introduction to IO}), 
    Introduction to Packages(\ref{Introduction to Packages} pg.\pageref{Introduction to Packages})
\end{command} % -- end command --------------------------------

\section{SourceRegion}
\label{SourceRegion}
\begin{command} % -- COMMAND: SourceRegion ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SourceRegion FromLine: INT,FromChar: INT To ToLine: INT,ToChar: INT In S: STRING
\end{Verbatim}


\subsection*{Description}

This command executes all CoCoA commands in the specified region of the
given file. It is not really intended for manual use, but is used by the
CoCoA UI.
\begin{verbatim}
  SourceRegion FromLine,FromChar To ToLine,ToChar In "MyFile.cocoa5";
\end{verbatim}
It is almost equivalent to copying the region into a temporary file, and
then reading that file with the ``\verb&source&'' command.
\par 
Line and char indexes start from 1; the region identified starts at the
``\verb&from&'' line/character position and stops immediately before the ``\verb&to&''
line/character position.

\SeeAlso %---- SEE ALSO ----
  source(\ref{source} pg.\pageref{source})
\end{command} % -- end command --------------------------------

\section{spaces}
\label{spaces}
\begin{command} % -- COMMAND: spaces ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
spaces(N: INT): STRING
\end{Verbatim}


\subsection*{Description}

This function returns a string consisting of N spaces.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := "a" + Spaces(5) + "b";
/**/  L;
a     b
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  dashes(\ref{dashes} pg.\pageref{dashes})
\end{command} % -- end command --------------------------------

\section{sprint}
\label{sprint}
\begin{command} % -- COMMAND: sprint ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
sprint(E: OBJECT): STRING
\end{Verbatim}


\subsection*{Description}

This function takes any CoCoA expression and converts its value to a
string.  One use is to check for extremely long output before printing
in a CoCoA window; see also ``\verb&fold&'' (\ref{fold} pg.\pageref{fold}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  I := ideal(x,y);
/**/  J := sprint(I);
/**/  I;
ideal(x, y)

/**/  J;        -- The output for I and J looks the same, but ...
ideal(x, y)
/**/  type(I);  -- I is an ideal, and
IDEAL
/**/  type(J);  -- J is just the string "ideal(x, y)".
STRING
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  fold(\ref{fold} pg.\pageref{fold}), 
    SprintTrunc(\ref{SprintTrunc} pg.\pageref{SprintTrunc}), 
    print(\ref{print} pg.\pageref{print}), 
    println(\ref{println} pg.\pageref{println}), 
    Introduction to IO(\ref{Introduction to IO} pg.\pageref{Introduction to IO})
\end{command} % -- end command --------------------------------

\section{SprintTrunc}
\label{SprintTrunc}
\begin{command} % -- COMMAND: SprintTrunc ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SprintTrunc(E: OBJECT, N: INT): STRING
\end{Verbatim}


\subsection*{Description}

This function works like ``\verb&sprint&'' (\ref{sprint} pg.\pageref{sprint}), turning the value of the
expression ``\verb&E&'' into a string, but if the string has length greater than
N-1, it is truncated and the string ``\verb&...&'' is concatenated.  This
function is useful in formatting reports of results.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  I := ideal(987*x+123*y)^4;
/**/  SprintTrunc(I, 20);
ideal(949005240561*x...
/**/  SprintTrunc(gens(I)[1], 20);
949005240561*x^4 +47...
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  format(\ref{format} pg.\pageref{format}), 
    sprint(\ref{sprint} pg.\pageref{sprint})
\end{command} % -- end command --------------------------------

\section{SqFreeFactor}
\label{SqFreeFactor}
\begin{command} % -- COMMAND: SqFreeFactor ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SqFreeFactor(F: RINGELEM): RECORD
\end{Verbatim}


\subsection*{Description}

Compute a factorization (of a polynomial) into coprime squarefree factors.
The factorization may sometimes be \textbf{finer than strictly necessary} (\textit{i.e.} two
factors could have the same multiplicity).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  f := (x^2-1)^2*(y*z+2*z)^3;
/**/  indent(SqFreeFactor(f));
record[
  RemainingFactor := 1,
  factors := [x^2 -1, y +2, z],
  multiplicities := [2, 3, 3]
]
/**/ use ZZ/(3)[x,y];
/**/ SqFreeFactor((x^3+y)*(x+y^3)).factors;
[x^3 +y,  y^3 +x]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  radical(\ref{radical} pg.\pageref{radical}), 
    factor(\ref{factor} pg.\pageref{factor}), 
    ContentFreeFactor(\ref{ContentFreeFactor} pg.\pageref{ContentFreeFactor})
\end{command} % -- end command --------------------------------

\section{StableBBasis5}
\label{StableBBasis5}
\begin{command} % -- COMMAND: StableBBasis5 ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
 StableBBasis5(Pts: LIST, Toler: LIST): RECORD
 StableBBasis5(Pts: LIST, Toler: LIST, Gamma: RAT): RECORD
 \end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
See ``\verb&ApproxPointsNBM&'' (\ref{ApproxPointsNBM} pg.\pageref{ApproxPointsNBM})
\par 
This function returns a record containing a \textbf{stable order ideal} of
the ideal of points, and a list of \textbf{almost vanishing} polynomials.
If the cardinality of the order ideal is equal to the number of points,
it is in fact a \textbf{quotient basis}, and in this case a
\textbf{stable border basis} founded on it is also returned.  The boolean field
``\verb&StableBBasisFound&'' is set to ``\verb&true&'' if a stable border basis was found,
otherwise ``\verb&false&''.
\par 
The first argument is a list of points in k-dimensional space, and the
second argument is list of k positive tolerances (one for each dimension).
The function builds the stable order ideal stepwise by testing, from a
numerical point of view, the linear dependence of a set of vectors.
So that the answer can be represented, the current ring must have at
least k indeterminates; the term ordering is ignored as it plays no role
in determining the border basis.
 \par 
 There is a third, optional argument: it is a real non negative number
 ``\verb&Gamma&'' which is used for scaling the threshold on the
 admissible perturbation of the points.
 A value of ``\verb&Gamma&'' << 1 should be used.
 If no value is specified then by default ``\verb&Gamma&'' = 0.1
 \par 
 For a full description of the algorithms we refer to the paper
 J.Abbott, C.Fassino, L.Torrente
 \textbf{Stable Border Bases for Ideals of Points} (to appear in JSC
 or arXiv:07062316).
 \par 
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED ***** See ApproxPointsNBM
  Pts := [[0.1,-1],[1,1],[2,3]];
  Toler := [0.1,0.1];
  StableBBasis5(Pts, Toler);
record[
  AlmostVanishing := [ (...) ],
  BBasis := [
    -3602879701896397/288230376151711744y^2 + x -
  32425917317067571/72057594037927936y -
  154923827181545063/288230376151711744,
    xy - 140512308373959475/288230376151711744y^2 -
  39631676720860365/72057594037927936y +
  10808639105689191/288230376151711744,
    y^3 - 3y^2 - y + 3,
    xy^2 - 580063632005319885/288230376151711744y^2 -
  32425917317067571/72057594037927936y +
  421536925121878425/288230376151711744],
  SOI := [1, y, y^2],
  StableBBasisFound := true]
-------------------------------
  Toler := [0.6, 0.6]:
  StableBBasis5(Pts, Toler);
record[AlmostVanishing := [.....], SOI := [1, y], StableBBasisFound := false]
-------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IdealOfPoints(\ref{IdealOfPoints} pg.\pageref{IdealOfPoints}), 
    ApproxPointsNBM(\ref{ApproxPointsNBM} pg.\pageref{ApproxPointsNBM})
\end{command} % -- end command --------------------------------

\section{StableIdeal}
\label{StableIdeal}
\begin{command} % -- COMMAND: StableIdeal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
StableIdeal(L: LIST of power-products): IDEAL
\end{Verbatim}


\subsection*{Description}

This function returns the smallest stable ideal containing the
power-products in ``\verb&L&'' (see also ``\verb&StronglyStableIdeal&'' (\ref{StronglyStableIdeal} pg.\pageref{StronglyStableIdeal})).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  L := [x*z^4, y^3];
/**/  StableIdeal(L);
ideal(x^2*z^3, x*y*z^3, x*z^4, x^3, x^2*y, x*y^2, y^3)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsStable(\ref{IsStable} pg.\pageref{IsStable}), 
    LexSegmentIdeal(\ref{LexSegmentIdeal} pg.\pageref{LexSegmentIdeal}), 
    StronglyStableIdeal(\ref{StronglyStableIdeal} pg.\pageref{StronglyStableIdeal})
\end{command} % -- end command --------------------------------

\section{StagedTrees}
\label{StagedTrees}
\begin{command} % -- COMMAND: StagedTrees ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
StagedTrees(L: LIST of power-products): IDEAL
\end{Verbatim}


\subsection*{Description}

This function returns all possible staged trees associated to an
interpolating polynomial.
\par 
See BigGoeRicSmi paper (TODO details)
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[a,b,x,y,z,w];
/**/  c_T := a*(x*(z+w)+y) + b*(x+y);
/**/  trees := StagedTrees(c_T);
/**/  PrintTrees(trees);
-- number of trees = 2 -----------------------
-------- tree 1 ----------------------------------
-- florets: [[x, y], [a, b], [z, w]]
< 
 x < 
      a < 
           z 
           w 
      b 
 y < 
      a 
      b 
-------- tree 2 ----------------------------------
-- florets: [[a, b], [x, y], [z, w]]
< 
 a < 
      x < 
           z 
           w 
      y 
 b < 
      x 
      y 
-------- end trees -------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsStable(\ref{IsStable} pg.\pageref{IsStable}), 
    LexSegmentIdeal(\ref{LexSegmentIdeal} pg.\pageref{LexSegmentIdeal}), 
    StronglyStableIdeal(\ref{StronglyStableIdeal} pg.\pageref{StronglyStableIdeal})
\end{command} % -- end command --------------------------------

\section{StandardInput}
\label{StandardInput}
\begin{command} % -- COMMAND: StandardInput ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
StandardInput(): ISTREAM
\end{Verbatim}


\subsection*{Description}

This function returns an ``\verb&ISTREAM&'' for reading interactive input: see ``\verb&GetLine&'' (\ref{GetLine} pg.\pageref{GetLine}).
\par 
\textbf{Warning:} this function may not work well if you are running CoCoA inside a GUI.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
//  UserInput := StandardInput();
//  str := GetLine(UserInput);
//  println "The input was: ", str;
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GetLine(\ref{GetLine} pg.\pageref{GetLine}), 
    OpenIFile(\ref{OpenIFile} pg.\pageref{OpenIFile}), 
    OpenIString(\ref{OpenIString} pg.\pageref{OpenIString})
\end{command} % -- end command --------------------------------

\section{StandardOutput}
\label{StandardOutput}
\begin{command} % -- COMMAND: StandardOutput ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
StandardOutput(): OSTREAM
\end{Verbatim}


\subsection*{Description}

This function returns an ``\verb&OSTREAM&'' for printing on the standard output
(usually this is the computer screen).
\par 
This function may not work well if you are running CoCoA inside a GUI.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  UserOutput := StandardOutput();
/**/  println "Hello" on UserOutput;  -- same as println "Hello";
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  print on(\ref{print on} pg.\pageref{print on}), 
    OpenOFile(\ref{OpenOFile} pg.\pageref{OpenOFile}), 
    OpenOString(\ref{OpenOString} pg.\pageref{OpenOString}), 
    StandardInput(\ref{StandardInput} pg.\pageref{StandardInput})
\end{command} % -- end command --------------------------------

\section{starting}
\label{starting}
\begin{command} % -- COMMAND: starting ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
starting(S: STRING): LIST of RECORD
\end{Verbatim}


\subsection*{Description}

This function returns a list of all CoCoA functions starting with the
string ``\verb&S&''.  This list may also include some undocumented
functions; be wary of using these (there is probably a reason they
are not documented!)
\par 
For each matching name there is a ``\verb&RECORD&'' comprising two fields:
``\verb&IsExported&'' and ``\verb&name&''.  The field ``\verb&IsExported&'' is ``\verb&false&'' for
user-defined and for built-in functions (implemented in C++), and ``\verb&true&''
for functions exported from a CoCoA-5 package.  The field ``\verb&name&'' contains
the full name of the function;  for exported functions, this is of the
form ``\verb&$PkgName.FnName&'', where the definition of ``\verb&FnName&'' can be found
in the CoCoA-5 package ``\verb&PkgName.cpkg&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  indent(starting("Subs"));
[
  record[IsExported := true, name := "$BackwardCompatible.Subsets"],
  record[IsExported := true, name := "$BackwardCompatible.Subst"]
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PackageOf(\ref{PackageOf} pg.\pageref{PackageOf}), 
    print(\ref{print} pg.\pageref{print}), 
    describe(\ref{describe} pg.\pageref{describe})
\end{command} % -- end command --------------------------------

\section{StdBasis}
\label{StdBasis}
\begin{command} % -- COMMAND: StdBasis ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
StdBasis(I: IDEAL): LIST
\end{Verbatim}


\subsection*{Description}

A \textbf{standard basis} of the ideal ``\verb&I&'' is a set of polynomials
whose initial forms generate the \textbf{tangent cone} of ``\verb&I&''
(see ``\verb&TgCone&'' (\ref{TgCone} pg.\pageref{TgCone}) for more details).
\par 
The implementation is based on Lazard's method 
(see Kreuzer-Robbiano, Computational Commutative Algebra 2, pg.463).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x^2*z-2*y, x^3+y^2-y*z);
StdBasis(I);
[(-1/2)*x^2*z +y, (1/2)*x^2*y*z +(-1/2)*x^2*z^2 +x^3]
/**/  TgCone(I);
ideal(y, x^3)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  TgCone(\ref{TgCone} pg.\pageref{TgCone}), 
    PrimaryHilbertSeries(\ref{PrimaryHilbertSeries} pg.\pageref{PrimaryHilbertSeries})
\end{command} % -- end command --------------------------------

\section{StdDegLexMat}
\label{StdDegLexMat}
\begin{command} % -- COMMAND: StdDegLexMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
StdDegLexMat(N: INT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the matrix defining a standard term-ordering.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  StdDegLexMat(3);
matrix(ZZ,
 [[1, 1, 1],
  [1, 0, 0],
  [0, 1, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  OrdMat(\ref{OrdMat} pg.\pageref{OrdMat}), 
    Term Orderings(\ref{Term Orderings} pg.\pageref{Term Orderings}), 
    StdDegRevLexMat(\ref{StdDegRevLexMat} pg.\pageref{StdDegRevLexMat}), 
    LexMat(\ref{LexMat} pg.\pageref{LexMat}), 
    RevLexMat(\ref{RevLexMat} pg.\pageref{RevLexMat}), 
    XelMat(\ref{XelMat} pg.\pageref{XelMat})
\end{command} % -- end command --------------------------------

\section{StdDegRevLexMat}
\label{StdDegRevLexMat}
\begin{command} % -- COMMAND: StdDegRevLexMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
StdDegRevLexMat(N: INT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the matrix defining a standard term-ordering.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  StdDegRevLexMat(3);
matrix(ZZ,
 [[1, 1, 1],
  [0, 0, -1],
  [0, -1, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  OrdMat(\ref{OrdMat} pg.\pageref{OrdMat}), 
    Term Orderings(\ref{Term Orderings} pg.\pageref{Term Orderings}), 
    StdDegLexMat(\ref{StdDegLexMat} pg.\pageref{StdDegLexMat}), 
    LexMat(\ref{LexMat} pg.\pageref{LexMat}), 
    RevLexMat(\ref{RevLexMat} pg.\pageref{RevLexMat}), 
    XelMat(\ref{XelMat} pg.\pageref{XelMat})
\end{command} % -- end command --------------------------------

\section{StronglyStableIdeal}
\label{StronglyStableIdeal}
\begin{command} % -- COMMAND: StronglyStableIdeal ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
StronglyStableIdeal(L: LIST of power-products): IDEAL
\end{Verbatim}


\subsection*{Description}

This function returns the smallest strongly stable ideal containing the
power-products in L.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  L := [x*y^2*z];
/**/  StableIdeal(L);
ideal(x^4, x^3*y, x^2*y^2, x*y^3, x*y^2*z)

/**/  StronglyStableIdeal(L);
ideal(x^4, x^3*y, x^2*y^2, x*y^3, x^3*z, x^2*y*z, x*y^2*z)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsStronglyStable(\ref{IsStronglyStable} pg.\pageref{IsStronglyStable}), 
    LexSegmentIdeal(\ref{LexSegmentIdeal} pg.\pageref{LexSegmentIdeal}), 
    StableIdeal(\ref{StableIdeal} pg.\pageref{StableIdeal})
\end{command} % -- end command --------------------------------

\section{SturmSeq}
\label{SturmSeq}
\begin{command} % -- COMMAND: SturmSeq ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SturmSeq(f: RINGELEM): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns a scaled Sturm sequence of the univariate polynomial
``\verb&f&'' which must have rational coefficients.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x];
/**/  f := 3*x^3-5*x^2+7*x-11;
/**/  SturmSeq(f);
[3*x^3 -5*x^2 +7*x -11,  9*x^2 -10*x +7,  -38*x +131,  -1]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  RealRoots(\ref{RealRoots} pg.\pageref{RealRoots}), 
    NumRealRoots(\ref{NumRealRoots} pg.\pageref{NumRealRoots})
\end{command} % -- end command --------------------------------

\section{SubalgebraHom}
\label{SubalgebraHom}
\begin{command} % -- COMMAND: SubalgebraHom ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SubalgebraHom(R: RING, L: LIST): RINGHOM
\end{Verbatim}


\subsection*{Description}

This function returns the homomorphism from ``\verb&R&'' into
(a representation of) the subalgebra generated by ``\verb&L&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use QQ[s,t];
/**/ L := [s^3, s^2*t, s*t^2, t^3];

/**/ ReprRing ::= QQ[x,y,z,w];
/**/ phi := SubalgebraHom(ReprRing, L);
/**/ phi;
RingHom(RingWithID(256, "QQ[x,y,z,w]") --> RingWithID(257, "QQ[s,t]")
  sending (x |--> s^3) & (y |--> s^2*t) & (z |--> s*t^2) & (w |--> t^3))

/**/ ker(phi);  --> implicitization
ideal(z^2 -y*w,  y*z -x*w,  y^2 -x*z)

/**/ SubalgRepr := preimage0(phi, s^6*t^6);  SubalgRepr;
x^2*w^2
/**/ phi(SubalgRepr);
s^6*t^6
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  preimage0(\ref{preimage0} pg.\pageref{preimage0}), 
    ker(\ref{ker} pg.\pageref{ker})
\end{command} % -- end command --------------------------------

\section{SubalgebraMap [OBSOLETE]}
\label{SubalgebraMap [OBSOLETE]}
\begin{command} % -- COMMAND: SubalgebraMap [OBSOLETE] ------------



\subsection*{Description}

[OBSOLETE] See  ``\verb&SubalgebraHom&'' (\ref{SubalgebraHom} pg.\pageref{SubalgebraHom}).















\SeeAlso %---- SEE ALSO ----
  SubalgebraHom(\ref{SubalgebraHom} pg.\pageref{SubalgebraHom})
\end{command} % -- end command --------------------------------

\section{SubalgebraRepr [OBSOLESCENT]}
\label{SubalgebraRepr [OBSOLESCENT]}
\begin{command} % -- COMMAND: SubalgebraRepr [OBSOLESCENT] ------------



\subsection*{Description}

[OBSOLESCENT]

\SeeAlso %---- SEE ALSO ----
  SubalgebraHom(\ref{SubalgebraHom} pg.\pageref{SubalgebraHom}), 
    preimage0(\ref{preimage0} pg.\pageref{preimage0}), 
    ker(\ref{ker} pg.\pageref{ker})
\end{command} % -- end command --------------------------------

\section{submat}
\label{submat}
\begin{command} % -- COMMAND: submat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
submat(M: MAT, R: LIST of INT, C: LIST of INT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the submatrix of ``\verb&M&'' formed by the rows listed
in ``\verb&R&'' and the columns listed in ``\verb&C&''.   If ``\verb&M&'' is a list, it is interpreted
as a matrix in the natural way.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15]]);
/**/  submat(M,[1,3],3..5);
matrix(QQ,
 [[3, 4, 5],
  [13, 14, 15]])

/**/  M := mat([[1,2,3],[4,5,6]]);
/**/  submat(M,[2],[1,3]);
matrix(QQ,
 [[4, 6]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  minors(\ref{minors} pg.\pageref{minors})
\end{command} % -- end command --------------------------------

\section{submodule}
\label{submodule}
\begin{command} % -- COMMAND: submodule ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
submodule(L: LIST of MODULEELEM): MODULE
submodule(F: MODULE, L: LIST of MODULEELEM): MODULE
\end{Verbatim}


\subsection*{Description}

The first form returns the ideal generated by ``\verb&L&''.
The second is the same as the first but works also if ``\verb&L = []&''.
\par 
This function is not friendly if you write the input by hand:
we suggest ``\verb&SubmoduleCols, SubmoduleRows&'' (\ref{SubmoduleCols, SubmoduleRows} pg.\pageref{SubmoduleCols, SubmoduleRows}) for creating
a module from the rows or columns of a matrix.
\par 
NOTE: the generators are a LIST of MODULEELEM, not a LIST of LISTS
of RINGELEM.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  R3 := NewFreeModule(R, 3);
/**/  L := [ModuleElem(R3, [x,y,z]), ModuleElem(R3, [x-1,0,z])];
/**/  M := submodule(R3, L); -- equivalent to
/**/  M := submodule(L);     -- (L not empty)
/**/  gens(M);
[[x, y, z], [x -1, 0, z]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ModuleOf(\ref{ModuleOf} pg.\pageref{ModuleOf}), 
    SubmoduleCols, SubmoduleRows(\ref{SubmoduleCols, SubmoduleRows} pg.\pageref{SubmoduleCols, SubmoduleRows}), 
    GensAsCols, GensAsRows(\ref{GensAsCols, GensAsRows} pg.\pageref{GensAsCols, GensAsRows}), 
    gens(\ref{gens} pg.\pageref{gens})
\end{command} % -- end command --------------------------------

\section{SubmoduleCols, SubmoduleRows}
\label{SubmoduleCols, SubmoduleRows}
\begin{command} % -- COMMAND: SubmoduleCols, SubmoduleRows ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SubmoduleCols(F: MODULE, M: MATRIX): MODULE
SubmoduleRows(F: MODULE, M: MATRIX): MODULE
\end{Verbatim}


\subsection*{Description}

The first (second) function returns the submodule of F generated by
the module elements described by the columns (rows) in the matrix M
(which might be empty).
\par 
Dimensions must be compatible.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  R3 := NewFreeModule(R, 3);
/**/  MGens := matrix(R,[[x,y,z],[x-1,0,z]]);

/**/  M := SubmoduleRows(R3, MGens);
/**/  gens(M);
[[x, y, z], [x -1, 0, z]]

-- /**/ M := SubmoduleCols(R3, MGens); --!!! ERROR !!! as expected: wrong length

/**/  M := SubmoduleCols(NewFreeModule(R,2), MGens);
/**/  gens(M);
[[x, x -1], [y, 0], [z, z]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GensAsCols, GensAsRows(\ref{GensAsCols, GensAsRows} pg.\pageref{GensAsCols, GensAsRows}), 
    submodule(\ref{submodule} pg.\pageref{submodule}), 
    ModuleElem(\ref{ModuleElem} pg.\pageref{ModuleElem})
\end{command} % -- end command --------------------------------

\section{SubmoduleOfMinGens}
\label{SubmoduleOfMinGens}
\begin{command} % -- COMMAND: SubmoduleOfMinGens ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SubmoduleOfMinGens(M: MODULE): MODULE
\end{Verbatim}


\subsection*{Description}

It works only in the homogeneous case:
for the inhomogeneous case see ``\verb&MinSubsetOfGens&'' (\ref{MinSubsetOfGens} pg.\pageref{MinSubsetOfGens}).
\par 
This function returns the ideal generated by a minimal set of generators
(\textit{i.e.} with minimal cardinality) of ``\verb&M&''.  
The minimal set of generators is not necessarily a subset of the given
generators.
\par 
Similar to ``\verb&IdealOfMinGens&'' (\ref{IdealOfMinGens} pg.\pageref{IdealOfMinGens}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  R3 := NewFreeModule(R, 3);
/**/  MGens := matrix(R, [[x,y,z], [x^2,0,z^2], [2*x^2,x*y,z^2+x*z]]);
/**/  M := SubmoduleRows(R3, MGens);
/**/  MGM := SubmoduleOfMinGens(M);  indent(MGM);
SubmoduleRows(F, matrix([
  [x, y, z],
  [0, x*y, x*z -z^2]
]))
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  MinGens(\ref{MinGens} pg.\pageref{MinGens}), 
    MinSubsetOfGens(\ref{MinSubsetOfGens} pg.\pageref{MinSubsetOfGens})
\end{command} % -- end command --------------------------------

\section{subsets}
\label{subsets}
\begin{command} % -- COMMAND: subsets ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
subsets(S: LIST): LIST
subsets(S: LIST, N: INT): LIST
\end{Verbatim}


\subsection*{Description}

This function computes all sublists (subsets) of a list (set).
If N is specified, it computes all sublists of cardinality N.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  subsets([1, 4, 7]);
[[ ], [7], [4], [4, 7], [1], [1, 7], [1, 4], [1, 4, 7]]

/**/  subsets([1, 4, 7], 2);
[[1, 4], [1, 7], [4, 7]]

/**/  subsets([2,3,3]);                 -- list with repeated entries
[[ ], [3], [3], [3, 3], [2], [2, 3], [2, 3], [2, 3, 3]]

/**/  subsets(MakeSet([2,3,3]));
[[ ], [3], [2], [2, 3]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  IsSubset(\ref{IsSubset} pg.\pageref{IsSubset}), 
    partitions(\ref{partitions} pg.\pageref{partitions}), 
    permutations(\ref{permutations} pg.\pageref{permutations}), 
    MakeSet(\ref{MakeSet} pg.\pageref{MakeSet}), 
    tuples(\ref{tuples} pg.\pageref{tuples})
\end{command} % -- end command --------------------------------

\section{subst}
\label{subst}
\begin{command} % -- COMMAND: subst ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
subst(E: OBJECT, X, F): OBJECT
subst(E: OBJECT,[[X_1, F_1],...,[X_r, F_r]]): OBJECT
  where each X or X_i is an indeterminate
  and each F or F_i is a RINGELEM
\end{Verbatim}


\subsection*{Description}

The first form of this function substitutes ``\verb&F_i&'' for ``\verb&X_i&'' in the
expression E.  The second form is a shorthand for the first in the
case of a single indeterminate.  When substituting for the
indeterminates in order, it is easier to use ``\verb&eval&'' (\ref{eval} pg.\pageref{eval}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z,t];
/**/  F := x +y +z +t^2;
/**/  subst(F, x, -2);
t^2 +y +z -2

/**/  subst(F, [[x,x^2], [y,y^3], [z,t^5]]);
t^5 +y^3 +x^2 +t^2

/**/  eval(F, [x^2,y^3,t^5]); -- the same thing as above
t^5 +y^3 +x^2 +t^2

/**/  MySubst := [[y,1], [t, 3*z-x]];
/**/  subst(x*y*z*t, MySubst);  -- substitute into the function x*y*z*t
-x^2*z +3*x*z^2
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  eval(\ref{eval} pg.\pageref{eval}), 
    Evaluation of Polynomials(\ref{Evaluation of Polynomials} pg.\pageref{Evaluation of Polynomials}), 
    PolyAlgebraHom(\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}), 
    QZP(\ref{QZP} pg.\pageref{QZP}), 
    RingElem(\ref{RingElem} pg.\pageref{RingElem}), 
    ZPQ(\ref{ZPQ} pg.\pageref{ZPQ})
\end{command} % -- end command --------------------------------

\section{substring}
\label{substring}
\begin{command} % -- COMMAND: substring ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
substring(S: STRING, StartPosn: INT, Length: INT): STRING
\end{Verbatim}


\subsection*{Description}

This function extracts a substring (with given start posn and length)
from a string.  It is an error if the start posn is not inside the string,
and also if the length is negative.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  substring("abcdef", 2, 3);
bcd
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  concat(\ref{concat} pg.\pageref{concat})
\end{command} % -- end command --------------------------------

\section{sum}
\label{sum}
\begin{command} % -- COMMAND: sum ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
sum(L: LIST): OBJECT
sum(L: LIST, InitVal: OBJECT): OBJECT
\end{Verbatim}


\subsection*{Description}

This function returns the sum of the objects in the list ``\verb&L&'' (together
with ``\verb&InitVal&'', if specified).  If the list ``\verb&L&'' may be empty,
you must specify ``\verb&InitVal&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  sum([3, x, y^2]);
y^2 +x +3

/**/  sum(1..40) = binomial(41,2);
true

/**/  sum(["c","oc","oa"]);
cocoa

/**/ sum([], "");      -- gives empty STRING

/**/ sum([], zero(R)); -- gives type RINGELEM
0
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Algebraic Operators(\ref{Algebraic Operators} pg.\pageref{Algebraic Operators}), 
    product(\ref{product} pg.\pageref{product})
\end{command} % -- end command --------------------------------

\section{support}
\label{support}
\begin{command} % -- COMMAND: support ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
support(F: RINGELEM): LIST
support(F: MODULEELEM): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the list of terms of F.  To get a list of
monomials, which includes coefficients, use ``\verb&monomials&'' (\ref{monomials} pg.\pageref{monomials}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  F := 3*x^2-4*x*y+y^3+3;
/**/  support(F);
[y^3, x^2, x*y, 1]

/**/  monomials(F);
[y^3, 3*x^2, -4*x*y, 3]

// NOT YET IMPLEMENTED for MODULEELEM
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  coefficients(\ref{coefficients} pg.\pageref{coefficients}), 
    monomials(\ref{monomials} pg.\pageref{monomials})
\end{command} % -- end command --------------------------------

\section{swap}
\label{swap}
\begin{command} % -- COMMAND: swap ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
swap(ref A: OBJECT, ref B: OBJECT)
\end{Verbatim}


\subsection*{Description}

This procedure swaps two values; it returns nothing!
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  A := 1;
/**/  B := 2;
/**/  swap(ref A, ref B);
/**/  PrintLn [A,B];
[2, 1]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ref(\ref{ref} pg.\pageref{ref})
\end{command} % -- end command --------------------------------

\section{SwapCols}
\label{SwapCols}
\begin{command} % -- COMMAND: SwapCols ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SwapCols(ref M: MAT, i: INT, j: INT)
\end{Verbatim}


\subsection*{Description}

This procedure swaps the ``\verb&i&''-th and ``\verb&j&''-th columns in the
matrix ``\verb&M&''; it returns nothing!
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := StdDegLexMat(5);
/**/  SwapCols(ref M, 1,5);
/**/  M;
matrix(QQ,
 [[1, 1, 1, 1, 1],
  [0, 0, 0, 0, 1],
  [0, 1, 0, 0, 0],
  [0, 0, 1, 0, 0],
  [0, 0, 0, 1, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ref(\ref{ref} pg.\pageref{ref}), 
    swap(\ref{swap} pg.\pageref{swap}), 
    GetCol(\ref{GetCol} pg.\pageref{GetCol}), 
    SetCol(\ref{SetCol} pg.\pageref{SetCol})
\end{command} % -- end command --------------------------------

\section{SwapRows}
\label{SwapRows}
\begin{command} % -- COMMAND: SwapRows ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SwapRows(ref M: MAT, i: INT, j: INT)
\end{Verbatim}


\subsection*{Description}

This procedure swaps the ``\verb&i&''-th and ``\verb&j&''-th rows in the
matrix ``\verb&M&''; it returns nothing!
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := IdentityMat(QQ, 5);
/**/  SwapRows(ref M, 2,5);
/**/  M;
matrix(QQ,
 [[1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1],
  [0, 0, 1, 0, 0],
  [0, 0, 0, 1, 0],
  [0, 1, 0, 0, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  ref(\ref{ref} pg.\pageref{ref}), 
    swap(\ref{swap} pg.\pageref{swap}), 
    GetRow(\ref{GetRow} pg.\pageref{GetRow}), 
    SetRow(\ref{SetRow} pg.\pageref{SetRow})
\end{command} % -- end command --------------------------------

\section{SwinnertonDyerPoly}
\label{SwinnertonDyerPoly}
\begin{command} % -- COMMAND: SwinnertonDyerPoly ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SwinnertonDyerPoly(x: RINGELEM, RootList: LIST of INT): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function computes the Swinnerton-Dyer polynomial whose roots are
the sum of all square-roots of the elements in ``\verb&RootList&''.  The result
is irreducible if ``\verb&RootList&'' contains distinct prime numbers.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x];
/**/  SwinnertonDyerPoly(x,[2,3]); --> roots are +/- sqrt(2) +/- sqrt(3)
x^4 -10*x^2 +1
/**/  SwinnertonDyerPoly(x, [2,2,2]);  -- you may also repeat the roots
x^8 -24*x^6 +120*x^4 -224*x^2 +144
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  factor(\ref{factor} pg.\pageref{factor}), 
    RealRoots(\ref{RealRoots} pg.\pageref{RealRoots}), 
    resultant(\ref{resultant} pg.\pageref{resultant})
\end{command} % -- end command --------------------------------

\section{SylvesterMat}
\label{SylvesterMat}
\begin{command} % -- COMMAND: SylvesterMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SylvesterMat(F: RINGELEM, G: RINGELEM, X: RINGELEM): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the Sylvester matrix of the polynomials F and G
with respect to the indeterminate X.  This is the matrix used to
calculate the resultant.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[p,q,x];
/**/  F := x^3+p*x-q;  G := deriv(F, x);
/**/  SylvesterMat(F, G, x);
matrix( /*RingWithID(36, "QQ[p,q,x]")*/
 [[1, 0, p, -q, 0],
  [0, 1, 0, p, -q],
  [3, 0, p, 0, 0],
  [0, 3, 0, p, 0],
  [0, 0, 3, 0, p]])

/**/  det(SylvesterMat(F, G, x)) = resultant(F, G, x);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  resultant(\ref{resultant} pg.\pageref{resultant})
\end{command} % -- end command --------------------------------

\section{SymbolRange}
\label{SymbolRange}
\begin{command} % -- COMMAND: SymbolRange ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SymbolRange(H: STRING, lo: INT, hi: INT): LIST of RECORD
SymbolRange(H: STRING, lo: LIST of INT, hi: LIST of INT): LIST of RECORD
\end{Verbatim}


\subsection*{Description}

This function is designed to work well with ``\verb&NewPolyRing&'' (\ref{NewPolyRing} pg.\pageref{NewPolyRing}).
It returns the list of the symbols with head given by the string ``\verb&H&''
and the range of indices.
A symbol is represented as a record with ``\verb&head&'' (as produced by ``\verb&IndetName&'' (\ref{IndetName} pg.\pageref{IndetName}))
and ``\verb&indices&'' (as produced by ``\verb&IndetSubscripts&'' (\ref{IndetSubscripts} pg.\pageref{IndetSubscripts})).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  P := NewPolyRing(QQ, SymbolRange("x", 0,4));
/**/  indets(P);
[x[0], x[1], x[2], x[3], x[4]]

/**/  P2 := NewPolyRing(QQ, SymbolRange("mu", [3,1], [5,2]));
/**/  indets(P2);
[mu[3,1],  mu[3,2],  mu[4,1],  mu[4,2],  mu[5,1],  mu[5,2]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing}), 
    indet(\ref{indet} pg.\pageref{indet}), 
    IndetSubscripts(\ref{IndetSubscripts} pg.\pageref{IndetSubscripts}), 
    IndetIndex(\ref{IndetIndex} pg.\pageref{IndetIndex}), 
    IndetName(\ref{IndetName} pg.\pageref{IndetName}), 
    NumIndets(\ref{NumIndets} pg.\pageref{NumIndets})
\end{command} % -- end command --------------------------------

\section{SymmetricPolys}
\label{SymmetricPolys}
\begin{command} % -- COMMAND: SymmetricPolys ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SymmetricPolys(P: RING): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the list of the homogeneous symmetric
polynomials with square-free support.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use P ::= QQ[x,y,z];
/**/ SymmetricPolys(P);
[x +y +z, x*y +x*z +y*z, x*y*z]
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{SystemCommand}
\label{SystemCommand}
\begin{command} % -- COMMAND: SystemCommand ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SystemCommand(CMD: STRING): INT
\end{Verbatim}


\subsection*{Description}

This function will work only if the CoCoA interpreter was started with
the "enable system command" flag set; by default the flag is not set
since system commands can be used maliciously (\textit{e.g.} to delete files).
\par 
This function expects a string containing a "system command" (\textit{e.g.} a
shell command on Linux platforms).  The string ``\verb&CMD&'' is passed to the
underlying operating system command line interpreter for execution.
The return value of ``\verb&SystemCommand&'' depends on the platform (\textit{i.e.} the
C++ run-time environment), so should not be relied upon to provide
any specific information: \textit{e.g.} on some Linux systems the value returned
is the exit code, on others it is 256 times the process exit code.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ ExitCode := SystemCommand("echo abc");  --> value of ExitCode is unclear
abc
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{syz}
\label{syz}
\begin{command} % -- COMMAND: syz ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
syz(L: LIST of RINGELEM): MODULE
syz(M: IDEAL|MODULE, Index: INT): MODULE
\end{Verbatim}


\subsection*{Description}

In the first two forms this function computes the syzygy module of a list
of polynomials or module elements.
``\verb&SyzOfGens(I)&'' is the same as ``\verb&syz(gens(I))&''.
\par 
In the last form this function returns the specified syzygy module of
the minimal free resolution of ``\verb&M&'' which must be homogeneous.  As a side
effect, it computes the Groebner basis of ``\verb&M&''.   (***** NOT YET IMPLEMENTED *****)
\par 
The coefficient ring must be a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  indent(syz([x^2-y-1, y^3-z, x^2-y, y^3-z]));
SubmoduleRows(F, matrix(
  [y^3 -z, 0, 0, -x^2 +y +1],
  [0, 1, 0, -1],
  [x^2 -y, 0, -x^2 +y +1, 0],
  [0, 0, y^3 -z, -x^2 +y]
))
-------------------------------
/**/  I := ideal(x, x, y);
/**/  syz(gens(I));
submodule(FreeModule(..), [[1, -1, 0], [0, y, -x]])
/**/  SyzOfGens(I);
submodule(FreeModule(..), [[1, -1, 0], [0, y, -x]])

  syz(I, 1);      -- NOT YET IMPLEMENTED
Module([[x, -y]])
-------------------------------
  I := ideal(x^2-yz, xy-z^2, xyz);    -- NOT YET IMPLEMENTED
  syz(I,0);
Module([x^2 - yz], [xy - z^2], [xyz])
-------------------------------
  syz(I,1);    -- NOT YET IMPLEMENTED
  Module([-x^2 + yz, xy - z^2, 0], [xz^2, -yz^2, -y^2 + xz], [z^3, 0,
-xy + z^2], [0, z^3, -x^2 + yz])
-------------------------------
  syz(I,2);
Module([0, z, -x, y], [-z^2, -x, y, -z])
-------------------------------
  syz(I,3);
Module([[0]])
-------------------------------
  Res(I);
0 --> R(-6)^2 --> R(-4)(+)R(-5)^3 --> R(-2)^2(+)R(-3)
-------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  res(\ref{res} pg.\pageref{res}), 
    SyzOfGens(\ref{SyzOfGens} pg.\pageref{SyzOfGens})
\end{command} % -- end command --------------------------------

\section{SyzOfGens}
\label{SyzOfGens}
\begin{command} % -- COMMAND: SyzOfGens ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
SyzOfGens(M: IDEAL|MODULE): MODULE
\end{Verbatim}


\subsection*{Description}

If M is an ideal or submodule, this function calculates the syzygy
module for the given set of generators of M.
\par 
If M is a quotient of a ring by an ideal I or a quotient of a free
module by a submodule N, then this function calculates the syzygy
module for the given set of generators of I or N, respectively.
\par 
``\verb&SyzOfGens(I)&'' is the same as ``\verb&syz(gens(I))&''.
\par 
The coefficient ring must be a field.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  I := ideal(x, y, x+y);
/**/  indent(SyzOfGens(I));
SubmoduleRows(F, matrix([
  [1, 1, -1],
  [0, x +y, -y]
]))

/**/  R3 := NewFreeModule(R, 3);
/**/  MGens := matrix(R,[[x,y,z], [x-y,0,z], [y^2,y^2,0]]);
/**/  indent(SyzOfGens(SubmoduleRows(R3, MGens)));
SubmoduleRows(F, matrix([
  [y, -y, -1]
]))
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  syz(\ref{syz} pg.\pageref{syz})
\end{command} % -- end command --------------------------------

\chapter{T}  %----=== CHAPTER LETTER ===----
\label{T}

\section{tag}
\label{tag}
\begin{command} % -- COMMAND: tag ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
tag(E: OBJECT): STRING
\end{Verbatim}


\subsection*{Description}

If E is a tagged object, this function returns the tag of E;
otherwise, it returns the empty string.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := tagged(3,"MyTag");
/**/  type(L);
TAGGED("$TopLevel.MyTag")

/**/  tag(L);
MyTag
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Printing a Tagged Object(\ref{Printing a Tagged Object} pg.\pageref{Printing a Tagged Object}), 
    tagged(\ref{tagged} pg.\pageref{tagged}), 
    untagged(\ref{untagged} pg.\pageref{untagged})
\end{command} % -- end command --------------------------------

\section{tagged}
\label{tagged}
\begin{command} % -- COMMAND: tagged ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
tagged(E: OBJECT, S: STRING): TAGGED(S)
\end{Verbatim}


\subsection*{Description}

This function returns the object E, tagged with the string S.
Tagging is used for pretty printing of objects.  See the reference
listed below.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [1,2,3];
/**/  M := tagged(L,"MyTag");
/**/  type(L);
LIST

/**/  type(M);
TAGGED("$TopLevel.MyTag")

/**/  type(untagged(M));
LIST
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Printing a Tagged Object(\ref{Printing a Tagged Object} pg.\pageref{Printing a Tagged Object}), 
    tag(\ref{tag} pg.\pageref{tag}), 
    untagged(\ref{untagged} pg.\pageref{untagged})
\end{command} % -- end command --------------------------------

\section{tail}
\label{tail}
\begin{command} % -- COMMAND: tail ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
tail(L: LIST): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the list obtained from L by removing its first
element.  It cannot be applied to the empty list.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  tail([1,2,3]);
[2, 3]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  first(\ref{first} pg.\pageref{first}), 
    last(\ref{last} pg.\pageref{last})
\end{command} % -- end command --------------------------------

\section{TensorMat [OBSOLESCENT]}
\label{TensorMat [OBSOLESCENT]}
\begin{command} % -- COMMAND: TensorMat [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&KroneckerProd&'' (\ref{KroneckerProd} pg.\pageref{KroneckerProd}).

\end{command} % -- end command --------------------------------

\section{TgCone}
\label{TgCone}
\begin{command} % -- COMMAND: TgCone ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
TgCone(I: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

The \textbf{initial form} of a polynomial ``\verb&f&'' is the homogeneous
component of ``\verb&f&'' of the lowest degree (in contrast with the
\textbf{leading form}, see ``\verb&LF&'' (\ref{LF} pg.\pageref{LF}), ``\verb&DF&'' (\ref{DF} pg.\pageref{DF})).
\par 
The \textbf{initial ideal} of the ideal ``\verb&I&'' is the ideal
generated by the initial forms of all polynomials in ``\verb&I&''.
It is also called \textbf{tangent cone} (which strictly is the variety
defined by the initial ideal).
\par 
The implementation is based on Lazard's method
(see Kreuzer-Robbiano, Commutative Computer Algebra 2, pg.463).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  TgCone(ideal(x^3-y));
ideal(y)
/**/  TgCone(ideal(x^3+x^2-y^2));
ideal(x^2 -y^2)

/**/  I := ideal(x^3-y*z, y^2-x*z, z^2-x^2*y);
/**/  TgCone(I); -- same as InitialIdeal(I, [x,y,z]);
ideal(z^2, y*z, y^2 -x*z)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  InitialIdeal(\ref{InitialIdeal} pg.\pageref{InitialIdeal}), 
    PrimaryHilbertSeries(\ref{PrimaryHilbertSeries} pg.\pageref{PrimaryHilbertSeries})
\end{command} % -- end command --------------------------------

\section{ThmProve [PROTOTYPE]}
\label{ThmProve [PROTOTYPE]}
\begin{command} % -- COMMAND: ThmProve [PROTOTYPE] ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ThmProve(Hypothesis: IDEAL of RINGELEM, Thesis: IDEAL of RINGELEM): RECORD
\end{Verbatim}


\subsection*{Description}

\textbf{This is just a prototype:} exact semantics, and interface are likely to change!
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ ThmMan();
/**/ ThmExample_FeetAndMidpoint();
/**/ ThmExample_Pappus();
/**/ ThmExample_DegenerateParallelogram();
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{TimeFrom}
\label{TimeFrom}
\begin{command} % -- COMMAND: TimeFrom ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
TimeFrom(StartPoint: RAT): STRING
\end{Verbatim}


\subsection*{Description}

This function returns a string indicating the number of CPU seconds consumed
since ``\verb&StartPoint&''; the value in ``\verb&StartPoint&'' should be the value produced
by the function ``\verb&CpuTime&'' (\ref{CpuTime} pg.\pageref{CpuTime}) at the point where timing should commence.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  t0 := CpuTime();
/**/  N := factorial(10000000);
/**/  PrintLn "Time to compute N: ",TimeFrom(t0);
Time to compute N: 7.538
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{TimeOfDay}
\label{TimeOfDay}
\begin{command} % -- COMMAND: TimeOfDay ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
TimeOfDay(): INT
\end{Verbatim}


\subsection*{Description}

This function returns the current time as an INT in the form
$HHMMSS = HH*10000+MM*100+SS$ using a 24-hour clock.
\par 
NOTE: from version 5.0.4 this information is no longer given by
the function ``\verb&date&'' (\ref{date} pg.\pageref{date}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  TimeOfDay();  -- 09:08:13
90813
/**/  date();       -- 2013-05-30
20130530
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  date(\ref{date} pg.\pageref{date})
\end{command} % -- end command --------------------------------

\section{TmpNBM [OBSOLETE]}
\label{TmpNBM [OBSOLETE]}
\begin{command} % -- COMMAND: TmpNBM [OBSOLETE] ------------



\subsection*{Description}

Renamed ``\verb&ApproxPointsNBM&'' (\ref{ApproxPointsNBM} pg.\pageref{ApproxPointsNBM}).

\end{command} % -- end command --------------------------------

\section{TopLevel}
\label{TopLevel}
\begin{command} % -- COMMAND: TopLevel ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
TopLevel X;
  where ``\verb&X&'' is the name of a top level variable or function.
\end{Verbatim}


\subsection*{Description}

This command makes a top-level variable accessible from inside a
function.  For instance, it is useful for making the rings ``\verb&QQ&'' (\ref{QQ} pg.\pageref{QQ}) and
``\verb&ZZ&'' (\ref{ZZ} pg.\pageref{ZZ}) accessible, and also if a top-level function is to be passed as
a parameter (\textit{e.g.} to the function ``\verb&SortBy&'' (\ref{SortBy} pg.\pageref{SortBy})).  It is poor style to
use ``\verb&TopLevel&'' for purposes other than these.
\par 
See also the commands ``\verb&ImportByRef, ImportByValue&'' (\ref{ImportByRef, ImportByValue} pg.\pageref{ImportByRef, ImportByValue}) if you want to
access a non-top-level variable inside an anonymous function.
\par 
NOTE: Package variables should be accessed directly, via their fully
qualified names.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  define BeautifulRing(N)
/**/    TopLevel QQ;
/**/    R ::= QQ[b[1..N]];
/**/    return R;
/**/  enddefine;


/**/  define CompareLen(X,Y) return len(X) < len(Y); EndDefine;

/**/  define LongestName(ListOfNameAndValue)
/**/    TopLevel CompareLen;  --> to pass it as paremeter to SortBy
/**/    names := [entry[1] | entry in ListOfNameAndValue];
/**/    SortBy(ref names, CompareLen);
/**/    return last(names);
/**/  EndDefine;

/**/  L := [["ABC",1],["XYZT",2]];
/**/  LongestName(L);
XYZT
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  func(\ref{func} pg.\pageref{func}), 
    ImportByRef, ImportByValue(\ref{ImportByRef, ImportByValue} pg.\pageref{ImportByRef, ImportByValue})
\end{command} % -- end command --------------------------------

\section{TopLevelFunctions}
\label{TopLevelFunctions}
\begin{command} % -- COMMAND: TopLevelFunctions ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
TopLevelFunctions(): LIST of FUNCTION
\end{Verbatim}


\subsection*{Description}

This function returns the list of all functions available at top-level
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  indent(TopLevelFunctions());
[
  record[IsExported := true, Name := "$BackwardCompatible.Abs"],
  record[IsExported := true, Name := "$BackwardCompatible.Append"],
  record[IsExported := true, Name := "$BackwardCompatible.Ascii"],
  ...
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{toric}
\label{toric}
\begin{command} % -- COMMAND: toric ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
toric(I: IDEAL): IDEAL
toric(I: IDEAL, L: LIST of INDETS): IDEAL
toric(M: MAT|LIST of LIST): IDEAL
toric(M: LIST of PP): IDEAL
\end{Verbatim}


\subsection*{Description}

These functions return the saturation of an ideal, I, generated by
binomials.  In the first two cases, I is the ideal generated by the
binomials in L.  To describe the ideal in the last case, let K be the
integral elements in the kernel of M.  For each k in K, we can write k
= k(+) - k(-) where the i-th component of k(+) is the i-th component
of k, if positive, otherwise zero.  Then I is the ideal generated by
the binomials ``\verb&x^k(+) - x^k(-)&'' as k ranges over K.
\par 
NOTE: successive calls to this last form of the function may produce
different generators for the saturation.
\par 
The first and third functions return the saturation of I.  For the
second function, if the saturation of I with respect to the variables
in X happens to equal the saturation of I, then the saturation of I is
returned.  Otherwise, an ideal \textbf{containing} the saturation with
respect to the given variables is returned.  The point is that if one
knows, a priori, that the saturation of I can be obtained by
saturating with respect to a subset of the variables, the second
function may be used to save time.
\par 
For more details, see the article:
A.M. Bigatti, R. La Scala, L. Robbiano, 
\textbf{Computing Toric Ideals,}
Journal of Symbolic Computation, 27, 351-365 (1999).
The article describes three different algorithms; the one implemented
in CoCoA is \textbf{EATI}.  The first two examples below are motivated
by B. Sturmfels, \textbf{Groebner Bases and Convex Polytopes,} Chapter
6, p. 51.  They count the number of homogeneous primitive partition
identities of degrees 8 and 9.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use QQ[x[1..8],y[1..8]];
/**/  HPPI8 := [x[1]^I*x[I+2]*y[2]^(I+1) -y[1]^I*y[I+2]*x[2]^(I+1) | I in 1..6];
/**/  BL := toric(ideal(HPPI8), [x[1],y[2]]);
/**/  len(gens(BL));
340

/**/  use QQ[x[1..9],y[1..9]];
/**/  HPPI9 := [x[1]^I*x[I+2]*y[2]^(I+1) -y[1]^I*y[I+2]*x[2]^(I+1) | I in 1..7];
/**/  BL := toric(ideal(HPPI9), [x[1],y[2]]);
/**/  len(gens(BL));
798

/**/  use R ::= QQ[x,y,z,w];
/**/  toric(ideal(x*z-y^2, x*w-y*z));
ideal(-y^2 +x*z, -y*z +x*w, z^2 -y*w)

/**/  toric(ideal(x*z-y^2, x*w-y*z), [y]);
ideal(-y^2 +x*z, -y*z +x*w, z^2 -y*w)

/**/  use R ::= QQ[x,y,z];
/**/  toric([[1,3,2],[3,4,8]]);
ideal(-x^16 +y^2*z^5)

/**/  toric(mat([[1,3,2],[3,4,8]]));
ideal(-x^16 +y^2*z^5)
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{transposed}
\label{transposed}
\begin{command} % -- COMMAND: transposed ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
transposed(M: MAT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the transpose of the matrix ``\verb&M&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := mat([[1,2,3],[4,5,6]]);
/**/  M;
matrix(QQ,
 [[1, 2, 3],
  [4, 5, 6]])

/**/  transposed(M);
matrix(QQ,
 [[1, 4],
  [2, 5],
  [3, 6]])
\end{Verbatim}


\end{command} % -- end command --------------------------------

\section{try}
\label{try}
\begin{command} % -- COMMAND: try ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
Try C1 UponError E Do C2 EndTry
  where C1, C2 are sequences of commands and E is a variable identifier.
\end{Verbatim}


\subsection*{Description}

Usually, when an error occurs during the execution of a command, the
error is automatically propagated out of the nesting of the
evaluation.  This can be prevented with the use of ``\verb&Try..UponError&''.
\par 
If an error occurs during the execution of the commands ``\verb&C1&'', then it is
captured by the command ``\verb&UponError&'' and assigned to the variable ``\verb&E&'',
and the commands ``\verb&C2&'' are executed; the string inside ``\verb&E&'' may be
retrieved using ``\verb&GetErrMesg&'' (\ref{GetErrMesg} pg.\pageref{GetErrMesg}).  If no error occurs then the variable ``\verb&E&''
and the commands ``\verb&C2&'' are ignored.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  -- Equality function allowing mixed types:
/**/  Define AreEqual(A,B)
/**/    Try
/**/      Return A = B;
/**/    UponError E Do
/**/      Return false;
/**/    EndTry;
/**/  EndDefine;

/**/  AreEqual(0, "zero");
false
/**/  AreEqual(1+2, 3);
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  error(\ref{error} pg.\pageref{error}), 
    GetErrMesg(\ref{GetErrMesg} pg.\pageref{GetErrMesg}), 
    All CoCoA commands(\ref{All CoCoA commands} pg.\pageref{All CoCoA commands})
\end{command} % -- end command --------------------------------

\section{tuples}
\label{tuples}
\begin{command} % -- COMMAND: tuples ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
tuples(S: LIST, N: INT): LIST
\end{Verbatim}


\subsection*{Description}

This function computes all N-tuples with entries in S.
It is equivalent to ``\verb&S >< S >< ... >< S&''  [N times].
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  tuples([1, 4, 7], 2);
[[1, 1], [1, 4], [1, 7], [4, 1], [4, 4], [4, 7], [7, 1], [7, 4], [7, 7]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CartesianProduct, CartesianProductList(\ref{CartesianProduct, CartesianProductList} pg.\pageref{CartesianProduct, CartesianProductList}), 
    permutations(\ref{permutations} pg.\pageref{permutations}), 
    subsets(\ref{subsets} pg.\pageref{subsets})
\end{command} % -- end command --------------------------------

\section{TVecFromHF}
\label{TVecFromHF}
\begin{command} % -- COMMAND: TVecFromHF ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
TVecFromHF(H: TAGGED): LIST
TVecFromHF(H: LIST): LIST
\end{Verbatim}


\subsection*{Description}

This function returns a LIST representing the type vector corresponding
to the Hilbert function ``\verb&H&''.
\par 
This is part of the CoCoA package ``\verb&TypeVectors&''
originally by E.Carlini, M.Stewart
for computing with "type vectors" as described in
  A.Geramita, T.Harima, Y.Shin
"An alternative to the Hilbert function
 for the ideal of a finite set of points in $P^n$"
Illinois J.Math. vol.45 (2001), no. 1, pages 1--23.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Use P ::= QQ[x,y,z,t];
/**/  HF := HilbertFn(P/Ideal(x, y^3, z^2-t*x));  HF;
/**/  TV := TVecFromHF(HF);  TV;
[[[2],  [4]]]
/**/  TV := TVecFromHF([[1, 3, 5], 6]);  TV;
[[[2],  [4]]]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  TVecToHF(\ref{TVecToHF} pg.\pageref{TVecToHF}), 
    TVecPrintRes(\ref{TVecPrintRes} pg.\pageref{TVecPrintRes}), 
    TVecPoints(\ref{TVecPoints} pg.\pageref{TVecPoints})
\end{command} % -- end command --------------------------------

\section{TVecPoints}
\label{TVecPoints}
\begin{command} % -- COMMAND: TVecPoints ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
TVecToHF(TV: LIST): TAGGED
\end{Verbatim}


\subsection*{Description}

This function return the points associated to the type vector ``\verb&TV&''.
\par 
See ``\verb&TVecFromHF&'' (\ref{TVecFromHF} pg.\pageref{TVecFromHF}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Use P ::= QQ[x,y,z,t];
/**/  HF := HilbertFn(P/Ideal(x, y^3, z^2-t*x));  HF;
/**/  TV := TVecFromHF(HF);  TV;
/**/  Pts := TVecPoints(TV);  indent(Pts);
[
  [0,  0,  0,  1],
  [0,  0,  1,  1],
  [0,  0,  2,  1],
  [0,  0,  3,  1],
  [0,  1,  0,  1],
  [0,  1,  1,  1]
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  TVecFromHF(\ref{TVecFromHF} pg.\pageref{TVecFromHF}), 
    TVecPrintRes(\ref{TVecPrintRes} pg.\pageref{TVecPrintRes}), 
    TVecToHF(\ref{TVecToHF} pg.\pageref{TVecToHF})
\end{command} % -- end command --------------------------------

\section{TVecPrintRes}
\label{TVecPrintRes}
\begin{command} % -- COMMAND: TVecPrintRes ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
TVecPrintRes(TV: LIST)
\end{Verbatim}


\subsection*{Description}

This function prints the resolution associated to the type vector ``\verb&TV&'',
\textit{i.e.} of the ideal of a K-configuration described by ``\verb&TV&''.
\par 
See ``\verb&TVecFromHF&'' (\ref{TVecFromHF} pg.\pageref{TVecFromHF}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Use P ::= QQ[x,y,z,t];
/**/  HF := HilbertFn(P/Ideal(x, y^3, z^2-t*x));  HF;
/**/  TV := TVecFromHF(HF);  TV;
/**/  TVecPrintRes(TV);
0 --> R(-5)(+)R(-6) --> R(-3)(+)R^2(-4)(+)R^2(-5) --> R(-1)(+)R(-2)(+)R(-3)(+)R(-4) --> R
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  TVecFromHF(\ref{TVecFromHF} pg.\pageref{TVecFromHF}), 
    TVecPoints(\ref{TVecPoints} pg.\pageref{TVecPoints}), 
    TVecToHF(\ref{TVecToHF} pg.\pageref{TVecToHF})
\end{command} % -- end command --------------------------------

\section{TVecToHF}
\label{TVecToHF}
\begin{command} % -- COMMAND: TVecToHF ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
TVecToHF(TV: LIST): TAGGED
\end{Verbatim}


\subsection*{Description}

This function returns the Hilbert function associated to the type vector ``\verb&TV&''.
\par 
See ``\verb&TVecFromHF&'' (\ref{TVecFromHF} pg.\pageref{TVecFromHF})
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  Use P ::= QQ[x,y,z,t];
/**/  T := TVecFromHF([[1, 3, 5], 6]);  T;
[[[2],  [4]]]
/**/  TVecToHF([[[2], [4]]]);
H(0) = 1
H(1) = 3
H(2) = 5
H(t) = 6   for t >= 3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  TVecFromHF(\ref{TVecFromHF} pg.\pageref{TVecFromHF}), 
    TVecPrintRes(\ref{TVecPrintRes} pg.\pageref{TVecPrintRes}), 
    TVecPoints(\ref{TVecPoints} pg.\pageref{TVecPoints})
\end{command} % -- end command --------------------------------

\section{type}
\label{type}
\begin{command} % -- COMMAND: type ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
type(E: OBJECT): TYPE
\end{Verbatim}


\subsection*{Description}

This function returns the data type of E.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ L := [1,"a",2,"b",3,"c"];
/**/ [ X in L | type(X)=INT ];
[1, 2, 3]

/**/  type(type(INT));  -- Type returns a value of type TYPE
TYPE

/**/  CurrentTypes();
[BOOL, ERROR, FUNCTION, ...]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  shape(\ref{shape} pg.\pageref{shape}), 
    CurrentTypes(\ref{CurrentTypes} pg.\pageref{CurrentTypes})
\end{command} % -- end command --------------------------------

\chapter{U}  %----=== CHAPTER LETTER ===----
\label{U}

\section{UnivariateIndetIndex}
\label{UnivariateIndetIndex}
\begin{command} % -- COMMAND: UnivariateIndetIndex ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
UnivariateIndetIndex(F: RINGELEM): INT
\end{Verbatim}


\subsection*{Description}

This function returns 0 if the polynomial ``\verb&F&'' is not univariate
otherwise it returns the indeterminate index of ``\verb&F&''.  If ``\verb&F&'' is
constant, the function throws an error.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  UnivariateIndetIndex(3*x^4-2*x-1);
1

/**/  UnivariateIndetIndex(x-y-1);
0
\end{Verbatim}



\SeeAlso %---- SEE ALSO ----
  indet(\ref{indet} pg.\pageref{indet}), 
    IndetSubscripts(\ref{IndetSubscripts} pg.\pageref{IndetSubscripts}), 
    IndetIndex(\ref{IndetIndex} pg.\pageref{IndetIndex}), 
    IndetName(\ref{IndetName} pg.\pageref{IndetName}), 
    indets(\ref{indets} pg.\pageref{indets}), 
    NumIndets(\ref{NumIndets} pg.\pageref{NumIndets})
\end{command} % -- end command --------------------------------

\section{UniversalGBasis}
\label{UniversalGBasis}
\begin{command} % -- COMMAND: UniversalGBasis ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
UniversalGBasis(I: IDEAL): LIST of RINGELEM
\end{Verbatim}


\subsection*{Description}

Returns a universal Groebner basis of the input IDEAL ``\verb&I&''.
\par 
This function was called ``\verb&UniversalGroebnerBasis&'' up to
version CoCoA-5.1.4.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
-- The ideal generated by the 3x3 minors of 3x4 matrix of indeterminates
-- has 96 marked reduced Groebner bases
/**/  use R ::= QQ[a,b,c,d,e,f,g,h,i,j,k,l];
/**/  I := ideal(minors(mat([[a,b,c,d],[e,f,g,h],[i,j,k,l]]),3));
/**/  indent(UniversalGBasis(I));
[d*g*j -c*h*j -d*f*k +b*h*k +c*f*l -b*g*l,
 d*g*i -c*h*i -d*e*k +a*h*k +c*e*l -a*g*l,
 d*f*i -b*h*i -d*e*j +a*h*j +b*e*l -a*f*l,
 c*f*i -b*g*i -c*e*j +a*g*j +b*e*k -a*f*k
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  GroebnerFanIdeals(\ref{GroebnerFanIdeals} pg.\pageref{GroebnerFanIdeals})
\end{command} % -- end command --------------------------------

\section{unprotect}
\label{unprotect}
\begin{command} % -- COMMAND: unprotect ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
unprotect X;
\end{Verbatim}


\subsection*{Description}

This command undoes the effect of the ``\verb&protect&'' (\ref{protect} pg.\pageref{protect}) command; once a
variable has been unprotected, it may be assigned to freely.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ X := 1;
/**/ protect X;    --> cannot assign to X henceforth
/**/
/**/ unprotect X;  --> remove protection, X may be assigned to now
/**/ X := 2;
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  protect(\ref{protect} pg.\pageref{protect})
\end{command} % -- end command --------------------------------

\section{Unset [OBSOLETE]}
\label{Unset [OBSOLETE]}
\begin{command} % -- COMMAND: Unset [OBSOLETE] ------------



\subsection*{Description}

[OBSOLETE]

\end{command} % -- end command --------------------------------

\section{untagged}
\label{untagged}
\begin{command} % -- COMMAND: untagged ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
untagged(E:TAGGED_OBJECT): OBJECT
\end{Verbatim}


\subsection*{Description}

This function strips an object ``\verb&E&'' of its tag, if any.
\par 
Tags are used for pretty printing of objects: see the reference
``Printing a Tagged Object'' (\ref{Printing a Tagged Object} pg.\pageref{Printing a Tagged Object}).
\par 
NOTE: in CoCoA-4 the obsolete syntax ``\verb&@E&'' should be replaced
by ``\verb&untagged(E)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [1,2,3];
/**/  M := tagged(L,"MyTag");
/**/  type(L);
LIST

/**/  type(M);
TAGGED("MyTag")

/**/  type(untagged(M));
LIST
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Printing a Tagged Object(\ref{Printing a Tagged Object} pg.\pageref{Printing a Tagged Object}), 
    tag(\ref{tag} pg.\pageref{tag}), 
    tagged(\ref{tagged} pg.\pageref{tagged})
\end{command} % -- end command --------------------------------

\section{use}
\label{use}
\begin{command} % -- COMMAND: use ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
use R
use RingDefn
use R ::= RingDefn

where R is a RING, and RingDefn is a ring definition.
\end{Verbatim}


\subsection*{Description}

This command works only at top-level; it makes a ring active,
\textit{i.e.} it makes that ring the \textbf{current ring}.
The command will also let you create a new ring, and make it active
immediately ``\verb&use NewR ::= RingDefn;&'' where ``\verb&RingDefn&'' is
a ring definition; this is a shorthand for
``\verb&NewR ::= RingDefn;  use NewR;&''
\par 
This command cannot be called inside a function, and it is never
necessary (if you write clean programs ;-).
See also ``\verb&RingElem&'' (\ref{RingElem} pg.\pageref{RingElem}) for reading elements without ``\verb&use&''.
In CoCoA-5 you can define new rings, return rings, assign rings and
pass rings as arguments (this was not possible in CoCoA-4).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use S ::= QQ[x,y,z];
/**/  Print CurrentRing;
RingDistrMPolyClean(QQ, 3)
/**/  indets(CurrentRing);
[x, y, z]

/**/  use QQ[u];  -- can be used w/out a ring identifier
/**/  indets(CurrentRing);
[u]

/**/  define SumInAnotherRing(N)
/**/    K := NewRingTwinFloat(128); -- 128 bits of precision
/**/    P ::= K[x[1..N]], Lex;
/**/    return sum(indets(P));
/**/  enddefine;

/**/  SumInAnotherRing(4);
x[1] +x[2] +x[3] +x[4]
/**/  CoeffRing(RingOf(It));
RingTwinFloat(AccuracyBits=128, BufferBits=128, NoiseBits=32)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Introduction to RINGHOM(\ref{Introduction to RINGHOM} pg.\pageref{Introduction to RINGHOM}), 
    CurrentRing(\ref{CurrentRing} pg.\pageref{CurrentRing}), 
    RingOf(\ref{RingOf} pg.\pageref{RingOf}), 
    RingElem(\ref{RingElem} pg.\pageref{RingElem})
\end{command} % -- end command --------------------------------

\chapter{V}  %----=== CHAPTER LETTER ===----
\label{V}

\section{valuation [OBSOLETE]}
\label{valuation [OBSOLETE]}
\begin{command} % -- COMMAND: valuation [OBSOLETE] ------------



\subsection*{Description}

Renamed ``\verb&FactorMultiplicity&'' (\ref{FactorMultiplicity} pg.\pageref{FactorMultiplicity}).

\SeeAlso %---- SEE ALSO ----
  FactorMultiplicity(\ref{FactorMultiplicity} pg.\pageref{FactorMultiplicity})
\end{command} % -- end command --------------------------------

\section{VerbosityLevel}
\label{VerbosityLevel}
\begin{command} % -- COMMAND: VerbosityLevel ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
VerbosityLevel(): INT
\end{Verbatim}


\subsection*{Description}

This function returns the current CoCoA verbosity level.
\par 
User defined functions may check this value when deciding whether to
print out some internal progress messages: normally printing should
happen only if ``\verb&VerbosityLevel()&'' is higher than some threshold value.
\par 
Various functions in CoCoALib and in the CoCoA-5 packages do this, but
they all have threshold values greater than 9.  So threshold values
from 1 to 9 may be used in user functions without triggering any
verbosity from CoCoA.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ define SimpleFn(n)
/**/   if VerbosityLevel() >= 4 then
/**/     println "SimpleFn: input type is ", type(n);
/**/   endif;
/**/   return n^2;
/**/ enddefine;

/**/  use P ::= QQ[x,y,z];
/**/  SetVerbosityLevel(9);
/**/  SimpleFn(ideal(indets(CurrentRing)));
SimpleFn: input type is IDEAL
ideal(z^2,  y*z,  x*z,  y^2,  x*y,  x^2)

/**/  SetVerbosityLevel(0);  --> unset verbosity
/**/  SimpleFn(ideal(indets(CurrentRing)));
ideal(z^2,  y*z,  x*z,  y^2,  x*y,  x^2)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  SetVerbosityLevel(\ref{SetVerbosityLevel} pg.\pageref{SetVerbosityLevel})
\end{command} % -- end command --------------------------------

\section{VersionInfo}
\label{VersionInfo}
\begin{command} % -- COMMAND: VersionInfo ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
VersionInfo(): RECORD
\end{Verbatim}


\subsection*{Description}

This function returns a record with various information about CoCoA
and CoCoALib (the mathematical core of CoCoA)
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ indent(VersionInfo(),2);
record[
  CoCoALibVersion := "0.99***",
  CoCoAVersion := "5.*.*",
  CompilationDate := ....,
  ...
  ExternalLibs := [...]
]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CoCoALib(\ref{CoCoALib} pg.\pageref{CoCoALib}), 
    RelNotes(\ref{RelNotes} pg.\pageref{RelNotes})
\end{command} % -- end command --------------------------------

\chapter{W}  %----=== CHAPTER LETTER ===----
\label{W}

\section{wdeg}
\label{wdeg}
\begin{command} % -- COMMAND: wdeg ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
wdeg(F: RINGELEM): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the multi-weighted degree of F, as determined by
the matrix weights of the polynomial ring of F.  The function ``\verb&deg&'' (\ref{deg} pg.\pageref{deg})
returns the standard degree.
\par 
NOTE: In CoCoA-4 ``\verb&deg&'' (\ref{deg} pg.\pageref{deg}) gave the weight given by only the first row
of the weights matrix.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := matrix([[2,3,4], [1,0,2], [1,0,0]]);
/**/  P := NewPolyRing(QQ, "x,y,z", M, 1);  -- GradingDim=1
/**/  use P;
/**/  wdeg(x*y^2+y);
[8]
/**/  P := NewPolyRing(QQ, "x,y,z", M, 2);  -- GradingDim=2
/**/  use P;
/**/  wdeg(x*y^2+y);
[8, 1]
/**/  deg(x*y^2+y);
3

/**/  P4 := NewFreeModule(P,4); -- the default module ordering is TOPos
/**/  wdeg(ModuleElem(P4, [0, x, y^2, x^2]));
[6, 0]

/**/  LT(ModuleElem(P4, [0, x, y^2, x^2]));
[0, 0, y^2, 0]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  deg(\ref{deg} pg.\pageref{deg}), 
    LF(\ref{LF} pg.\pageref{LF})
\end{command} % -- end command --------------------------------

\section{WeightsMatrix [OBSOLESCENT]}
\label{WeightsMatrix [OBSOLESCENT]}
\begin{command} % -- COMMAND: WeightsMatrix [OBSOLESCENT] ------------



\subsection*{Description}

Renamed ``\verb&GradingMat&'' (\ref{GradingMat} pg.\pageref{GradingMat}).

\SeeAlso %---- SEE ALSO ----
  deg(\ref{deg} pg.\pageref{deg}), 
    wdeg(\ref{wdeg} pg.\pageref{wdeg})
\end{command} % -- end command --------------------------------

\section{while}
\label{while}
\begin{command} % -- COMMAND: while ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
While B Do C EndWhile

where B is a boolean expression and C is a sequence of commands.
\end{Verbatim}


\subsection*{Description}

The command sequence ``\verb&C&'' is repeated until ``\verb&B&'' evaluates to ``\verb&false&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  N := 0;
/**/  while N <= 5 do
/**/    PrintLn 2, "^", N, " = ", 2^N;
/**/    N := N+1;
/**/  EndWhile;
2^0 = 1
2^1 = 2
2^2 = 4
2^3 = 8
2^4 = 16
2^5 = 32
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  for(\ref{for} pg.\pageref{for}), 
    foreach(\ref{foreach} pg.\pageref{foreach}), 
    repeat(\ref{repeat} pg.\pageref{repeat}), 
    All CoCoA commands(\ref{All CoCoA commands} pg.\pageref{All CoCoA commands})
\end{command} % -- end command --------------------------------

\section{WithoutNth}
\label{WithoutNth}
\begin{command} % -- COMMAND: WithoutNth ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
WithoutNth(L: LIST, N: INT): LIST
\end{Verbatim}


\subsection*{Description}

This function returns the list obtained by removing the ``\verb&N&''-th component
of the list ``\verb&L&''.  The list ``\verb&L&'' itself is not changed; compare with
``\verb&remove&'' (\ref{remove} pg.\pageref{remove}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := [1,2,3,4,5];
/**/  WithoutNth(L,3);
[1, 2, 4, 5]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  remove(\ref{remove} pg.\pageref{remove})
\end{command} % -- end command --------------------------------

\section{WLog [OBSOLETE]}
\label{WLog [OBSOLETE]}
\begin{command} % -- COMMAND: WLog [OBSOLETE] ------------



\subsection*{Description}

[OBSOLETE]

\SeeAlso %---- SEE ALSO ----
  exponents(\ref{exponents} pg.\pageref{exponents})
\end{command} % -- end command --------------------------------

\chapter{X}  %----=== CHAPTER LETTER ===----
\label{X}

\section{XelMat}
\label{XelMat}
\begin{command} % -- COMMAND: XelMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
XelMat(N: INT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the matrix defining a standard term-ordering.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  XelMat(3);
matrix(ZZ,
 [[0, 0, 1],
  [0, 1, 0],
  [1, 0, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  OrdMat(\ref{OrdMat} pg.\pageref{OrdMat}), 
    Term Orderings(\ref{Term Orderings} pg.\pageref{Term Orderings}), 
    StdDegRevLexMat(\ref{StdDegRevLexMat} pg.\pageref{StdDegRevLexMat}), 
    StdDegLexMat(\ref{StdDegLexMat} pg.\pageref{StdDegLexMat}), 
    LexMat(\ref{LexMat} pg.\pageref{LexMat}), 
    RevLexMat(\ref{RevLexMat} pg.\pageref{RevLexMat})
\end{command} % -- end command --------------------------------

\chapter{Z}  %----=== CHAPTER LETTER ===----
\label{Z}

\section{zero}
\label{zero}
\begin{command} % -- COMMAND: zero ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
zero(R: RING): RINGELEM
\end{Verbatim}


\subsection*{Description}

This function returns the additive identity of a ring.
For when you want to force the integer ``\verb&0&'' to be a RINGELEM.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ P ::= ZZ/(101)[x,y,z];

/**/ N := 0;  Print N, " of type ",  type(N);
0 of type INT
/**/ N := zero(P);  Print N, " of type ",  type(N);
0 of type RINGELEM
/**/ N := 300*0;  Print N, " of type ",  type(N);
0 of type INT
/**/ N := 300*zero(P);  Print N, " of type ",  type(N);
0 of type RINGELEM

/**/  F := NewFreeModule(P, 3);
/**/  zero(F);
[0, 0, 0]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  one(\ref{one} pg.\pageref{one}), 
    IsZero(\ref{IsZero} pg.\pageref{IsZero})
\end{command} % -- end command --------------------------------

\section{ZeroMat}
\label{ZeroMat}
\begin{command} % -- COMMAND: ZeroMat ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ZeroMat(R: RING, NumRows: INT, NumCols: INT): MAT
\end{Verbatim}


\subsection*{Description}

This function returns the ``\verb&NumRows x NumCols&'' zero matrix
with entries in ``\verb&R&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  ZeroMat(QQ, 1, 3); --> same as NewMatFilled(1,3, 0)
matrix(QQ,
 [[0, 0, 0]])
/**/  ZeroMat(R, 1, 3); --> same as NewMatFilled(1,3, zero(R))
matrix( /*RingDistrMPolyClean(QQ, 3)*/
 [[0, 0, 0]])
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  matrix(\ref{matrix} pg.\pageref{matrix}), 
    IdentityMat(\ref{IdentityMat} pg.\pageref{IdentityMat}), 
    NewMatFilled(\ref{NewMatFilled} pg.\pageref{NewMatFilled})
\end{command} % -- end command --------------------------------

\section{ZPQ}
\label{ZPQ}
\begin{command} % -- COMMAND: ZPQ ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ZPQ(F: RINGELEM): RINGELEM
ZPQ(F: LIST of RINGELEM): LIST of RINGELEM
ZPQ(I: IDEAL): IDEAL
\end{Verbatim}


\subsection*{Description}

***** NOT YET IMPLEMENTED *****
\par 
The function ``\verb&ZPQ&'' maps a polynomial with finite field coefficients
into one with rational (actually, integer) coefficients.  It is not
uniquely defined mathematically, and currently for each coefficient
the least non-negative equivalent integer is chosen.
Users should not rely on this choice, though any change will be
documented.
\par 
See ``\verb&QZP&'' (\ref{QZP} pg.\pageref{QZP}) for more details.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
***** NOT YET IMPLEMENTED *****
  use R ::= QQ[x,y,z];
  F := 1/2*x^3 + 34/567*x*y*z - 890; -- a poly with rational coefficients
  use S ::= ZZ/(101)[x,y,z];
  QZP(F);                            -- compute its image with coeffs in ZZ/(101)
-50x^3 - 19xyz + 19
-------------------------------
  G := It;
  use R;
  ZPQ(G);     -- now map that result back to QQ[x,y,z] it is NOT the same as F...
51x^3 + 82xyz + 19
-------------------------------
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  BringIn(\ref{BringIn} pg.\pageref{BringIn})
\end{command} % -- end command --------------------------------

\section{ZZ}
\label{ZZ}
\begin{command} % -- COMMAND: ZZ ------------


\begin{Verbatim}[label=syntax, rulecolor=\color{MidnightBlue},
frame=single]
ZZ: RING
\end{Verbatim}


\subsection*{Description}

This system variable is constant; its value is the ring of integers.
Its name is protected so that it cannot be re-assigned to any other value.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  type(5);
INT
/**/  type(RingElem(ZZ, 5));
RINGELEM

/**/  P ::= ZZ/(101)[x,y,z]; -- coeffs in quotient ring
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  QQ(\ref{QQ} pg.\pageref{QQ}), 
    Quotient Rings(\ref{Quotient Rings} pg.\pageref{Quotient Rings})
\end{command} % -- end command --------------------------------

% -- PART 1 --------------------------------

  
\part{CoCoA Tutorials and Programming Language}
\setcounter{chapter}{0}
    

% -- CHAPTER --------------------------------
\chapter{CoCoA Tutorials}
\label{CoCoA Tutorials}

      

% -- SECTION --------------------------------
\section{Basic Tutorial for CoCoA-5}
\label{Basic Tutorial for CoCoA-5}

        
Use the command ``\verb&ciao;&'' to get out of CoCoA-5.  It is important to type
the semicolon ";" after the word "ciao".  As a rule, you should put a
semicolon after every CoCoA-5 command.  After receiving the ``\verb&ciao&''
command, it may occasionally take a few seconds for CoCoA-5 to fully
terminate itself.
\par 
If CoCoA-5 is busy computing, it will not heed any further commands
(including ``\verb&ciao;&'') until the computation ends.  When CoCoA-5 is
ready for a new command it prints out a prompt; if the previous input
was incomplete, this is indicated by a different prompt.
\par 
If CoCoA-5 is taking too long with a computation you may "interrupt" it
(\textit{i.e.} forcibly end it prematurely); it may take a few seconds for
CoCoA-5 to react after you give the interrupt signal.  CoCoA-5 will print
a prompt when the computation has been stopped; it is then ready to
receive new commands.  The correct way to interrupt a CoCoA computation
depends on the user interface (and operating system).
\par 
If you are still stuck inside CoCoA-5, you can try ``\verb&*/ciao;&'' instead;
note the extra two characters "star" and "slash" at the start.  You may
need to type this twice.


% -- SECTION --------------------------------
\section{Tutorial: manual}
\label{Tutorial: manual}

        
CoCoA-5 includes an on-line manual which explains what the various
commands and functions do.  To consult the manual you use ``\verb&?&''
followed by a keyword; for instance to find out how to compute
GCDs in CoCoA, you could type ``\verb&?gcd&''.  This will print out the
corresponding manual page.  Notice at the bottom that there is usually
a list of related manual pages (with ``\verb&?&'' at the start so you can
easily cut-and-paste to go to the indicated manual page).
\par 
If your keyword does not identify a unique manual page then you will see
a list of manual entries which do contain the keyword; again each entry
is preceded by ``\verb&?&'' to make it quicker to use cut-and-paste.
\par 
A double-query will simply list the titles of all manual pages containing
the keyword: for example try ``\verb&??gcd&''.
\par 
Unlike for normal commands, there is no need to type a semicolon at
the end of a manual query (but you can type one if you want).


% -- SECTION --------------------------------
\section{Tutorial: Emacs UI (basic)}
\label{Tutorial: Emacs UI (basic)}

        
The developers of CoCoA use the (GNU) emacs UI to CoCoA-5, so it is
extensively tested.  Other UIs may become available in the future.
\par 
Emacs is an extensible text editor with numerous functions.  One of these
extensions helps one edit files of CoCoA commands, and also run an
interactive CoCoA-5 session.  Many of the special functions for CoCoA-5
are available from a "drop-down" menu (under the title CoCoA-5).
\par 
We find the following approach convenient.  Inside Emacs use the
"Open File" function to open (or create) a file whose name \textbf{must} end
in ".cocoa5".  Type in your commands and function definitions into this
file; then use "Source file into CoCoA-5" or "Source region into CoCoA-5".
An advantage of this approach is that if you make a mistake, you can
easily edit the file, and then send the corrected commands to CoCoA-5.
\par 
The functions can also be activated via suitable key-sequences; this is
usually quicker than using the menus, but entails memorizing the most
useful "key sequences".  A key sequence usually looks cryptic:
for example in the key sequence "C-M-\", the substring "M-" means to
press and release the "Esc" key, while the substring "C-" means to
press and hold the "Ctrl" key, finally you should press briefly the
"\" (backslash) key.
\par 
Some more help for Emacs can be found online at the following link:
``\verb&http://cocoa.dima.unige.it/download/screenshots.shtml&''

\SeeAlso %---- SEE ALSO ----
  Basic Tutorial for CoCoA-5(\ref{Basic Tutorial for CoCoA-5} pg.\pageref{Basic Tutorial for CoCoA-5})

% -- SECTION --------------------------------
\section{Tutorial: variables, assignment}
\label{Tutorial: variables, assignment}

        
CoCoA-5 includes its own \textit{imperative} programming language.
Values you plan to use in future computations need to be \textit{stored} in
variables; the act of storing a value in a variable is also called
\textit{assignment}.  CoCoA-5 uses the \textit{colon-equals} operator to indicate
assignment, for instance ``\verb&A := 13;&'' assigns 13 to the variable ``\verb&A&''.
\par 
A variable name must start with a letter, and may contain letters,
digits, and the underscore character.  We recommend using names
which are mnemonic (but hopefully not too long).
\par 
The most basic types in CoCoA-5 are integers, rationals and strings.
A number written in "decimal notation" is automatically converted to
a rational number: for example ``\verb&3.14&'' is converted into the fraction
``\verb&157/50&''.

\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ A := 1;          // assign the integer 1 to the variable "A"
/**/ half := 1/2;     // assign rational 1/2 to the variable "half"
/**/ A := 0.333;      // assign the rational 333/1000 to "A"
                      // The previously stored value is overwritten.
/**/ mesg1 := "hi!";  // assign the string "hi!" to variable "mesg1"
\end{Verbatim}



% -- SECTION --------------------------------
\section{Tutorial: arithmetic operators}
\label{Tutorial: arithmetic operators}

        
CoCoA-5 includes its own \textit{imperative} programming language.  The
language includes some fairly natural arithmetic operators (usually
similar to other computer algebra systems).
\par 
The main peculiarities are: \textit{colon-equals} representing assignment,
\textit{less-than greater-than} representing not-equals, and the words ``\verb&and&'',
``\verb&or&'' and ``\verb&not&'' representing the boolean operations.
\par 
To see a complete list of all infix operators, type the manual query
``\verb&?operator&''

\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ A := 1;          // assign the integer 1 to the variable "A"
/**/ 1+2*3^4;         // addition, multiplication, power
163
/**/ 1-2/3;           // subtraction, division
1/3
/**/ (A > 0) and (A < 2);  // greater-than, less-than, boolean "and"
true
/**/ (A >= 0) or (A <= 2); // greater-or-equal, less-or-equal, boolean "or"
true
/**/ (A = 1) or (A <> 2);  // equal, not-equal
true
/**/ not(A > -1 and A < 3); // boolean "not"
false
\end{Verbatim}



% -- SECTION --------------------------------
\section{Tutorial: printing}
\label{Tutorial: printing}

        
The way CoCoA-5 can show us the results of its computation is by
(so-called) \textit{printing} them on the screen.
\par 
At top level, if you type in an expression for a computation,
CoCoA-5 will evaluate the expression, and then automatically print
out the answer.  This is convenient for interactive use.
\par 
Inside a function definition you must use explicitly a printing
command: the two fundamental printing commands are ``\verb&println&''
and ``\verb&print&''.  The only difference between them is that the
first command also prints out a \textit{newline} at the end; this is
usually what is desired.
\par 
The procedure ``\verb&indent&'' is useful for printing out long
lists of values: it prints a newline after each list entry
(whereas ``\verb&print&'' and ``\verb&println&'' will print all entries
on the same line).
\par 
To help comprehend the true size of large integers or rationals
there is the function ``\verb&FloatStr&'' which prints out the
value using an easy-to-understand floating-point format.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ 1+2; // an expression at top level
3
/**/ println 1; println 2;
1
2
/**/ print 1; print 2;
12
/**/ println [11,22];
[11, 22]
/**/ indent([11,22]);
[
  11,
  22
]
\end{Verbatim}



% -- SECTION --------------------------------
\section{Tutorial: lists}
\label{Tutorial: lists}

        
A convenient way of "putting together" many values in CoCoA-5
is to put them into a LIST.  Though the CoCoA-5 name is LIST
the data-structure more closely resembles a \textit{vector} in C++
than a \textit{list} in C++.
\par 
CoCoA-5 does not impose restrictions on the values a LIST may
contain; nevertheless it usually makes most sense if the values
are all of the same type (\textit{e.g.} all integers, all polynomials).
\par 
A list may be created in several ways.  The simplest is to write
out the entries explicitly.  Another is to start with an empty list,
and the append new elements in a loop.  There is also a convenient
syntax inspired by the mathematical notation for sets.
\par 
If you have a list, you can find out how many elements it contains
using the function ``\verb&len&''.  You can also iterate over the
elements of a list using the ``\verb&foreach&'' loop command.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ [2,3,5];  // list containing the elements 2,3,5 in that order
[2, 3, 5]
/**/ 1..5;  // integer range
[1, 2, 3, 4, 5]
// Now create a list using "append":
/**/ L := [];  // start with the empty list in L
/**/ for i := 1 to 5 do append(ref L, i^2); endfor;
/**/ println L;
[1, 4, 9, 16, 25]
/**/ [ n in L | IsEven(n)];  // list containing even values
[4, 16]
/**/ [ n^2 | n in L  and  n < 10];
[1, 16, 81]
/**/ len(L);
5
/**/ foreach n in L do print n," "; endforeach;
1 4 9 16 25
\end{Verbatim}



% -- SECTION --------------------------------
\section{Tutorial: polynomial rings, use command}
\label{Tutorial: polynomial rings, use command}

        
When you want to do a computation in CoCoA-5, the first thing you
need to do is tell CoCoA-5 in which ring to compute.  The ``\verb&use&'' (\ref{use} pg.\pageref{use})
command informs CoCoA-5 about this.  The most convenient method does
two things at once: it creates the polynomial ring, and then chooses
that ring as the "current ring".
\par 
Once the correct current ring has been selected, you may type in
polynomials using a natural syntax; note that you must use ``\verb&*&'' to
denote all products (\textit{e.g.} between coefficients and indeterminates,
or even between powers of indeterminates).
\par 
The most common coefficient fields are the rationals (denoted by ``\verb&QQ&'')
and small prime finite fields (denoted by ``\verb&ZZ/(p)&'').

\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use P ::= QQ[x,y];  // polys in x,y with coefficients in QQ
/**/ (x+y)^2;
x^2 + 2*x*y + y^2
/**/ use ZZ/(2)[a,b];   // polys in a,b with coefficients in ZZ/(2)
/**/ (a+b)^2;
a^2 + b^2
/**/ use QQ[x,y,z],lex;  // polys in x,y,z, coeffs in QQ, term order "lex"
/**/ x+y^2;
x + y^2
\end{Verbatim}



% -- SECTION --------------------------------
\section{Tutorial: polynomials}
\label{Tutorial: polynomials}

        
If you are new to CoCoA-5, we recommend that you read first the
``\verb&Tutorial: polynomial rings, use command&'' (\ref{Tutorial: polynomial rings, use command} pg.\pageref{Tutorial: polynomial rings, use command}).
\par 
A complete list of the functions and commands which operate on
or return a polynomial can be obtained by looking up "RINGELEM"
in the on-line manual.
\par 
In addition to the usual arithmetic operations, CoCoA-5 offers
several functions for looking "inside" a polynomial.  We give
some examples here.  Each non-zero polynomial has a leading
monomial (see ``\verb&LM&'' (\ref{LM} pg.\pageref{LM})), a leading coefficient (see ``\verb&LC&'' (\ref{LC} pg.\pageref{LC})), and a
leading term (see ``\verb&LT&'' (\ref{LT} pg.\pageref{LT}) and ``\verb&LPP&'' (\ref{LPP} pg.\pageref{LPP})).
\par 
One may also extract all monomials (see ``\verb&monomials&'' (\ref{monomials} pg.\pageref{monomials})), all
coefficients (see ``\verb&coefficients&'' (\ref{coefficients} pg.\pageref{coefficients})), and all power-products
(see ``\verb&support&'' (\ref{support} pg.\pageref{support})).  In each case the lists have the same order
as in the polynomial itself.
\par 
There are more advanced functions for exploring the structure of
a polynomial: see for instance ``\verb&CoefficientsWRT&'' (\ref{CoefficientsWRT} pg.\pageref{CoefficientsWRT}), ``\verb&CoeffListWRT&'' (\ref{CoeffListWRT} pg.\pageref{CoeffListWRT}),
and ``\verb&CoeffOfTerm&'' (\ref{CoeffOfTerm} pg.\pageref{CoeffOfTerm}).

\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ use P ::= QQ[x,y];  // polys in x,y with coefficients in QQ
/**/ f := (2*x^2+y)^3; f;
8*x^6 +12*x^4*y +6*x^2*y^2 +y^3
/**/ [LM(f), LC(f), LT(f)];
[8*x^6,  8,  x^6]
/**/ monomials(f);
[8*x^6,  12*x^4*y,  6*x^2*y^2,  y^3]
/**/ coefficients(f);
[8,  12,  6,  1]
/**/ support(f);
[x^6,  x^4*y,  x^2*y^2,  y^3]
/**/ CoeffListWRT(f,x);
[y^3,  0,  6*y^2,  0,  12*y,  0,  8]
\end{Verbatim}



% -- SECTION --------------------------------
\section{Tutorial: defining new functions}
\label{Tutorial: defining new functions}

        
To define a new function in CoCoA use the command ``\verb&define&'' (\ref{define} pg.\pageref{define}).
\par 
When defining a new function you must pick a new name for the function,
and state what arguments/parameters it expects.  The parameters and
variables used inside the function are different from any variables
outside it (even if the names look the same).
\par 
Strictly there is a difference between "functions" and "procedures":
the former always return values, while the latter never return values.
In CoCoA there is hardly any distinction: the only difference is the
use of the ``\verb&return&'' (\ref{return} pg.\pageref{return}) command inside the fn-proc.

\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
  /**/ -- Define new fn "SimpleFn" with just 1 parameter:
  /**/ define SimpleFn(N) return N^2+1; enddefine;
  /**/ SimpleFn(3);
  10

  /**/ define OneStep(N)
  /**/   if IsEven(N) then return N/2;
  /**/   else return 3*N+1;
  /**/   endif;
  /**/ enddefine;
  /**/ OneStep(5);
  16

  /**/ define MaxAbs(X, Y)  -->  2 parameters
  /**/   return max(abs(X), abs(Y));
  /**/ enddefine;
  /**/ MaxAbs(2, -3);
  3

  /**/ -- Next defn is a "procedure" (returns no value)
  /**/ define CheckIsPositive(X)
  /**/   if X <= 0 then println "NOT POSITIVE"; endif
  /**/ enddefine
\end{Verbatim}



% -- SECTION --------------------------------
\section{Tutorial: defining new functions (advanced)}
\label{Tutorial: defining new functions (advanced)}

        
Please read ``Tutorial: defining new functions'' (\ref{Tutorial: defining new functions} pg.\pageref{Tutorial: defining new functions}) before reading this.
\par 
Inside a function it is possible to access variables which were
defined outside it.  The command ``\verb&TopLevel&'' (\ref{TopLevel} pg.\pageref{TopLevel}) will make a global
variable accessible from inside the function, and parameters may be passed
"by reference".
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
  /**/ define negate(ref X) // pass by reference
  /**/   X := -X;           // changes value of variable OUTSIDE the fn
  /**/ enddefine;           // does not "return" a value, so is a procedure!
  /**/ A := 1;
  /**/ negate(ref A);  // use "ref" also to call the fn
  /**/ println A;      // now see that value has changed
  -1

  /**/ define QQx()
  /**/   TopLevel QQ;    // make global variable QQ accessible
  /**/   return NewPolyRing(QQ, "x");
  /**/ enddefine;
  /**/ QQx();
  RingWithID(3, "QQ[x]")  
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Tutorial: defining new functions(\ref{Tutorial: defining new functions} pg.\pageref{Tutorial: defining new functions})

% -- SECTION --------------------------------
\section{Tutorial: homomorphisms}
\label{Tutorial: homomorphisms}

        
CoCoA-5 lets you create ring homomorphisms; these are useful for
various purposes such as "moving" a value from one ring to another.
\par 
A homomorphism from a polynomial ring must state what the images
of the indeterminates are.  If the codomain is also a polynomial
ring with the same ring of coefficients then use ``\verb&PolyAlgebraHom&'' (\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}),
otherwise use ``\verb&PolyRingHom&'' (\ref{PolyRingHom} pg.\pageref{PolyRingHom}) giving also the homomorphism saying
how the coefficient ring is mapped. 
\par 
Some "special" homomorphisms can be created easily via dedicated functions.
If there is a canonical homomorphism between the rings then this
may be specified using ``\verb&CanonicalHom&'' (\ref{CanonicalHom} pg.\pageref{CanonicalHom}).
For the homomorphism which embed the coefficent ring into a polynomial
ring use ``\verb&CoeffEmbeddingHom&'' (\ref{CoeffEmbeddingHom} pg.\pageref{CoeffEmbeddingHom}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ P1 ::= QQ[x,y];   // polys in x,y with coefficients in QQ
/**/ P2 ::= QQ[a,b];   // polys in a,b with coefficients in QQ
/**/ use P2; IndetImages := [a^2, b^3];
/**/ phi := PolyAlgebraHom(P1, P2, IndetImages);
/**/ use P1;
/**/ f := 2*x^2 + 3*y + 4;
/**/ phi(f);
2*a^4 + 3*b^3 + 4
\end{Verbatim}



% -- SECTION --------------------------------
\section{Tutorial: programming and debugging}
\label{Tutorial: programming and debugging}

        
This tutorial is for those who have little experience in
programming and debugging.
\par 
Despite one's best efforts any non-trivial program may easily contain "bugs".
When this happens one must somehow locate the fault,
and then find a way to rectify it.
\par 
The CoCoA interpreter does not offer a special debugger.
\par 
A good guideline is to split your program into smaller pieces,
each of which has a clearly defined purpose which can be described succinctly.
Then these pieces can be tested, and fixed, independently.
Understanding how to split the program becomes easier with more experience.
\par 
Try to find a simple input where your program misbehaves:
this is not always easy, and may require quite some time!
When you have a manageable troublesome input, you should insert
some print commands in your code saying where execution has reached,
and the values of some variables.
For instance:
\begin{verbatim}
  println "Start of function Blah: input A = ", A, " and B = ", B;
  ....
  println "After doing XYZ: poly has degree ", deg(f);
\end{verbatim}
The mistake might in the input, and the program is correct:
double-check that the input really is what you intended!
\par 
It may also happen that the problem lies in CoCoA.
Check carefully the CoCoA manual to see whether the function actually
does what you think it does!
If you are quite sure the problem lies inside CoCoA then see
``Tutorial: feedback and reporting bugs'' (\ref{Tutorial: feedback and reporting bugs} pg.\pageref{Tutorial: feedback and reporting bugs})

\SeeAlso %---- SEE ALSO ----
  Tutorial: feedback and reporting bugs(\ref{Tutorial: feedback and reporting bugs} pg.\pageref{Tutorial: feedback and reporting bugs})

% -- SECTION --------------------------------
\section{Tutorial: feedback and reporting bugs}
\label{Tutorial: feedback and reporting bugs}

        
We try to make CoCoA natural and easy to use, and have everything
properly described in the manual.  However, there is always room
for improvement, and we are happy to receive constructive criticism.
\par 
We try hard to make CoCoA reliable, but some bugs surely slip through
our testing.
So if you find an example where CoCoA goes wrong, let us know.
If you can, try to find a "small" example which triggers the problem.
Send us all the commands we must execute to reproduce the bug, and the
correct output you expected.
Please, also tell us which version of CoCoA you are using
(see ``\verb&VersionInfo&'' (\ref{VersionInfo} pg.\pageref{VersionInfo})), and which operating system your
computer uses (\textit{i.e.} Linux, Mac or Microsoft Windows).
\par 
To give feedback or report a bug send email to the address
``\verb&cocoa@dima.unige.it&'' and we will reply soon.
We also usually put information about bugs and new features into the
"redmine" issue-tracking system, at ``\verb&https://cocoa.dima.unige.it/redmine/&''.

\SeeAlso %---- SEE ALSO ----
  Tutorial: manual(\ref{Tutorial: manual} pg.\pageref{Tutorial: manual})

% -- CHAPTER --------------------------------
\chapter{Introduction to CoCoA Programming}
\label{Introduction to CoCoA Programming}

      

% -- SECTION --------------------------------
\section{An Overview of CoCoA Programming}
\label{An Overview of CoCoA Programming}

        
The CoCoA system includes a full-fledged high level programming
language, CoCoALanguage, complete with loops, branching, scoping of
variables, and input/output control.  The language is used whenever
one issues commands during a CoCoA session.  A sequence of commands
may be stored in a text file and then read into a CoCoA session using
the ``\verb&source&'' (\ref{source} pg.\pageref{source}) command.
\par 
The most important construct in CoCoA programming is the user-defined
function, created with ``\verb&define&'' (\ref{define} pg.\pageref{define}).
A user-defined function can take any number of arguments, of any
types, perform CoCoA commands, and return values.
Collections of these functions can be stored in text files,
as mentioned in the preceding paragraph, or formed into CoCoA
\textbf{packages}, to be made available for general use.
\par 
See ``\verb&All CoCoA commands&'' (\ref{All CoCoA commands} pg.\pageref{All CoCoA commands}).


% -- SECTION --------------------------------
\section{All CoCoA commands}
\label{All CoCoA commands}

        
This is a complete list of all CoCoA commands:

\begin{center}
\begin{longtable}{ll}
   
{\verb~break~} &
      break out of a loop command\\
   
{\verb~ciao~} &
      quit CoCoA\\
   
{\verb~continue~} &
      continue directly with next loop iteration\\
   
{\verb~define~} &
      define a function\\
   
{\verb~describe~} &
      information about an object\\
   
{\verb~exit~} &
      quit CoCoA\\
   
{\verb~for~} &
      loop command\\
   
{\verb~foreach~} &
      loop command\\
   
{\verb~if~} &
      conditional statement\\
   
{\verb~print~} &
      print the value of an expression\\
   
{\verb~print on~} &
      print to an output stream\\
   
{\verb~println~} &
      print the value of an expression\\
   
{\verb~protect~} &
      protect a variable from being overwritten\\
   
{\verb~quit~} &
      quit CoCoA\\
   
{\verb~repeat~} &
      loop command\\
   
{\verb~return~} &
      exit from a function\\
   
{\verb~source~} &
      read commands from a file or device\\
   
{\verb~SourceRegion~} &
      read commands from a region in a file\\
   
{\verb~try~} &
      try command sequence, catch any errors\\
   
{\verb~unprotect~} &
      remove protection from a variable\\
   
{\verb~use~} &
      command for making a ring active\\
   
{\verb~while~} &
      loop command\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{Language Elements}
\label{Language Elements}

      

% -- SECTION --------------------------------
\section{Character Set and Special Symbols}
\label{Character Set and Special Symbols}

        
The CoCoA character set consists of the 26 lower case letters, the 26
upper case letters, the 10 digits and the special characters listed in
the table below.  Note that the special character ``\verb&|&'' looks a bit
different on some keyboards (its ASCII code is 124).
\begin{verbatim}
    ------------------------------------------------------
   |    blank     _  underscore     (  left parenthesis   |
   | +  plus      =  equal          )  right parenthesis  |
   | -  minus     <  less than      [  left bracket       |
   | *  asterisk  <  greater than   [  right bracket      |
   | /  slash     |  vertical bar   '  single quote       |
   | :  colon     .  period         "  "  double quote    |
   | ^  caret     ;  semicolon                            |
   | ,  comma     %  percent                              |
    ------------------------------------------------------
                  Special Characters
\end{verbatim}
The character-groups listed in the table below are special symbols in CoCoA
\begin{verbatim}
    -------------------------------------------------------------
   | :=   assign                      ..   range                 |
   | <<   input from                  //   start line comment    |
   | <>   not equal                   --   start line comment    |
   | ><   Cartesian product           ::=  ring definition       |
   | <=   less than or equal to       /*   start embedded comment|
   | >=   greater than or equal to    */   end embedded comment  |
    -------------------------------------------------------------
                     Special Character-groups
\end{verbatim}


% -- SECTION --------------------------------
\section{Identifiers}
\label{Identifiers}

        
There are two types of identifiers or names.
\par 
  * Identifiers of ring indeterminates (see ``\verb&NewPolyRing&'' (\ref{NewPolyRing} pg.\pageref{NewPolyRing}))
\par 
  * Predefined or user-defined names (functions and CoCoALanguage variables).

\SeeAlso %---- SEE ALSO ----
  Indeterminates(\ref{Indeterminates} pg.\pageref{Indeterminates})

% -- SECTION --------------------------------
\section{Reserved Names}
\label{Reserved Names}

        
***** NOT YET UPDATED TO CoCoA-5: follow with care *****
\par 
The names in the following tables are reserved and cannot be used
otherwise.  The names in the first table are case insensitive
(\textit{e.g.} CLEAR, Clear and ClEaR are all reserved).  The names in the
second table are case sensitive.

\par ...work in progress...

\begin{verbatim}
     ----------------------------------------------------
    | Alias      And      Block       Ciao      Define   |
    | Describe   Do       Elif        Else      End      |
    | EndBlock   EndTry               EndDefine EndFor   |
    | EndForeach EndIf    EndPackage  EndRepeat EndUsing |
    | EndWhile   Eof      False       For       Foreach  |
    | Global     Help     If          In        IsIn     |
    | NewLine    Not      On          Or        Package  |
    | Print      PrintLn  Quit        Repeat    Record   |
    | Return     Set      Skip        Source    Step     |
    | Then       Time     To          True      Unset    |
    | Until      use      Using       Var       While    |
    | QQ         ZZ                                      |
     ----------------------------------------------------
           Case insensitive reserved names

     -------------------------------------------------
    | BOOL      DegLex  DegRevLex  DEVICE  ERROR      |
    | FUNCTION  IDEAL   INT        LIST    Lex        |
    | MAT       MODULE  NULL       Null    PANEL      |
    | POLY      PosTo   RAT        RATFUN  RING       |
    | STRING    TAGGED  ToPos      TYPE    MODULEELEM |
    | Xel       ZMOD                                  |
     -------------------------------------------------
            Case sensitive reserved names
\end{verbatim}
	

% -- SECTION --------------------------------
\section{Comments}
\label{Comments}

        
End-of-line comments in CoCoA start with either ``\verb&--&'' or
``\verb&//&''; all text up to the end of the line is considered comment.
CoCoA also allows embedded comments; these begin with the symbol
``\verb&/*&'' and end with the symbol ``\verb&*/&''.  CoCoA ignores the
contents of a comment, and treats it as if it were just a space.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  // This is an end-of-line comment
/**/  Print 1+1; -- a command followed by an end-of-comment
2
/**/  A := [1 /*x-coord*/, 2 /*y-coord*/ ]; --> embedded comments
\end{Verbatim}

\par 
Writing multi-line comment inside ``\verb&/*&'' and ``\verb&*/&''
is \textbf{strongly} discouraged (even though allowed).


% -- CHAPTER --------------------------------
\chapter{Operators}
\label{Operators}

      

% -- SECTION --------------------------------
\section{CoCoA Operators: introduction}
\label{CoCoA Operators: introduction}

        
In CoCoA there are 5 main types of operators: algebraic
operators, relational operators, boolean operators, selection
operators, and the range operator.
There is also an n-ary operator ``\verb&><&'' for forming
Cartesian products of lists and an operator ``\verb&::=&'' used in
defining rings.
\par 
The meaning of an operator depends on the types of its operands; the ``\verb&+&''
in the expression ``\verb&A + B&'' represents the sum of polynomials, or of
ideals, or of matrices, etc. according to the type of A and B.


















\SeeAlso %---- SEE ALSO ----
  operators, shortcuts(\ref{operators, shortcuts} pg.\pageref{operators, shortcuts})

% -- SECTION --------------------------------
\section{Algebraic Operators}
\label{Algebraic Operators}

        
The algebraic operators are:
\begin{verbatim}
      +  -  *  /  :  ^
\end{verbatim}
The following table shows which operations the system can perform
between two objects of the same or of different types; the first
column lists the type of the first operand and the first row lists the
type of the second operand. So, for example, the symbol ``\verb&:&'' in the box
on the seventh row and fourth column means that it is possible to
divide an ideal by a polynomial.
\begin{verbatim}
          INT    RAT  RINGELEM  MODULEELEM IDEAL MODULE MAT LIST
INT       +-*/^  +-*/   +-*/      *         *     *      *   *
RAT       +-*/^  +-*/   +-*/      *         *     *      *   *
RINGELEM  +-*/^  +-*/   +-*/      *         *     *      *   *
MODULEELEM *     *      *         +-
IDEAL     *^     *      *                   +*:   *
MODULE    *      *      *                   *     +:
MAT       *^     *      *                                +-*
LIST      *      *      *                                    +-

                           Algebraic operators
\end{verbatim}
Remarks:
\par 
  * Let F and G be two polynomials. If F is a multiple of G, then
    F/G is the polynomial obtained from the division of F by G,
    otherwise F/G is a rational function (common factors are
    simplified). The functions ``\verb&div&'' (\ref{div} pg.\pageref{div}) and ``\verb&mod&'' (\ref{mod} pg.\pageref{mod}) can be used to get the
    quotient and the remainder of a polynomial division.
\par 
  * Let $L_1$ and $L_2$ be two lists of the same length. Then $L_1 + L_2$ is
    the list obtained by adding $L_1$ to $L_2$ componentwise.
\par 
  * If I and J are both ideals or both modules, then $I : J$ is the
    ideal consisting of all polynomials f such that fg is in I for all
    g in J.


% -- SECTION --------------------------------
\section{Relational Operators}
\label{Relational Operators}

        

\SeeAlso %---- SEE ALSO ----
  Equality Operator(\ref{Equality Operator} pg.\pageref{Equality Operator}), 
    Order Comparison Operators(\ref{Order Comparison Operators} pg.\pageref{Order Comparison Operators}), 
    IsIn(\ref{IsIn} pg.\pageref{IsIn})

% -- SECTION --------------------------------
\section{Selection Operators}
\label{Selection Operators}

        
The selection operators are
\begin{verbatim}
      []    .
\end{verbatim}
Let N be of type INT and let L be of type STRING, MODULEELEM, LIST, or
MAT.  Then the meaning of L[N] depends on the type of L as explained
in the following table:
\begin{verbatim}
    ------------------------------------------------------------
   |  Type of L    Meaning of L[N]                              |
    ------------------------------------------------------------
   | STRING       string consisting of the N-th character of L. |
   | MODULEELEM   N-th component of L                           |
   | LIST         N-th element of L                             |
   | MAT          N-th element of L                             |
    ------------------------------------------------------------
                   Selection Operator
\end{verbatim}
If N is an identifier and L is of type RECORD, then ``\verb&L.N&'' indicates the
object contained in the field N of the record L (see ``record'' (\ref{record} pg.\pageref{record})).
	
\SeeAlso %---- SEE ALSO ----
  record(\ref{record} pg.\pageref{record}), 
    List Constructors(\ref{List Constructors} pg.\pageref{List Constructors})

% -- SECTION --------------------------------
\section{Range Operator}
\label{Range Operator}

        
If ``\verb&M&'' and ``\verb&N&'' are of type INT, then the expression:  ``\verb&M .. N&'' returns
\par 
      * the list ``\verb&[M, M+1, ... , N]&'' if $M \le  N;$
\par 
      * the empty list, ``\verb&[]&'', otherwise.
\par 
NOTE: see example for how to select a sub-range of a list
\par 
NOTE: CoCoA does not allow ``\verb&N..M&'' to produce lists longer than $10^7$ values.
\par 
If ``\verb&x&'' and ``\verb&y&'' are indeterminates in a ring, then ``\verb&x .. y&''
gives the indeterminates between ``\verb&x&'' and ``\verb&y&'' in the order they appear
in the definition of the ring.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  1..10;
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

/**/  use R ::= QQ[x,y,z,a,b,c,d];
/**/  z..c;
[z, a, b, c]

/**/ L := [11, 22, 33, 44, 55];
/**/ PartOfL := L[2]..L[4];  --> probably *NOT* what you want!
/**/ PartOfL := [ L[k] | k in 2..4 ]; --> OK, this is RIGHT!
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CoCoA Operators: introduction(\ref{CoCoA Operators: introduction} pg.\pageref{CoCoA Operators: introduction}), 
    List Constructors(\ref{List Constructors} pg.\pageref{List Constructors}), 
    LIST(\ref{LIST} pg.\pageref{LIST})

% -- CHAPTER --------------------------------
\chapter{Evaluation and Assignment}
\label{Evaluation and Assignment}

      

% -- SECTION --------------------------------
\section{Evaluation}
\label{Evaluation}

        
An expression is by itself a valid command. The effect of this
command is that the expression is evaluated in the current ring and
its value is displayed.
\par 
The evaluation of an expression in CoCoA is normally performed in a
full recursive evaluation mode.
Usually the result is the fully evaluated expression.
\par 
The result of the evaluation is automatically stored in the variable
``\verb&It&'' (\ref{It} pg.\pageref{It}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  2 + 2;
4
/**/  It + 3;
7
/**/  It;
7
/**/  X := 5;
/**/  It;
7
\end{Verbatim}

The command ``\verb&X := 5&'' is an assignment, not an evaluation; so it does
not change the value of the variable ``\verb&It&'' (\ref{It} pg.\pageref{It}).
\par 
If an error occurs during the evaluation of an expression, then the
evaluation is interrupted and the user is notified about the error.


% -- SECTION --------------------------------
\section{Assignment}
\label{Assignment}

        
An assignment command has the form
\begin{verbatim}
  L := E
\end{verbatim}
where ``\verb&L&'' is a variable and ``\verb&E&'' is an expression.
The assignment command binds the result of the evaluation of the
expression ``\verb&E&'' to ``\verb&L&'' in the working memory.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  M := 5;  N := 8;
/**/  T := M+N;
/**/  println T;
13
/**/  T := T+1;  -- evaluate RHS first, then assign value to T
/**/  println T;
14

/**/  L := [1,2,3];
/**/  L[2] := 0; -- assign to an entry in a list
/**/  println L;
[1, 0, 3]

/**/  use QQ[x,y,z];
/**/  P := record[F := x*z];
/**/  P.Degree := deg(P.F); -- assign to a field in a record
/**/  P;
record[Degree := 2, F := x*z]
\end{Verbatim}



% -- CHAPTER --------------------------------
\chapter{Flow Control: Conditional Statements and Loops}
\label{Flow Control: Conditional Statements and Loops}

      

% -- SECTION --------------------------------
\section{Commands and Functions for Branching}
\label{Commands and Functions for Branching}

        
The following are the CoCoA commands for constructing conditional
statements:

\begin{center}
\begin{longtable}{ll}
   
{\verb~if~} &
      conditional statement\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions for Loops}
\label{Commands and Functions for Loops}

        
The following are the commands and functions for loops:

\begin{center}
\begin{longtable}{ll}
   
{\verb~break~} &
      break out of a loop command\\
   
{\verb~continue~} &
      continue directly with next loop iteration\\
   
{\verb~for~} &
      loop command\\
   
{\verb~foreach~} &
      loop command\\
   
{\verb~repeat~} &
      loop command\\
   
{\verb~return~} &
      exit from a function\\
   
{\verb~while~} &
      loop command\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{Verbosity and interrupt}
\label{Verbosity and interrupt}

      

% -- SECTION --------------------------------
\section{Introduction to verbosity and interrupt}
\label{Introduction to verbosity and interrupt}

        
Various functions defined in CoCoALib and in the CoCoA packages print
out some internal progress when the global ``\verb&VerbosityLevel&'' (\ref{VerbosityLevel} pg.\pageref{VerbosityLevel})
is higher than some value (see their specific manual for the values,
anyway not less than 10).  See also ``\verb&SetVerbosityLevel&'' (\ref{SetVerbosityLevel} pg.\pageref{SetVerbosityLevel}).
\par 
A computation which appears to take too long may be interrupted by
typing ``\verb&C-c&'' (control-c), or, in Emacs, ``\verb&C-c C-c&''.
The state of the memory after an interrupt is as it was before calling
the interrupted function, thanks to the exception-safe design of CoCoALib.


% -- SECTION --------------------------------
\section{Commands and Functions implementing Verbosity}
\label{Commands and Functions implementing Verbosity}

        
The following are the commands and functions implementing verbosity:

\begin{center}
\begin{longtable}{ll}
   
{\verb~ApproxPointsNBM~} &
      Numerical Border Basis of ideal of points\\
   
{\verb~ApproxSolve~} &
      Approximate real solutions for polynomial system\\
   
{\verb~CallOnGroebnerFanIdeals~} &
      apply a function to Groebner fan ideals\\
   
{\verb~GBasis~} &
      calculate a Groebner basis\\
   
{\verb~GBasisByHomog~} &
      calculate a Groebner basis by homogenization\\
   
{\verb~gin~} &
      generic initial ideal\\
   
{\verb~GroebnerFanIdeals~} &
      all reduced Groebner bases of an ideal\\
   
{\verb~ImplicitHypersurface~} &
      implicitization of hypersurface\\
   
{\verb~interreduce~} &
      interreduce a list of polynomials\\
   
{\verb~interreduced~} &
      interreduce a list of polynomials\\
   
{\verb~MinPolyQuot~} &
      minimal polynomial in quotient ring\\
   
{\verb~rgin~} &
      generic initial ideal wrt StdDegRevLex\\
   
{\verb~SetVerbosityLevel~} &
      set the verbosity level\\
   
{\verb~UniversalGBasis~} &
      universal Groebner basis of the input ideal\\
   
{\verb~VerbosityLevel~} &
      verbosity level\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions implementing interruption}
\label{Commands and Functions implementing interruption}

        
All functions implemented in CoCoA language,
\textit{i.e.} all user-defined functions and those defined in packages,
are interruptible.
\par 
Moreover the following CoCoALib functions are interruptible:

\begin{center}
\begin{longtable}{ll}
   
{\verb~GBasis~} &
      calculate a Groebner basis\\
   
{\verb~GBasisByHomog~} &
      calculate a Groebner basis by homogenization\\
   
{\verb~ImplicitHypersurface~} &
      implicitization of hypersurface\\
   
{\verb~MinPolyQuot~} &
      minimal polynomial in quotient ring\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{Input/Output}
\label{Input/Output}

      

% -- SECTION --------------------------------
\section{Introduction to IO}
\label{Introduction to IO}

        
***** NOT YET UPDATED TO CoCoA-5: follow with care *****
\par 
Input and output is implemented in CoCoA through the use of
\textbf{devices}.  At present, the official devices are: (1) standard IO (the
CoCoA window), (2) text files, and (3) strings.  What this means is that
it is possible to read from or write to any of these places.  The
cases are discussed separately, below.  Text files may be read
verbatim or---with the ``\verb&source&'' (\ref{source} pg.\pageref{source}) command---be executed as CoCoA
commands.


% -- SECTION --------------------------------
\section{Standard IO}
\label{Standard IO}

        
***** NOT YET UPDATED TO CoCoA-5: follow with care *****
\par 
Standard IO is what takes places normally when one interacts with
CoCoA.
CoCoA accepts and interprets strings typed in by the user and prints
out expressions.  If E is a CoCoA object, then the command
\begin{verbatim}
    E;
\end{verbatim}
causes the value of E to be printed to the CoCoA window.  One may also
use the functions ``\verb&print&'' (\ref{print} pg.\pageref{print}) and ``\verb&println&'' (\ref{println} pg.\pageref{println}) for more control over the
format of the output.
\par 
The official devices that are being used here are ``\verb&DEV.STDIN&'' and
``\verb&DEV.OUT&''. So for instance, the commands ``\verb&GetLine&'' (\ref{GetLine} pg.\pageref{GetLine}) and ``\verb&print on&'' (\ref{print on} pg.\pageref{print on}) can be
used with the standard devices although they are really meant to be
used with the other devices.  ``\verb&Print E On DEV.OUT&'' is synonymous with
``\verb&Print E&''.  Also, one may use ``\verb&Get(DEV.STDIN,10)&'', for example, to get
the next 10 characters typed in the CoCoA window.  Thus, clever use of
``\verb&GetLine&'' (\ref{GetLine} pg.\pageref{GetLine}) will allow your user-defined functions to prompt the user for
input, but normal practice is to pass variables to a function as
arguments to that function.


% -- SECTION --------------------------------
\section{File IO}
\label{File IO}

        
***** NOT YET UPDATED TO CoCoA-5: follow with care *****
\par 
To print CoCoA output to a file, one first opens the file
with ``\verb&OpenOFile&'' (\ref{OpenOFile} pg.\pageref{OpenOFile}) then prints to the file using ``\verb&print on&'' (\ref{print on} pg.\pageref{print on}).
\par 
To receive verbatim input from a file, one first opens the file with
``\verb&OpenIFile&'' (\ref{OpenIFile} pg.\pageref{OpenIFile}), then reads lines from the file with ``\verb&GetLine&'' (\ref{GetLine} pg.\pageref{GetLine}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  D := OpenOFile("my-file"); -- open text file with name "my-file",
/**/                             -- creating it if necessary
/**/  Print "hello world" On D; -- append "hello world" to my-file
/**/  Close(D); -- close the file
/**/  D := OpenIFile("my-file"); -- open "my-file"
/**/  GetLine(D);
hello world
/**/  Close(D);
\end{Verbatim}

To read and execute a sequence of CoCoA commands from a text file, one
uses the ``\verb&source&'' (\ref{source} pg.\pageref{source}) command.  For instance, if the
file ``\verb&MyFile.coc&'' contains a list of CoCoA commands, then
\begin{verbatim}
  Source "MyFile.cocoa";
\end{verbatim}
reads and executes the commands.

\SeeAlso %---- SEE ALSO ----
  ascii(\ref{ascii} pg.\pageref{ascii}), 
    close(\ref{close} pg.\pageref{close}), 
    GetLine(\ref{GetLine} pg.\pageref{GetLine}), 
    OpenIFile(\ref{OpenIFile} pg.\pageref{OpenIFile}), 
    OpenOFile(\ref{OpenOFile} pg.\pageref{OpenOFile}), 
    OpenLog(\ref{OpenLog} pg.\pageref{OpenLog}), 
    CloseLog(\ref{CloseLog} pg.\pageref{CloseLog}), 
    print on(\ref{print on} pg.\pageref{print on}), 
    source(\ref{source} pg.\pageref{source})

% -- SECTION --------------------------------
\section{String IO}
\label{String IO}

        
***** NOT YET UPDATED TO CoCoA-5: follow with care *****
\par 
To print CoCoA output to a string, on may use ``\verb&OpenOString&'' (\ref{OpenOString} pg.\pageref{OpenOString}) to
\textbf{open} the string, then ``\verb&print on&'' (\ref{print on} pg.\pageref{print on}) to write to it.  To read from a
string, one may open the string for input with ``\verb&OpenIString&'' (\ref{OpenIString} pg.\pageref{OpenIString}) then read
substrings from it with ``\verb&GetLine&'' (\ref{GetLine} pg.\pageref{GetLine}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  S := "hello world!\ngoodbye world!";
/**/  D := OpenIString(S);  -- open the string S for input to CoCoA
/**/  line := GetLine(D);  -- read 1st line from the string
/**/  line;
hello world!
/**/  Close(D);  -- close device D
\end{Verbatim}

There are usually more direct ways to collect results in strings.  For
instance, if the output of a CoCoA command is not already of type
``\verb&STRING&'', one may convert it to a string using ``\verb&sprint&'' (\ref{sprint} pg.\pageref{sprint}).


% -- SECTION --------------------------------
\section{Commands and Functions for IO}
\label{Commands and Functions for IO}

        
The following are commands and functions for input/output:

\begin{center}
\begin{longtable}{ll}
   
{\verb~block~} &
      group several commands into a single command\\
   
{\verb~close~} &
      close an output stream\\
   
{\verb~CloseLog~} &
      close a log of a CoCoA session\\
   
{\verb~format~} &
      convert object to formatted string\\
   
{\verb~GetLine~} &
      read a line of input from an in-stream\\
   
{\verb~latex~} &
      LaTeX formatting\\
   
{\verb~NewFreeModule~} &
      create a new FreeModule\\
   
{\verb~NewLine [OBSOLESCENT]~} &
      [OBSOLESCENT] string containing a newline\\
   
{\verb~OpenIFile~} &
      open input file\\
   
{\verb~OpenIString~} &
      open input string\\
   
{\verb~OpenLog~} &
      open a log of a CoCoA session\\
   
{\verb~OpenOFile~} &
      open output file\\
   
{\verb~OpenOString~} &
      open output string\\
   
{\verb~OpenSocket~} &
      open a socket connection\\
   
{\verb~print~} &
      print the value of an expression\\
   
{\verb~print on~} &
      print to an output stream\\
   
{\verb~println~} &
      print the value of an expression\\
   
{\verb~source~} &
      read commands from a file or device\\
   
{\verb~SourceRegion~} &
      read commands from a region in a file\\
   
{\verb~sprint~} &
      convert to a string\\
   
{\verb~SprintTrunc~} &
      convert to a string and truncate\\
   
{\verb~tag~} &
      returns the tag string of an object\\
   
{\verb~tagged~} &
      tag an object for pretty printing\\
   
{\verb~untagged~} &
      untag an object\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{CoCoA Packages}
\label{CoCoA Packages}

      

% -- SECTION --------------------------------
\section{Introduction to Packages}
\label{Introduction to Packages}

        
User-defined functions may be saved in separate files and read into a
CoCoA session using the ``\verb&source&'' (\ref{source} pg.\pageref{source}) command.
If one sources several such files or, especially, if a file is to be
made available for general use, a possible problem arises from
conflicting function names.
If two functions with the same name are read into a CoCoA session, only
the one last read survives.
To avoid this, functions may be collected in \textbf{packages}.
\par 
A CoCoA package is essentially a list of functions labeled with prefix.
\par 
Writing a package in CoCoA-5 is easier than in CoCoA-4.

\SeeAlso %---- SEE ALSO ----
  define(\ref{define} pg.\pageref{define}), 
    source(\ref{source} pg.\pageref{source})

% -- SECTION --------------------------------
\section{First Example of a Package}
\label{First Example of a Package}

        
The following is an example of a package.  It could be typed into a
window as-is during a CoCoA session, but we will assume that it is
stored in a file in the CoCoA directory under the name ``\verb&one.cpkg5&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
package $contrib/toypackage

export ToyTest;

define IsNumberOne(n)
  if n = 1 then return true; else return false; endif;
enddefine;

define ToyTest(n)
  if IsNumberOne(n) then
    print "The number 1";
  else
    print "Not the number 1";
  endif;
enddefine;

endpackage; -- of toypackage
\end{Verbatim}


Below is output from a CoCoA session in which this package was used:
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
-- read in the package:
Source "one.cpkg";
/**/ ToyTest(4);  -- was exported
Not the number 1
-- /**/ IsNumberOne(4);  -- !!! ERROR !!! as expected: fn was not exported

/**/ $contrib/toypackage.IsNumberOne(4);
false
\end{Verbatim}



% -- SECTION --------------------------------
\section{Package essentials}
\label{Package essentials}

        
A package begins with
\begin{verbatim}
  Package $PackageName
\end{verbatim}
and ends with
\begin{verbatim}
  EndPackage;
\end{verbatim}
``\verb&PackageName&'' is a string that will be used to identify the package.
The dollar sign is required.  The ``\verb&PackageName&'' must be a valid
identifier: \textit{i.e.} start with a letter and comprise only letters,
digits, slash and underscore; the name should be meaningful (and
usually long, to avoid any risk of a name clash).  We recommend using
a name of the form ``\verb&contrib/subject&''.
\par 
All packages in the CoCoA directory ``\verb&packages&'' are
automatically loaded when starting CoCoA.


% -- SECTION --------------------------------
\section{Global Aliases}
\label{Global Aliases}

        
A global alias for a package is formed by using the command ``\verb&alias&'' (\ref{alias} pg.\pageref{alias})
during a CoCoA session.
NOTE: global aliases cannot be used in function definitions.
This is to force independence of context.
Inside a function, one must use the complete package name.

\SeeAlso %---- SEE ALSO ----
  alias(\ref{alias} pg.\pageref{alias}), 
    aliases(\ref{aliases} pg.\pageref{aliases})

% -- SECTION --------------------------------
\section{Sharing Your Package}
\label{Sharing Your Package}

        
If you create a package that others might find useful, please contact
the CoCoA team by email at ``\verb&cocoa at dima.unige.it&''.
\par 
Include comments in the package that:
\par 
  * explain the use of the package
\par 
  * give the syntax, description, examples for exported functions.


% -- SECTION --------------------------------
\section{Commands and Functions for Packages}
\label{Commands and Functions for Packages}

        
The following are commands and functions for packages:

\begin{center}
\begin{longtable}{ll}
   
{\verb~alias~} &
      define aliases for package names\\
   
{\verb~aliases~} &
      list of global aliases\\
   
{\verb~package~} &
      keyword marking content of a CoCoA package\\
   
{\verb~PackageOf~} &
      package of an identifier\\
   
{\verb~packages~} &
      list of loaded packages\\
   
{\verb~PkgName~} &
      returns the name of a package\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Supported Packages}
\label{Supported Packages}

        
Several packages are supported by the CoCoA team.  These packages
contain functions that are not built into CoCoA because they are of a
more specialized or experimental nature.
\par 
Some functions which used to be defined in supported packages are now
official functions in CoCoA-5.


% -- SECTION --------------------------------
\section{Galois Package}
\label{Galois Package}

        
***** NOT YET UPDATED TO CoCoA-5: follow with care *****
\par 
\begin{verbatim}
TITLE       : galois.cpkg
DESCRIPTION : CoCoA package for computing in a cyclic algebraic
              extension
AUTHOR      : A. Bigatti, D.La Macchia, F.Rossi

-- Enter
       $contrib/galois.Man();
   to get a complete description of the package including a suggested alias.
\end{verbatim}


% -- SECTION --------------------------------
\section{Integer Programming}
\label{Integer Programming}

        
***** NOT YET UPDATED TO CoCoA-5: follow with care *****
\par 
\begin{verbatim}
TITLE       : intprog.cpkg
DESCRIPTION : CoCoA package for applying toric ideals to integer
              programming
AUTHOR      : A. Bigatti

-- Enter
       $contrib/intprog.Man();
   to get a complete description of the package including a suggested alias.
\end{verbatim}


% -- SECTION --------------------------------
\section{Algebra of Invariants}
\label{Algebra of Invariants}

        
***** NOT YET UPDATED TO CoCoA-5: follow with care *****
\par 
\begin{verbatim}
TITLE       : invariants.cpkg
DESCRIPTION : CoCoA package for computing homogeneous generators of an
              algebra of invariants, and for testing invariance of a polynomial
AUTHOR      : A. Del Padrone

-- Enter
       $contrib/invariants.Man();
   to get a complete description of the package including a suggested alias.
\end{verbatim}


% -- SECTION --------------------------------
\section{Special Varieties}
\label{Special Varieties}

        
***** NOT YET UPDATED TO CoCoA-5: follow with care *****
\par 
\begin{verbatim}
TITLE       : specvar.cpkg
DESCRIPTION : CoCoA package for computing the Hilbert-Poincare
              series of special varieties (Segre, Veronese, Rees).
AUTHORS     : A. Bigatti, L. Robbiano

-- Enter
       $contrib/specvar.Man();
   to get a complete description of the package including a suggested alias.
\end{verbatim}


% -- SECTION --------------------------------
\section{Statistics}
\label{Statistics}

        
***** NOT YET UPDATED TO CoCoA-5: follow with care *****
\par 
\begin{verbatim}
TITLE       : stat.cpkg
DESCRIPTION : package for design of experiments in statistics
AUTHOR      : M. Caboara

-- Enter
       $contrib/stat.Man();
   to get a complete description of the package including a suggested alias.
\end{verbatim}


% -- SECTION --------------------------------
\section{Geometrical Theorem-Proving [PROTOTYPE]}
\label{Geometrical Theorem-Proving [PROTOTYPE]}

        
\textbf{This is just a prototype:} exact semantics, and interface are likely to change!
\begin{verbatim}
TITLE       : thmproving.cpkg
DESCRIPTION : CoCoA package for geometrical theorem-proving in euclidean space
AUTHOR      : L. Bazzotti, G. Dalzotto

ThmMan();
\end{verbatim}


% -- SECTION --------------------------------
\section{Conductor}
\label{Conductor}

        
***** NOT YET UPDATED TO CoCoA-5: follow with care *****
\par 
\begin{verbatim}
TITLE       : conductor.cpkg
DESCRIPTION : CoCoA package for computing conductor sequence of points
AUTHOR      : L.Bazzotti

-- Enter
       $contrib/conductor.Man();
   to get a complete description of the package including a suggested alias.
\end{verbatim}


% -- SECTION --------------------------------
\section{Matrix Normal Form}
\label{Matrix Normal Form}

        
***** NOT YET UPDATED TO CoCoA-5: follow with care *****
\par 
\begin{verbatim}
TITLE       : matrixnormalform.cpkg
DESCRIPTION : CoCoA package for computing normal forms of a matrix,
              Smith Normal Form (PID)
AUTHOR      : A.Bigatti, S.DeFrancisci

-- Enter
       $contrib/matrixnormalform.Man();
   to get a complete description of the package including a suggested alias.
\end{verbatim}


% -- SECTION --------------------------------
\section{Control}
\label{Control}

        
***** NOT YET UPDATED TO CoCoA-5: follow with care *****
\par 
\begin{verbatim}
TITLE       : control.cpkg
DESCRIPTION : CoCoA package for Geometric Control Theory
AUTHOR      : M. Anderlucci and M. Caboara

-- Enter
       $contrib/control.Man();
   to get a complete description of the package including a suggested alias.
\end{verbatim}


% -- CHAPTER --------------------------------
\chapter{Linked libraries}
\label{Linked libraries}

      

% -- SECTION --------------------------------
\section{CoCoALib}
\label{CoCoALib}

        
CoCoALib ``\verb&http://cocoa.dima.unige.it/cocoalib&''.
\par 
CoCoALib is the mathematical core of CoCoA-5.
It may be used directly as a C++ library.


% -- SECTION --------------------------------
\section{GMP}
\label{GMP}

        
GMP - The GNU Multiple Precision Arithmetic Library
``\verb&https://gmplib.org&''
\par 
All arbitrary precision integer/rational/floating-point datatypes and
operations are based on GMP.


% -- SECTION --------------------------------
\section{GSL}
\label{GSL}

        
GSL - GNU Scientific Library
``\verb&http://www.gnu.org/software/gsl/&''
\par 
Some functions from GSL have been ported to CoCoA-5.
There is no manual yet because it is still work in progress.


% -- SECTION --------------------------------
\section{Frobby}
\label{Frobby}

        
Frobby - Computations With Monomial Ideals
``\verb&http://www.broune.com/frobby&''
\par 
All functions starting with ``\verb&Frb&'' are implemented in Frobby.


% -- SECTION --------------------------------
\section{MathSAT}
\label{MathSAT}

        
MathSAT - Satisfiability modulo theories (SMT) solver
``\verb&http://mathsat.fbk.eu/&''
\par 
All functions starting with ``\verb&MSAT&'' are implemented in MathSAT.


% -- SECTION --------------------------------
\section{Normaliz}
\label{Normaliz}

        
libNormaliz is a C++ library for computations with rational cones and affine
monoids; full details may be found on the official Normaliz website
``\verb&https://www.normaliz.uni-osnabrueck.de&''
\par 
When CoCoA is compiled it is possible to incorporate also libNormaliz;
if so, then many libNormaliz functions can be called from CoCoA-5.
All CoCoA functions starting with ``\verb&Nmz&'' are actually implemented
in libNormaliz.


% -- CHAPTER --------------------------------
\chapter{Migrating from CoCoA-4 and keeping up-to-date}
\label{Migrating from CoCoA-4 and keeping up-to-date}

      

% -- SECTION --------------------------------
\section{Changes in the CoCoA language}
\label{Changes in the CoCoA language}

        
CoCoA-5 is largely, but not completely, backward-compatible with CoCoA-4.
Some commands/functions have changed name; others have been removed or
replaced.  Here we give a little guidance to help update your CoCoA-4
programs to CoCoA-5.
\par 
The operator ``\verb&Not&'' has been replaced by the function ``\verb&not(...)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/*C4*/ If Not X IsIn L Then ... EndIf;
/*C5*/ If not(X IsIn L) Then ... EndIf;
\end{Verbatim}

Several functions modify one of their arguments (\textit{e.g.} ``\verb&append&'' (\ref{append} pg.\pageref{append}),
``\verb&sort&'' (\ref{sort} pg.\pageref{sort})); CoCoA-5 wants these arguments to be identified with the new
keyword ``\verb&ref&'' (\ref{ref} pg.\pageref{ref}), and will issue a warning if you do not do this
(just to make sure you know that ``\verb&L&'' will be modified).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/*C4*/ L := [1,2,3];  Append(L, 4);
/*C5*/ L := [1,2,3];  append(ref L, 4);
\end{Verbatim}

Implicit multiplication has gone: either write ``\verb&x*y&'' instead of ``\verb&xy&''
for every product, or use ``\verb&CoCoA-4 mode&'' (\ref{CoCoA-4 mode} pg.\pageref{CoCoA-4 mode}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/*C4*/ F := 3xyzt;
/*C5*/ F := 3*x*y*z*t;  OR  F := ***3xyzt***;
\end{Verbatim}

Many CoCoA-4 functions would employ the ``\verb&CurrentRing&'' implicitly (\textit{e.g.}
``\verb&NumIndets()&'', ``\verb&CoeffRing()&'').  They now require an explicit argument;
you can pass ``\verb&CurrentRing&'' as the argument, but inside a function you must
make that system variable visible via the command ``\verb&TopLevel&'' (\ref{TopLevel} pg.\pageref{TopLevel}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/*C4*/ Define LastIndet() Return Last(Indets()); EndDefine;
/*C5*/ Define LastIndet()
         TopLevel CurrentRing;
         Return last(indets(CurrentRing));
       EndDefine;
\end{Verbatim}

However, we encourage you to consider modifying your function so that
it does not depend on ``\verb&CurrentRing&''; \textit{e.g.} you can find
out to which ring a value belongs by calling the function ``\verb&RingOf&'' (\ref{RingOf} pg.\pageref{RingOf}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/*C5*/ I := ideal(x,y^2);  NumIndets(RingOf(I));
\end{Verbatim}

The function ``\verb&LinKer&'' (\ref{LinKer} pg.\pageref{LinKer}) has been replaced by ``\verb&LinKerBasis&'' (\ref{LinKerBasis} pg.\pageref{LinKerBasis}),
and there is a new function called ``\verb&LinKer&'' (\ref{LinKer} pg.\pageref{LinKer}) which produces a matrix.
\par 
More generally, see also the CoCoA-4 "translation table" in the
CoCoAManual directory or at the URL
\begin{verbatim}
  http://cocoa.dima.unige.it/cocoalib/doc/CoCoATranslationTable.html
\end{verbatim}

\SeeAlso %---- SEE ALSO ----
  CoCoA-4 mode(\ref{CoCoA-4 mode} pg.\pageref{CoCoA-4 mode}), 
    TopLevel(\ref{TopLevel} pg.\pageref{TopLevel}), 
    CurrentRing(\ref{CurrentRing} pg.\pageref{CurrentRing}), 
    RingOf(\ref{RingOf} pg.\pageref{RingOf})

% -- SECTION --------------------------------
\section{Recent changes in the CoCoA-5 language}
\label{Recent changes in the CoCoA-5 language}

        
There are a few changes in the language even from the first versions
of CoCoA-5.
\par 
The operator ``\verb&Not&'' has been replaced by the function ``\verb&not(...)&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/*5.0.9*/ If Not X IsIn L Then ... EndIf;
/*5.1.0*/ If not(X IsIn L) Then ... EndIf;
\end{Verbatim}

The anonymous function called ``\verb&lambda&'' is now called ``\verb&func&'' (\ref{func} pg.\pageref{func}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/*5.0.9*/  square := Lambda(x) Return x^2; EndLambda;
/*5.1.0*/  square := Func(x) Return x^2; EndFunc;
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  not(\ref{not} pg.\pageref{not}), 
    func(\ref{func} pg.\pageref{func})

% -- SECTION --------------------------------
\section{Obsolete and obsolescent functions}
\label{Obsolete and obsolescent functions}

        
As the language evolves some functions might become obsolete, maybe
just more sensibly renamed.  This is the list of such functions: see
in the manual for reasons/updates.

\begin{center}
\begin{longtable}{ll}
    
{\verb~AllReducedGroebnerBases [OBSOLETE]~} &
      [OBSOLETE] Renamed GroebnerFanIdeals\\
   
{\verb~Call [OBSOLETE]~} &
      [OBSOLETE] apply a function to given arguments\\
   
{\verb~Cast [OBSOLETE]~} &
      [OBSOLETE] type conversion\\
   
{\verb~ColumnVectors [OBSOLETE]~} &
      [OBSOLETE] list of module elements\\
   
{\verb~Comp [OBSOLETE]~} &
      [OBSOLETE] access a component\\
   
{\verb~CompleteToOrd [OBSOLETE]~} &
      [OBSOLETE] renamed MakeTermOrdMat\\
   
{\verb~E_ [OBSOLETE]~} &
      [OBSOLETE] vectors of the canonical basis\\
   
{\verb~Function [OBSOLETE]~} &
      [OBSOLETE]\\
   
{\verb~functions [OBSOLETE]~} &
      [OBSOLETE] replaced by describe\\
   
{\verb~Get [OBSOLETE]~} &
      [OBSOLETE] replaced by GetLine\\
   
{\verb~ID [OBSOLETE]~} &
      [OBSOLETE] renamed RingID\\
   
{\verb~IsInSubalgebra [OBSOLETE]~} &
      [OBSOLETE] check if one polynomial is in a subalgebra\\
   
{\verb~IsNumber [OBSOLETE]~} &
      [OBSOLETE] checks if the argument is a number\\
   
{\verb~isqrt [OBSOLETE]~} &
      [OBSOLETE] renamed FloorSqrt\\
   
{\verb~LinKerModP [OBSOLETE]~} &
      [OBSOLETE] find the kernel of a matrix mod p\\
   
{\verb~LinSol [OBSOLETE]~} &
      [OBSOLETE] renamed LinSolve\\
   
{\verb~MapDown [OBSOLETE]~} &
      [OBSOLETE] convert a constant polynomial to a number\\
   
{\verb~Mod2Rat [OBSOLETE]~} &
      [OBSOLETE] reconstruct rationals from modular integers\\
   
{\verb~NewId [OBSOLETE]~} &
      [OBSOLETE] create a new identifier\\
   
{\verb~NFsAreZero [OBSOLETE]~} &
      [OBSOLETE]test if normal forms are zero\\
   
{\verb~Option [OBSOLETE]~} &
      [OBSOLETE] status of a panel option\\
   
{\verb~panel [OBSOLETE]~} &
      [OBSOLETE] print status of a panel's options\\
   
{\verb~panels [OBSOLETE]~} &
      [OBSOLETE] list of CoCoA panels\\
   
{\verb~PoincareMultiDeg [OBSOLETE]~} &
      [OBSOLETE] Renamed HilbertSeriesMultiDeg\\
   
{\verb~PoincareShifts [OBSOLETE]~} &
      [OBSOLETE] Renamed HilbertSeriesShifts\\
   
{\verb~PrimaryDecomposition0 [OBSOLETE]~} &
      [OBSOLETE]\\
   
{\verb~randomize [OBSOLETE]~} &
      [OBSOLETE] randomize the coefficients of a given polynomial\\
   
{\verb~randomized [OBSOLETE]~} &
      [OBSOLETE] randomize the coefficients of a given polynomial\\
   
{\verb~RefineGCDFreeBasis [OBSOLETE]~} &
      refine an integer GCD free basis\\
   
{\verb~Reset [OBSOLETE]~} &
      [OBSOLETE] reset panels and random number seed to defaults\\
   
{\verb~ResetPanels [OBSOLETE]~} &
      [OBSOLETE] reset panels to their default values\\
   
{\verb~RingEnv [OBSOLETE]~} &
      [OBSOLETE] name of the ring environment\\
   
{\verb~RingSet [OBSOLETE]~} &
      [OBSOLETE] renamed RingsOf\\
   
{\verb~seed [OBSOLETE]~} &
      [OBSOLETE] replaced by reseed\\
   
{\verb~size [OBSOLETE]~} &
      [OBSOLETE]\\
   
{\verb~SubalgebraMap [OBSOLETE]~} &
      [OBSOLETE] algebra homomorphism representing a subalgebra\\
   
{\verb~TmpNBM [OBSOLETE]~} &
      [OBSOLETE] renamed ApproxPointsNBM\\
   
{\verb~Unset [OBSOLETE]~} &
      [OBSOLETE] set and unset panel options\\
   
{\verb~valuation [OBSOLETE]~} &
      [OBSOLETE]\\
   
{\verb~WLog [OBSOLETE]~} &
      [OBSOLETE]\\
   
\end{longtable}
\end{center}
\noindent


Some functions are obsolescent, that means that they are still usable
but will be deleted in some future version of CoCoA (leaving some time
to adapt to the replacing function).

\begin{center}
\begin{longtable}{ll}
    
{\verb~AffHilbert [OBSOLESCENT]~} &
      [OBSOLESCENT] renamed AffHilbertFn\\
   
{\verb~AffPoincare [OBSOLESCENT]~} &
      [OBSOLESCENT] Renamed AffHilbertSeries\\
   
{\verb~apply [OBSOLESCENT]~} &
      apply [OBSOLESCENT]\\
   
{\verb~ArrDerMod [OBSOLESCENT]~} &
      [OBSOLESCENT] renamed ArrDerModule\\
   
{\verb~FactorAlgExt [OBSOLESCENT]~} &
      [OBSOLESCENT] factorization over algebraic extensions\\
   
{\verb~hilbert [OBSOLESCENT]~} &
      [OBSOLESCENT] renamed HilbertFn\\
   
{\verb~HomogElimMat [OBSOLESCENT]~} &
      [OBSOLESCENT] renamed ElimHomogMat\\
   
{\verb~image [OBSOLESCENT]~} &
      [OBSOLESCENT] apply ring homomorphism\\
   
{\verb~insert [OBSOLESCENT]~} &
      [OBSOLESCENT] insert an object in a list\\
   
{\verb~log [OBSOLESCENT]~} &
      [OBSOLESCENT] renamed exponents\\
   
{\verb~MakeTermOrd [OBSOLESCENT]~} &
      [OBSOLESCENT] renamed MakeTermOrdMat\\
   
{\verb~MinGensGeneral [OBSOLESCENT]~} &
      [OBSOLESCENT] renamed MinSubsetOfGens\\
   
{\verb~minimalize [OBSOLESCENT]~} &
      [OBSOLESCENT]\\
   
{\verb~minimalized [OBSOLESCENT]~} &
      [OBSOLESCENT] Renamed IdealOfMinGens and SubmoduleOfMinGens\\
   
{\verb~MultiArrDerMod [OBSOLESCENT]~} &
      [OBSOLESCENT] renamed MultiArrDerModule\\
   
{\verb~NewLine [OBSOLESCENT]~} &
      [OBSOLESCENT] string containing a newline\\
   
{\verb~NewRingFp [OBSOLESCENT]~} &
      create a new finite field\\
   
{\verb~poincare [OBSOLESCENT]~} &
      [OBSOLESCENT] Renamed HilbertSeries\\
   
{\verb~PreImage [OBSOLESCENT]~} &
      [OBSOLESCENT]\\
   
{\verb~PrimaryPoincare [OBSOLESCENT]~} &
      [OBSOLESCENT] renamed PrimaryHilbertSeries\\
   
{\verb~rank [OBSOLESCENT]~} &
      [OBSOLESCENT] rank\\
   
{\verb~ReadExpr [OBSOLESCENT]~} &
       [OBSOLESCENT] renamed RingElem\\
   
{\verb~RMap [OBSOLESCENT]~} &
      [OBSOLESCENT] define ring homomorphism for function image\\
   
{\verb~SmoothFactor [OBSOLESCENT]~} &
      [OBSOLESCENT] see FactorINT TrialDiv variant\\
   
{\verb~SubalgebraRepr [OBSOLESCENT]~} &
      [OBSOLESCENT] representation of a polynomial as a subalgebra element\\
   
{\verb~TensorMat [OBSOLESCENT]~} &
      [OBSOLESCENT] renamed KroneckerProd\\
   
{\verb~WeightsMatrix [OBSOLESCENT]~} &
      [OBSOLESCENT] matrix of generalized weights for indeterminates\\
   
\end{longtable}
\end{center}
\noindent


\part{CoCoA datatypes}
\setcounter{chapter}{0}
    

% -- CHAPTER --------------------------------
\chapter{BOOL}
\label{BOOL}

      

% -- SECTION --------------------------------
\section{Introduction to BOOL}
\label{Introduction to BOOL}

        
The two BOOL constants are ``\verb&true&'' and ``\verb&false&''.
(can also be written
``\verb&TRUE&'', ``\verb&FALSE&'' and ``\verb&True&'', ``\verb&False&'')
They are mainly used with the commands ``\verb&if&'' (\ref{if} pg.\pageref{if})
and ``\verb&while&'' (\ref{while} pg.\pageref{while}), etc., inside CoCoA programs.
\par 
The relational operators
\begin{verbatim}
    =  <>  <  <=  >  >=
\end{verbatim}
return boolean constants (see ``Relational Operators'' (\ref{Relational Operators} pg.\pageref{Relational Operators})).
\par 
The boolean operators are ``\verb&and&'' (\ref{and} pg.\pageref{and}), ``\verb&or&'' (\ref{or} pg.\pageref{or}), ``\verb&IsIn&'' (\ref{IsIn} pg.\pageref{IsIn}).
From version CoCoA-5.0.9 ``\verb&not&'' (\ref{not} pg.\pageref{not}) is a function (instead of
an operator).

\SeeAlso %---- SEE ALSO ----
  Relational Operators(\ref{Relational Operators} pg.\pageref{Relational Operators}), 
    Commands and Functions for BOOL(\ref{Commands and Functions for BOOL} pg.\pageref{Commands and Functions for BOOL}), 
    Commands and Functions returning BOOL(\ref{Commands and Functions returning BOOL} pg.\pageref{Commands and Functions returning BOOL})

% -- SECTION --------------------------------
\section{Commands and Functions for BOOL}
\label{Commands and Functions for BOOL}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~and~} &
      boolean "and" operator\\
   
{\verb~assert~} &
      check an assertion\\
   
{\verb~Bool01~} &
      Convert a boolean to an integer\\
   
{\verb~in~} &
      list element selector in list constructor\\
   
{\verb~IsPolyRing~} &
      test whether a ring is a polynomial ring\\
   
{\verb~not~} &
      boolean "not" operator\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~or~} &
      boolean "or" operator\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning BOOL}
\label{Commands and Functions returning BOOL}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~and~} &
      boolean "and" operator\\
   
{\verb~AreGensMonomial~} &
      checks if given gens are monomial\\
   
{\verb~AreGensSqFreeMonomial~} &
      checks if given gens are squarefree monomial\\
   
{\verb~EqSet~} &
      checks if the set of elements in two lists are equal\\
   
{\verb~Equality Operator~} &
      test whether two values are equal or not\\
   
{\verb~HasGBasis~} &
      checks if the argument has a pre-computed GBasis\\
   
{\verb~IsAntiSymmetric~} &
      checks if a matrix is anti-symmetric\\
   
{\verb~IsArrCentral~} &
      checks if the arrangement is central\\
   
{\verb~IsArrFree~} &
      checks if the arrangement is free\\
   
{\verb~IsAtEOF~} &
      checks if input stream has reached end of input\\
   
{\verb~IsCommutative~} &
      test whether a ring is commutative\\
   
{\verb~IsConstant~} &
      checks if a ringelem is in the coefficient ring\\
   
{\verb~IsContained~} &
      checks if A is Contained in B\\
   
{\verb~IsCoprime~} &
      checks if t1 is coprime with t2\\
   
{\verb~IsDiagonal~} &
      checks if a matrix is diagonal\\
   
{\verb~IsDivisible~} &
      checks if A is divisible by B\\
   
{\verb~IsElem~} &
      checks if A is an element of B\\
   
{\verb~IsEmpty~} &
      checks if a list is empty\\
   
{\verb~IsEven, IsOdd~} &
      test whether an integer is even or odd\\
   
{\verb~IsEvenPoly, IsOddPoly~} &
      test whether a polynomial is even or odd as a function\\
   
{\verb~IsFactorClosed~} &
      test whether a list of PPs is factor closed\\
   
{\verb~IsField~} &
      test whether a ring is a field\\
   
{\verb~IsFiniteField~} &
      test whether a ring is a finite field\\
   
{\verb~IsFractionField~} &
      test whether a ring is a fraction field\\
   
{\verb~IsHomog~} &
      test whether given polynomials are homogeneous\\
   
{\verb~IsIn~} &
      check if one object is contained in another\\
   
{\verb~IsIndet~} &
      check if argument is an indeterminate\\
   
{\verb~IsIndetPosPower~} &
      check if argument is a power of an indeterminate\\
   
{\verb~IsInImage~} &
      check if a RINGELEM is in image of RINGHOM\\
   
{\verb~IsInjective~} &
      check if a RINGHOM is injective\\
   
{\verb~IsInRadical~} &
      check if a polynomial (or ideal) is in a radical\\
   
{\verb~IsInteger~} &
      check if a RINGELEM is integer\\
   
{\verb~IsIntegralDomain~} &
      test whether a ring is integral\\
   
{\verb~IsInvertible~} &
      check if a RINGELEM is invertible\\
   
{\verb~IsIrred~} &
      check if a RINGELEM is irreducible\\
   
{\verb~IsLattice~} &
      checks if the poset is a lattice\\
   
{\verb~IsLexSegment~} &
      checks if an ideal is lex-segment\\
   
{\verb~IsMaximal~} &
      maximality test\\
   
{\verb~IsMinusOne~} &
      test whether an object is -1\\
   
{\verb~IsMultiArrFree~} &
      checks if the multiarrangement is free\\
   
{\verb~IsOne~} &
      test whether an object is one\\
   
{\verb~IsPolyRing~} &
      test whether a ring is a polynomial ring\\
   
{\verb~IsPosetGraded~} &
      checks if the poset is graded\\
   
{\verb~IsPositiveGrading~} &
      check if a matrix defines a positive grading\\
   
{\verb~IsPrimary~} &
      primary test\\
   
{\verb~IsPrime~} &
      prime integer test\\
   
{\verb~IsProbPrime~} &
      checks if an integer is a probable prime\\
   
{\verb~IsPthPower~} &
      p-th power test\\
   
{\verb~IsQQ~} &
      test whether a ring is the ring of rationals\\
   
{\verb~IsQuotientRing~} &
      test whether a ring is a quotient ring\\
   
{\verb~IsRadical~} &
      check if an IDEAL is radical\\
   
{\verb~IsRational~} &
      check if a RINGELEM is rational\\
   
{\verb~IsSigmaGoodPrime~} &
      check if INT is good prime for IDEAL \\
   
{\verb~IsSqFree~} &
      check if an INT or RINGELEM is square-free\\
   
{\verb~IsSquare~} &
      check if an INT is a square\\
   
{\verb~IsStable~} &
      checks if an ideal is stable\\
   
{\verb~IsStdGraded~} &
      checks if the grading is standard\\
   
{\verb~IsStronglyStable~} &
      checks if an ideal is strongly stable\\
   
{\verb~IsSubset~} &
      checks if the elements of one list are a subset of another\\
   
{\verb~IsSurjective~} &
      check if a RINGHOM is surjective\\
   
{\verb~IsSymmetric~} &
      checks if a matrix is symmetric\\
   
{\verb~IsTerm~} &
      checks if the argument is a term\\
   
{\verb~IsTermOrdering~} &
      check if a matrix defines a term-ordering\\
   
{\verb~IsTrueGCDDomain~} &
      test whether a ring is a true GCD domain\\
   
{\verb~IsZero~} &
      test whether an object is zero\\
   
{\verb~IsZeroCol, IsZeroRow~} &
      test whether a column(row) is zero\\
   
{\verb~IsZeroDet~} &
      test whether determinant is zero\\
   
{\verb~IsZeroDim~} &
      test whether an ideal is zero-dimensional\\
   
{\verb~IsZeroDivisor~} &
      test whether a RINGELEM is a zero-divisor\\
   
{\verb~IsZZ~} &
      test whether a ring is the ring of integers\\
   
{\verb~not~} &
      boolean "not" operator\\
   
{\verb~or~} &
      boolean "or" operator\\
   
{\verb~Order Comparison Operators~} &
      less than, greater than, ...\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{INT}
\label{INT}

      

% -- SECTION --------------------------------
\section{Introduction to INT}
\label{Introduction to INT}

        
There are two types of numbers recognized by CoCoA: integers (type
INT), rationals (type RAT).
(CoCoA-4 also had ``\verb&ZMOD&'', but CoCoA-5 can deal with more rings:
see ``\verb&NewZZmod&'' (\ref{NewZZmod} pg.\pageref{NewZZmod})).
Numbers in CoCoA are handled with arbitrary precision.  This means that the
sizes of numbers are only limited by the amount of available memory.
The basic numeric operations---addition (``\verb&+&''), subtraction (``\verb&-&''),
multiplication (``\verb&*&''), division (``\verb&/&''), exponentiation (``\verb&^&''),
and negation (``\verb&-&'')---behave as one would expect.
Be careful, two adjacent minus signs, ``\verb&--&'', start a comment in CoCoA.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  N := 3;
/**/  -N;
-3
--N;  <-- THIS IS A COMMENT  (not C++ decrement)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Commands and Functions for INT(\ref{Commands and Functions for INT} pg.\pageref{Commands and Functions for INT}), 
    Commands and Functions returning INT(\ref{Commands and Functions returning INT} pg.\pageref{Commands and Functions returning INT})

% -- SECTION --------------------------------
\section{Commands and Functions for INT}
\label{Commands and Functions for INT}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~abs~} &
      absolute value of a number\\
   
{\verb~AffHilbertFn~} &
      the affine Hilbert function\\
   
{\verb~ArrBoolean~} &
      boolean arrangement\\
   
{\verb~ArrBraid~} &
      braid arrangement\\
   
{\verb~ArrCatalanA~} &
      Catalan arrangement of type A\\
   
{\verb~ArrCatalanB~} &
      Catalan arrangement of type B\\
   
{\verb~ArrCatalanD~} &
      Catalan arrangement of type D\\
   
{\verb~ArrShiA~} &
      Shi arrangement of type A\\
   
{\verb~ArrShiB~} &
      Shi arrangement of type B\\
   
{\verb~ArrShiCatalanA~} &
      Shi-Catalan arrangement of type A with multiplicities\\
   
{\verb~ArrShiCatalanB~} &
      Shi-Catalan arrangement of type B with given multiplicities\\
   
{\verb~ArrShiCatalanD~} &
      Shi-Catalan arrangement of type D with given multiplicities\\
   
{\verb~ArrShiD~} &
      Shi arrangement of type D\\
   
{\verb~ArrTypeB~} &
      reflection arrangement of type B\\
   
{\verb~ArrTypeD~} &
      reflection arrangement of type D\\
   
{\verb~ascii~} &
      convert between characters and ascii code\\
   
{\verb~AsINT~} &
      convert into an INT\\
   
{\verb~AsRAT~} &
      convert into a RAT\\
   
{\verb~binomial~} &
      binomial coefficient\\
   
{\verb~BinomialRepr, BinomialReprShift~} &
      binomial representation of integers\\
   
{\verb~ChebyshevPoly~} &
      Orthogonal Polynomials: Chebyshev, Hermite, Laguerre\\
   
{\verb~ContFracToRat~} &
      convert continued fraction to rational\\
   
{\verb~CoprimeFactorBasis~} &
      determine coprime factor base for a set of integers or ring elements\\
   
{\verb~CRT~} &
      Chinese Remainder Theorem\\
   
{\verb~CRTPoly~} &
      Chinese Remainder Theorem on polynomial coefficients\\
   
{\verb~cyclotomic~} &
      n-th cyclotomic polynomial\\
   
{\verb~DecimalStr~} &
      convert rational number to decimal string\\
   
{\verb~den~} &
      denominator\\
   
{\verb~DensePoly~} &
      the sum of all power-products of a given degree\\
   
{\verb~DicksonPoly~} &
      Dickson polynomial\\
   
{\verb~div~} &
      quotient for integers\\
   
{\verb~ElimMat~} &
      matrix for elimination ordering\\
   
{\verb~EulerTotient~} &
      Euler Totient function for positive integers\\
   
{\verb~EvalHilbertFn~} &
      evaluate the Hilbert function\\
   
{\verb~exponents~} &
      the list of exponents of the leading term of a polynomial\\
   
{\verb~Ext~} &
      presentation Ext modules as quotients of free modules\\
   
{\verb~factorial~} &
      factorial function\\
   
{\verb~FactorINT~} &
      find prime factors of an integer\\
   
{\verb~FactorMultiplicity~} &
      multiplicity of a factor of an integer\\
   
{\verb~fibonacci~} &
      n-th fibonacci number\\
   
{\verb~first~} &
      the first N elements of a list\\
   
{\verb~flatten~} &
      flatten a list\\
   
{\verb~FloatApprox~} &
      approx. of rational number of the form $M*2^E$\\
   
{\verb~FloatStr~} &
      convert rational number to a decimal string\\
   
{\verb~FloorLog2, FloorLog10, FloorLogBase~} &
      integer part of the logarithm\\
   
{\verb~FloorRoot~} &
      integer part of r-th root of an integer\\
   
{\verb~FloorSqrt~} &
      (truncated) square root of an integer\\
   
{\verb~fold~} &
      inset newlines into a long string\\
   
{\verb~FoldToListInput~} &
      convert string so it looks like a list of short strings\\
   
{\verb~format~} &
      convert object to formatted string\\
   
{\verb~GBasisTimeout~} &
      compute a Groebner basis with a timeout\\
   
{\verb~gcd~} &
      greatest common divisor\\
   
{\verb~GenericPoints~} &
      random projective points\\
   
{\verb~GetCol~} &
      convert a column of a matrix into a list\\
   
{\verb~GetRow~} &
      convert a row of a matrix into a list\\
   
{\verb~HermitePoly~} &
      Orthogonal Polynomials: Chebyshev, Hermite, Laguerre\\
   
{\verb~HilbertFn~} &
      the Hilbert function\\
   
{\verb~HilbertMat~} &
      create a Hilbert matrix over QQ\\
   
{\verb~HomogCompt~} &
      homogeneous part of given degree\\
   
{\verb~IdentityMat~} &
      the identity matrix\\
   
{\verb~incr, decr~} &
      increment/decrement a counter\\
   
{\verb~indent~} &
      prints in a more readable way\\
   
{\verb~indet~} &
      individual indeterminates\\
   
{\verb~insert [OBSOLESCENT]~} &
      [OBSOLESCENT] insert an object in a list\\
   
{\verb~InverseSystem~} &
      Inverse system of an ideal of derivations\\
   
{\verb~IsDivisible~} &
      checks if A is divisible by B\\
   
{\verb~IsEven, IsOdd~} &
      test whether an integer is even or odd\\
   
{\verb~IsInteger~} &
      check if a RINGELEM is integer\\
   
{\verb~IsMinusOne~} &
      test whether an object is -1\\
   
{\verb~IsOne~} &
      test whether an object is one\\
   
{\verb~IsPrime~} &
      prime integer test\\
   
{\verb~IsProbPrime~} &
      checks if an integer is a probable prime\\
   
{\verb~IsSigmaGoodPrime~} &
      check if INT is good prime for IDEAL \\
   
{\verb~IsSqFree~} &
      check if an INT or RINGELEM is square-free\\
   
{\verb~IsSquare~} &
      check if an INT is a square\\
   
{\verb~IsZero~} &
      test whether an object is zero\\
   
{\verb~IsZeroCol, IsZeroRow~} &
      test whether a column(row) is zero\\
   
{\verb~KroneckerSymbol~} &
      Kronecker symbol of R mod M\\
   
{\verb~LaguerrePoly~} &
      Orthogonal Polynomials: Chebyshev, Hermite, Laguerre\\
   
{\verb~last~} &
      the last N elements of a list\\
   
{\verb~lcm~} &
      least common multiple\\
   
{\verb~LexMat~} &
      matrices for std. term-orderings\\
   
{\verb~MakeMatByRows, MakeMatByCols~} &
      convert a list into a matrix\\
   
{\verb~MakeTerm~} &
      returns a monomial (power-product) with given exponents\\
   
{\verb~MakeTermOrdMat~} &
      Make a term order matrix from a given matrix\\
   
{\verb~MantissaAndExponent10~} &
      convert rational number to a float\\
   
{\verb~MantissaAndExponent2~} &
      convert rational number to a binary float\\
   
{\verb~max~} &
      a maximum element of a sequence or list\\
   
{\verb~min~} &
      a minimum element of a sequence or list\\
   
{\verb~minors~} &
      list of minor determinants of a matrix\\
   
{\verb~mod~} &
      remainder for integers\\
   
{\verb~NewFreeModule~} &
      create a new FreeModule\\
   
{\verb~NewList~} &
      create a new list\\
   
{\verb~NewMat~} &
      Zero matrix\\
   
{\verb~NewMatFilled~} &
      matrix filled with value\\
   
{\verb~NewPolyRing~} &
      create a new PolyRing\\
   
{\verb~NewRingTwinFloat~} &
      create a new twin-float ring\\
   
{\verb~NewZZmod~} &
      create a new finite ring (integers mod N)\\
   
{\verb~NextPrime, NextProbPrime~} &
      find the next prime number\\
   
{\verb~NmzSetVerbosityLevel~} &
      Set the verbosity state for Normaliz\\
   
{\verb~num~} &
      numerator\\
   
{\verb~NumPartitions~} &
      number of partitions of an integer\\
   
{\verb~OpenSocket~} &
      open a socket connection\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~partitions~} &
      partitions of an integer\\
   
{\verb~PosetJoin~} &
      join between two elements of a poset from the relations of the poset\\
   
{\verb~PosetMeet~} &
      meet between two elements of a poset from the relations of the poset\\
   
{\verb~PosetNRank~} &
      rank of the node N from the relations of the graded poset\\
   
{\verb~power~} &
      compute a power\\
   
{\verb~PowerMod~} &
      compute a modular power efficiently\\
   
{\verb~PrevPrime, PrevProbPrime~} &
      find the previous prime number\\
   
{\verb~PrimitiveRoot~} &
      find a primitive root modulo a prime\\
   
{\verb~primorial~} &
      primorial function\\
   
{\verb~product~} &
      the product of the elements of a list\\
   
{\verb~radical~} &
      radical of an ideal\\
   
{\verb~random~} &
      random integer\\
   
{\verb~RandomLinearForm~} &
      random linear form in polynomial ring\\
   
{\verb~RandomPermutation~} &
      random permutation (of indices)\\
   
{\verb~RandomSmallPrime~} &
      Random prime between 5 and N\\
   
{\verb~RandomSparseNonSing01Mat~} &
      random sparse non-singular (0,1) matrix\\
   
{\verb~RandomSubset~} &
      random subset\\
   
{\verb~RandomSubsetIndices~} &
      indices for random subset\\
   
{\verb~RandomTuple~} &
      random tuple\\
   
{\verb~RandomTupleIndices~} &
      indices for random tuples\\
   
{\verb~RandomUnimodularMat~} &
      random unimodular matrix\\
   
{\verb~RatReconstructByContFrac~} &
      rational reconstruction from modular image\\
   
{\verb~RatReconstructByLattice~} &
      rational reconstruction from modular image\\
   
{\verb~RatReconstructPoly~} &
      Rational reconstruction of polynomial coefficents\\
   
{\verb~RatReconstructWithBounds~} &
      deterministic rational reconstruction from modular image\\
   
{\verb~RelNotes~} &
      print the release notes\\
   
{\verb~remove~} &
      remove an object in a list\\
   
{\verb~reseed~} &
      reseed the pseudo-random number generator\\
   
{\verb~RevLexMat~} &
      matrix for rev lex term-ordering\\
   
{\verb~RingElem~} &
      convert an expression into a RINGELEM\\
   
{\verb~RingQQt~} &
      pre-defined polynomial rings\\
   
{\verb~RootBound~} &
      bound on roots of a polynomial over QQ\\
   
{\verb~ScientificStr~} &
      convert integer/rational to a floating-point string\\
   
{\verb~SectionalMatrix~} &
      sectional matrix \\
   
{\verb~SetCol~} &
      set a list as a column into a matrix\\
   
{\verb~SetEntry~} &
      set an entry into a matrix\\
   
{\verb~SetRow~} &
      set a list as a row into a matrix\\
   
{\verb~SetStackSize~} &
      secret ;-)\\
   
{\verb~SetVerbosityLevel~} &
      set the verbosity level\\
   
{\verb~sign~} &
      the sign of a number\\
   
{\verb~SleepFor~} &
      Make program sleep for a specified time\\
   
{\verb~SmallestNonDivisor~} &
      find smallest prime which does not divide an integer\\
   
{\verb~SmoothFactor [OBSOLESCENT]~} &
      [OBSOLESCENT] see FactorINT TrialDiv variant\\
   
{\verb~SourceRegion~} &
      read commands from a region in a file\\
   
{\verb~spaces~} &
      return a string of spaces\\
   
{\verb~SprintTrunc~} &
      convert to a string and truncate\\
   
{\verb~StdDegLexMat~} &
      matrix for std deg lex term-ordering\\
   
{\verb~StdDegRevLexMat~} &
      matrix for std deg rev lex term-ordering\\
   
{\verb~submat~} &
      submatrix\\
   
{\verb~subsets~} &
      returns all sublists of a list\\
   
{\verb~substring~} &
      substring of a string\\
   
{\verb~sum~} &
      the sum of the elements of a list\\
   
{\verb~SwapCols~} &
      swap two columns in a matrix\\
   
{\verb~SwapRows~} &
      swap two rows in a matrix\\
   
{\verb~SwinnertonDyerPoly~} &
      compute Swinnerton-Dyer polynomial with given roots\\
   
{\verb~SymbolRange~} &
      range of symbols for the indeterminates of a PolyRing\\
   
{\verb~syz~} &
      syzygy modules\\
   
{\verb~tuples~} &
      N-tuples\\
   
{\verb~WithoutNth~} &
      removes the N-th component from a list\\
   
{\verb~XelMat~} &
      matrices for std. term-orderings\\
   
{\verb~ZeroMat~} &
      matrix filled with 0\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning INT}
\label{Commands and Functions returning INT}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~abs~} &
      absolute value of a number\\
   
{\verb~AffHilbertFn~} &
      the affine Hilbert function\\
   
{\verb~AsINT~} &
      convert into an INT\\
   
{\verb~binomial~} &
      binomial coefficient\\
   
{\verb~BinomialRepr, BinomialReprShift~} &
      binomial representation of integers\\
   
{\verb~Bool01~} &
      Convert a boolean to an integer\\
   
{\verb~ceil~} &
      round rational up to integer\\
   
{\verb~characteristic~} &
      the characteristic of a ring\\
   
{\verb~ContFrac~} &
      continued fraction quotients\\
   
{\verb~count~} &
      count the objects in a list\\
   
{\verb~date~} &
      the date\\
   
{\verb~deg~} &
      the standard degree of a polynomial or moduleelem\\
   
{\verb~den~} &
      denominator\\
   
{\verb~depth~} &
      Depth of a module\\
   
{\verb~dim~} &
      the dimension of a (quotient) ring\\
   
{\verb~div~} &
      quotient for integers\\
   
{\verb~EulerTotient~} &
      Euler Totient function for positive integers\\
   
{\verb~EvalHilbertFn~} &
      evaluate the Hilbert function\\
   
{\verb~factorial~} &
      factorial function\\
   
{\verb~FactorMultiplicity~} &
      multiplicity of a factor of an integer\\
   
{\verb~fibonacci~} &
      n-th fibonacci number\\
   
{\verb~floor~} &
      round rational down to integer\\
   
{\verb~FloorLog2, FloorLog10, FloorLogBase~} &
      integer part of the logarithm\\
   
{\verb~FloorRoot~} &
      integer part of r-th root of an integer\\
   
{\verb~FloorSqrt~} &
      (truncated) square root of an integer\\
   
{\verb~gcd~} &
      greatest common divisor\\
   
{\verb~GFanContainsPositiveVector~} &
      ...\\
   
{\verb~GFanGetAmbientDimension~} &
      ...\\
   
{\verb~GFanGetCodimension~} &
      ...\\
   
{\verb~GFanGetDimension~} &
      ...\\
   
{\verb~GFanGetDimensionOfLinealitySpace~} &
      ...\\
   
{\verb~GradingDim~} &
      Number of components in weighted degree\\
   
{\verb~HilbertFn~} &
      the Hilbert function\\
   
{\verb~IndetIndex~} &
      index of an indeterminate\\
   
{\verb~KroneckerSymbol~} &
      Kronecker symbol of R mod M\\
   
{\verb~lcm~} &
      least common multiple\\
   
{\verb~len~} &
      the length of an object\\
   
{\verb~LogCardinality~} &
      extension degree of a finite field\\
   
{\verb~LPosn~} &
      the position of the leading power-product in a ModuleElem\\
   
{\verb~MayerVietorisTreeN1~} &
      N-1st Betti multidegrees of monomial ideals using Mayer-Vietoris trees\\
   
{\verb~MinPowerInIdeal~} &
      the mininum power of a polynomial is an ideal\\
   
{\verb~mod~} &
      remainder for integers\\
   
{\verb~moebius~} &
      Moebius function of a poset\\
   
{\verb~multiplicity~} &
      the multiplicity (degree) of a ring\\
   
{\verb~NextPrime, NextProbPrime~} &
      find the next prime number\\
   
{\verb~NmzVerbosityLevel~} &
      Get the verbosity level for Normaliz\\
   
{\verb~num~} &
      numerator\\
   
{\verb~NumBChambers~} &
      number of bounded chambers of an arrangement of hyperplanes\\
   
{\verb~NumChambers~} &
      number of chambers of an arrangement of hyperplanes\\
   
{\verb~NumCols~} &
      number of columns in a matrix\\
   
{\verb~NumCompts~} &
      the number of components\\
   
{\verb~NumGens~} &
      number of generators\\
   
{\verb~NumIndets~} &
      number of indeterminates\\
   
{\verb~NumPartitions~} &
      number of partitions of an integer\\
   
{\verb~NumRealRoots~} &
      number of real roots of a polynomial\\
   
{\verb~NumRows~} &
      number of rows in a matrix\\
   
{\verb~NumTerms~} &
      number of terms in a polynomial\\
   
{\verb~PosetNRank~} &
      rank of the node N from the relations of the graded poset\\
   
{\verb~PosetRank~} &
      rank of the poset from its relations\\
   
{\verb~power~} &
      compute a power\\
   
{\verb~PowerMod~} &
      compute a modular power efficiently\\
   
{\verb~PrevPrime, PrevProbPrime~} &
      find the previous prime number\\
   
{\verb~PrimitiveRoot~} &
      find a primitive root modulo a prime\\
   
{\verb~primorial~} &
      primorial function\\
   
{\verb~radical~} &
      radical of an ideal\\
   
{\verb~random~} &
      random integer\\
   
{\verb~RandomSmallPrime~} &
      Random prime between 5 and N\\
   
{\verb~reg~} &
      Castelnuovo-Mumford regularity of a module\\
   
{\verb~RegularityIndex~} &
      regularity index of a Hilbert function or series\\
   
{\verb~RingID~} &
      identification for ring\\
   
{\verb~rk~} &
      rank of a matrix or module\\
   
{\verb~round~} &
      round to integer\\
   
{\verb~ScalarProduct~} &
      scalar product\\
   
{\verb~sign~} &
      the sign of a number\\
   
{\verb~SmallestNonDivisor~} &
      find smallest prime which does not divide an integer\\
   
{\verb~SystemCommand~} &
      run a system command\\
   
{\verb~TimeOfDay~} &
      the current time\\
   
{\verb~UnivariateIndetIndex~} &
      the index of the indeterminate of a univariate polynomial\\
   
{\verb~VerbosityLevel~} &
      verbosity level\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{RAT}
\label{RAT}

      

% -- SECTION --------------------------------
\section{Introduction to RAT}
\label{Introduction to RAT}

        
Rational numbers can be entered as fractions or as terminating decimals.
CoCoA always converts a rational number into a fraction in lowest terms.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  3.8;
19/5
/**/  N := 4/8;  N;
1/2
/**/  type(N);
RAT
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Commands and Functions for RAT(\ref{Commands and Functions for RAT} pg.\pageref{Commands and Functions for RAT}), 
    Commands and Functions returning RAT(\ref{Commands and Functions returning RAT} pg.\pageref{Commands and Functions returning RAT})

% -- SECTION --------------------------------
\section{Commands and Functions for RAT}
\label{Commands and Functions for RAT}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~abs~} &
      absolute value of a number\\
   
{\verb~AsINT~} &
      convert into an INT\\
   
{\verb~AsRAT~} &
      convert into a RAT\\
   
{\verb~ceil~} &
      round rational up to integer\\
   
{\verb~CFApprox~} &
      continued fraction approximation\\
   
{\verb~CFApproximants~} &
      continued fraction approximants\\
   
{\verb~ContFrac~} &
      continued fraction quotients\\
   
{\verb~DecimalStr~} &
      convert rational number to decimal string\\
   
{\verb~den~} &
      denominator\\
   
{\verb~FloatApprox~} &
      approx. of rational number of the form $M*2^E$\\
   
{\verb~FloatStr~} &
      convert rational number to a decimal string\\
   
{\verb~floor~} &
      round rational down to integer\\
   
{\verb~FloorLog2, FloorLog10, FloorLogBase~} &
      integer part of the logarithm\\
   
{\verb~IsMinusOne~} &
      test whether an object is -1\\
   
{\verb~IsOne~} &
      test whether an object is one\\
   
{\verb~IsRational~} &
      check if a RINGELEM is rational\\
   
{\verb~IsZero~} &
      test whether an object is zero\\
   
{\verb~MantissaAndExponent10~} &
      convert rational number to a float\\
   
{\verb~MantissaAndExponent2~} &
      convert rational number to a binary float\\
   
{\verb~max~} &
      a maximum element of a sequence or list\\
   
{\verb~min~} &
      a minimum element of a sequence or list\\
   
{\verb~NewMatFilled~} &
      matrix filled with value\\
   
{\verb~num~} &
      numerator\\
   
{\verb~power~} &
      compute a power\\
   
{\verb~product~} &
      the product of the elements of a list\\
   
{\verb~RealRootRefine~} &
      refine a real root of a univariate polynomial\\
   
{\verb~RealRoots~} &
      real roots of a univariate polynomial\\
   
{\verb~RealRootsApprox~} &
      approximations to the real roots of a univariate poly\\
   
{\verb~RingElem~} &
      convert an expression into a RINGELEM\\
   
{\verb~round~} &
      round to integer\\
   
{\verb~ScientificStr~} &
      convert integer/rational to a floating-point string\\
   
{\verb~SetEntry~} &
      set an entry into a matrix\\
   
{\verb~sign~} &
      the sign of a number\\
   
{\verb~SimplestBinaryRatBetween~} &
      find simplest binary rational in a closed interval\\
   
{\verb~SimplestRatBetween~} &
      find simplest rational in a closed interval\\
   
{\verb~SleepFor~} &
      Make program sleep for a specified time\\
   
{\verb~StableBBasis5~} &
      Stable Border Basis of ideal of points\\
   
{\verb~sum~} &
      the sum of the elements of a list\\
   
{\verb~TimeFrom~} &
      time elapsed since a given moment\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning RAT}
\label{Commands and Functions returning RAT}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~abs~} &
      absolute value of a number\\
   
{\verb~AsRAT~} &
      convert into a RAT\\
   
{\verb~CFApprox~} &
      continued fraction approximation\\
   
{\verb~CFApproximants~} &
      continued fraction approximants\\
   
{\verb~ContFracToRat~} &
      convert continued fraction to rational\\
   
{\verb~CpuTime~} &
      Counts cpu time\\
   
{\verb~ElapsedTime~} &
      Counts elapsed time\\
   
{\verb~FloatApprox~} &
      approx. of rational number of the form $M*2^E$\\
   
{\verb~power~} &
      compute a power\\
   
{\verb~RootBound~} &
      bound on roots of a polynomial over QQ\\
   
{\verb~ScalarProduct~} &
      scalar product\\
   
{\verb~SimplestBinaryRatBetween~} &
      find simplest binary rational in a closed interval\\
   
{\verb~SimplestRatBetween~} &
      find simplest rational in a closed interval\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{STRING}
\label{STRING}

      

% -- SECTION --------------------------------
\section{String Literals}
\label{String Literals}

        
A string literal consists of a sequence of characters between double
quotes ("...").
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ PrintLn "The primes up to 10 are ", [n in 1..10 | IsPrime(n)];
The primes up to 10 are [2, 3, 5, 7]

/**/ Print "The quick brown fox", "jumped over the lazy dog.";
The quick brown foxjumped over the lazy dog
\end{Verbatim}


To put special characters in CoCoA string literals use the appropriate
\textbf{escape sequence}.  Here is a summary:
  ``\verb&\"&''  produces a double-quote character;
  ``\verb&\n&''  produces a newline character;
  ``\verb&\\&''  produces a backslash character;
  ``\verb&\t&''  produces a TAB character;
  ``\verb&\r&''  produces a carriage-return character.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ Print "line 1\nline 2";
line 1
line 2
/**/  Print "A string containing \"quote marks\".";
A string containing "quote marks".
\end{Verbatim}


WARNING: CoCoA still accepts an \textbf{obsolescent} syntax for string
literals (between single-quotes); do not use this!

\SeeAlso %---- SEE ALSO ----
  String Operations(\ref{String Operations} pg.\pageref{String Operations}), 
    sprint(\ref{sprint} pg.\pageref{sprint}), 
    Commands and Functions for STRING(\ref{Commands and Functions for STRING} pg.\pageref{Commands and Functions for STRING}), 
    Commands and Functions returning STRING(\ref{Commands and Functions returning STRING} pg.\pageref{Commands and Functions returning STRING})

% -- SECTION --------------------------------
\section{String Operations}
\label{String Operations}

        
CoCoA offers only a few operations on strings: length, concatenation,
comparison, substring containment and indexing.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/ str := "Hello" + "World!";  --> string concatenation
/**/ Print str;
HelloWorld!
/**/ len(str);       --> length in characters
11
/**/ "Abc" < str;    --> lexicographical comparison
true
/**/ str[1];         --> character indexing, indexes start from 1
H
\end{Verbatim}


The operator ``\verb&IsIn&'' (\ref{IsIn} pg.\pageref{IsIn}) can be used to test if one string is
a substring of another.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  mesg := "Banana";
/**/  "ana" IsIn mesg;
true
/**/  "Ana" IsIn mesg;  --> substring must be an exact match
false
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  String Literals(\ref{String Literals} pg.\pageref{String Literals}), 
    ascii(\ref{ascii} pg.\pageref{ascii}), 
    ConcatStrings(\ref{ConcatStrings} pg.\pageref{ConcatStrings}), 
    IsIn(\ref{IsIn} pg.\pageref{IsIn}), 
    len(\ref{len} pg.\pageref{len}), 
    substring(\ref{substring} pg.\pageref{substring})

% -- SECTION --------------------------------
\section{Commands and Functions for STRING}
\label{Commands and Functions for STRING}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~ascii~} &
      convert between characters and ascii code\\
   
{\verb~ConcatStrings~} &
      concatenate strings\\
   
{\verb~error~} &
      throw an error message\\
   
{\verb~fold~} &
      inset newlines into a long string\\
   
{\verb~FoldToListInput~} &
      convert string so it looks like a list of short strings\\
   
{\verb~GetEnv~} &
      access shell variables\\
   
{\verb~ImplicitHypersurface~} &
      implicitization of hypersurface\\
   
{\verb~ImplicitPlotOn~} &
      outputs the zero locus of a bivariate polynomial to a file\\
   
{\verb~indets~} &
      list of indeterminates in a PolyRing\\
   
{\verb~IsIn~} &
      check if one object is contained in another\\
   
{\verb~len~} &
      the length of an object\\
   
{\verb~max~} &
      a maximum element of a sequence or list\\
   
{\verb~min~} &
      a minimum element of a sequence or list\\
   
{\verb~NewPolyRing~} &
      create a new PolyRing\\
   
{\verb~NewQuotientRing~} &
      create a new quotient ring\\
   
{\verb~NewWeylAlgebra~} &
      create a new Weyl Algebra\\
   
{\verb~OpenIFile~} &
      open input file\\
   
{\verb~OpenIString~} &
      open input string\\
   
{\verb~OpenOFile~} &
      open output file\\
   
{\verb~OpenSocket~} &
      open a socket connection\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~package~} &
      keyword marking content of a CoCoA package\\
   
{\verb~PackageOf~} &
      package of an identifier\\
   
{\verb~PlayCantStop~} &
      First game in CoCoA\\
   
{\verb~PlotPointsOn~} &
      outputs the coordinates of the points to a file\\
   
{\verb~PolyAlgebraHom~} &
      homomorphism of polynomial algebras\\
   
{\verb~PolyRingHom~} &
      homomorphism of polynomial rings\\
   
{\verb~protect~} &
      protect a variable from being overwritten\\
   
{\verb~RingElem~} &
      convert an expression into a RINGELEM\\
   
{\verb~RingElemList, RingElems~} &
      convert expressions into a LIST of RINGELEM\\
   
{\verb~source~} &
      read commands from a file or device\\
   
{\verb~SourceRegion~} &
      read commands from a region in a file\\
   
{\verb~starting~} &
      list functions starting with a given string\\
   
{\verb~substring~} &
      substring of a string\\
   
{\verb~SymbolRange~} &
      range of symbols for the indeterminates of a PolyRing\\
   
{\verb~SystemCommand~} &
      run a system command\\
   
{\verb~tagged~} &
      tag an object for pretty printing\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning STRING}
\label{Commands and Functions returning STRING}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~ascii~} &
      convert between characters and ascii code\\
   
{\verb~CocoaPackagePath~} &
      returns the path to the CoCoA packages\\
   
{\verb~ConcatStrings~} &
      concatenate strings\\
   
{\verb~DecimalStr~} &
      convert rational number to decimal string\\
   
{\verb~ExternalLibs~} &
      Linked external libraries\\
   
{\verb~FloatStr~} &
      convert rational number to a decimal string\\
   
{\verb~fold~} &
      inset newlines into a long string\\
   
{\verb~FoldToListInput~} &
      convert string so it looks like a list of short strings\\
   
{\verb~format~} &
      convert object to formatted string\\
   
{\verb~GetEnv~} &
      access shell variables\\
   
{\verb~GetErrMesg~} &
      returns the message associated with an error\\
   
{\verb~GetLine~} &
      read a line of input from an in-stream\\
   
{\verb~IndetName~} &
      the name of an indeterminate\\
   
{\verb~latex~} &
      LaTeX formatting\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~PackageOf~} &
      package of an identifier\\
   
{\verb~packages~} &
      list of loaded packages\\
   
{\verb~PkgName~} &
      returns the name of a package\\
   
{\verb~ScientificStr~} &
      convert integer/rational to a floating-point string\\
   
{\verb~spaces~} &
      return a string of spaces\\
   
{\verb~sprint~} &
      convert to a string\\
   
{\verb~SprintTrunc~} &
      convert to a string and truncate\\
   
{\verb~substring~} &
      substring of a string\\
   
{\verb~tag~} &
      returns the tag string of an object\\
   
{\verb~TimeFrom~} &
      time elapsed since a given moment\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{LIST}
\label{LIST}

      

% -- SECTION --------------------------------
\section{Introduction to LIST}
\label{Introduction to LIST}

        
A CoCoA list is a sequence of CoCoA objects between square brackets.
See also ``List Constructors'' (\ref{List Constructors} pg.\pageref{List Constructors}).  The objects may be of different
types, though a well-designed algorithm will likely create lists of
objects of a single type.
\par 
In particular, a list may contain other lists.  The empty list is ``\verb&[]&''.
We use square brackets to index into a list.  If ``\verb&L&'' is a non-empty
list and ``\verb&N&'' is an integer (between 1 and ``\verb&len(L)&''), then ``\verb&L[N]&'' is
the ``\verb&N&''-th component of ``\verb&L&''; indexes start from 1.
\par 
If ``\verb&L&'' contains sublists, we can write ``\verb&L[N_1, N_2,...,N_s]&'' as
shorthand for ``\verb&L[N_1][N_2]...[N_s]&'' (see the example below).
\par 
Lists are often used to build structured objects of type
MAT, MODULEELEM, IDEAL, and MODULE.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[t,x,y,z];
/**/  L := [34*x+y^2, "a string", [], [true, false]]; -- a list
/**/  L[1];  -- the 1st component
y^2 +34*x
/**/  L[2];
a string
/**/  L[3];
[ ]
/**/  L[4];  -- The 4th component is a list, itself;
[true, false]
/**/  L[4][1]; -- its 1st component;
true
/**/  L[4,1];  -- the same.
true

/**/  [1,"a"]+[2,"b"];  -- NOTE: one may add lists if their components
[3, "ab"]               -- are compatible (see "Algebraic Operators").

/**/  L := [x^2-y, t*y^2-z^3];
/**/  I := ideal(L);
/**/  I;
ideal(x^2 -y, t*y^2 -z^3)
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  len(\ref{len} pg.\pageref{len}), 
    List Constructors(\ref{List Constructors} pg.\pageref{List Constructors}), 
    Commands and Functions for LIST(\ref{Commands and Functions for LIST} pg.\pageref{Commands and Functions for LIST}), 
    Commands and Functions returning LIST(\ref{Commands and Functions returning LIST} pg.\pageref{Commands and Functions returning LIST})

% -- SECTION --------------------------------
\section{List Constructors}
\label{List Constructors}

        
These operators create new lists.
\begin{verbatim}
A..B
[A,B,C,...]
[X in L: LIST | Condn: BOOL]: LIST
[E:expression | X in L]: LIST
[E:expression | X in L: LIST and Condn: BOOL]: LIST
\end{verbatim}
``\verb&A..B&'' creates the list of (consecutive) integers from ``\verb&A&'' to ``\verb&B&'';
    both ends are included.
\par 
``\verb&[A,B,C,...]&'' makes a list containing the values ``\verb&A&'', ``\verb&B&'', ``\verb&C&'' and so on,
    in that order.  In particular, ``\verb&[]&'' creates the empty list.
\par 
``\verb&[X in L | Condn]&'' makes a list of those elements in ``\verb&L&'' for which
    condition ``\verb&Condn&'' is true; the entries in ``\verb&L&'' are considered in order.
\par 
``\verb&[E | X in L]&'' evaluates the expression ``\verb&E&'' for each ``\verb&X&'' in ``\verb&L&'', and collects
    the results in a new list; the entries in ``\verb&L&'' are considered in order.
\par 
``\verb&[E | X in L and Condn]&'' evaluates the expression ``\verb&E&'' for each ``\verb&X&'' in ``\verb&L&'' which
    satisfies the condition ``\verb&Condn&'', and collects the results in a new list;
    the entries in ``\verb&L&'' are considered in order.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  [];  --> empty list
[]
/**/  1..4;
[1, 2, 3, 4]
/**/  [3,1,4,2];
[3, 1, 4, 2]
/**/  [N in 1..10 | IsPrime(N)];
[2, 3, 5, 7]
/**/  [N^2 | N in 1..4];
[1, 4, 9, 16]
/**/  [N^2 | N in 1..10 and IsPrime(N)];
[4, 9, 25, 49]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewList(\ref{NewList} pg.\pageref{NewList}), 
    append(\ref{append} pg.\pageref{append}), 
    concat(\ref{concat} pg.\pageref{concat}), 
    Range Operator(\ref{Range Operator} pg.\pageref{Range Operator}), 
    CartesianProduct, CartesianProductList(\ref{CartesianProduct, CartesianProductList} pg.\pageref{CartesianProduct, CartesianProductList})

% -- SECTION --------------------------------
\section{Commands and Functions for LIST}
\label{Commands and Functions for LIST}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~append~} &
      append an object to a list\\
   
{\verb~ApproxSolve~} &
      Approximate real solutions for polynomial system\\
   
{\verb~ArrBettiNumbers~} &
      Betti numbers of an arrangement of hyperplanes\\
   
{\verb~ArrCharPoly~} &
      characteristic polynomial of an arrangement of hyperplanes\\
   
{\verb~ArrCone~} &
      cone of an arrangement of hyperplanes\\
   
{\verb~ArrDeletion~} &
      deletes a hyperplane from a list of hyperplanes\\
   
{\verb~ArrFlats~} &
      list of flats of an arrangement of hyperplanes\\
   
{\verb~ArrGraphical~} &
      graphical arrangement\\
   
{\verb~ArrLattice~} &
      lattice of an arrangement of hyperplanes\\
   
{\verb~ArrPoincarePoly~} &
      Poincare polynomial of an arrangement of hyperplanes\\
   
{\verb~ArrRestriction~} &
      arrangement of hyperplanes A restricted to a hyperplane\\
   
{\verb~ArrShiCatalanA~} &
      Shi-Catalan arrangement of type A with multiplicities\\
   
{\verb~ArrShiCatalanB~} &
      Shi-Catalan arrangement of type B with given multiplicities\\
   
{\verb~ArrShiCatalanD~} &
      Shi-Catalan arrangement of type D with given multiplicities\\
   
{\verb~ArrSignedGraphical~} &
      signed graphical arrangement\\
   
{\verb~ArrToMultiArr~} &
      multiarrangement from an arrangement and a list of multiplicities\\
   
{\verb~ArrTuttePoly~} &
      Tutte polynomial of an arrangement of hyperplanes\\
   
{\verb~ArtinianOrlikTeraoIdeal~} &
      Artinian Orlik-Terao ideal of an arrangement of hyperplanes\\
   
{\verb~ascii~} &
      convert between characters and ascii code\\
   
{\verb~BettiMatrix~} &
      the matrix of the graded Betti numbers\\
   
{\verb~CartesianProduct, CartesianProductList~} &
      Cartesian product of lists\\
   
{\verb~CheckArgTypes~} &
      Check types in a list\\
   
{\verb~coefficients~} &
      list of coefficients of a polynomial\\
   
{\verb~CoefficientsWRT~} &
      list of coeffs and PPs of a poly wrt indet or list of indets\\
   
{\verb~ColMat~} &
      single column matrix\\
   
{\verb~CommonDenom~} &
      Common denominator of a polynomial with rational coefficients\\
   
{\verb~concat~} &
      concatenate lists\\
   
{\verb~ConcatHorList~} &
      create a simple block matrix\\
   
{\verb~ConcatLists~} &
      concatenate a list of lists\\
   
{\verb~ConcatStrings~} &
      concatenate strings\\
   
{\verb~ConcatVerList~} &
      create a simple block matrix\\
   
{\verb~ContentWRT~} &
      content of a polynomial wrt and indet or a list of indets\\
   
{\verb~ContFracToRat~} &
      convert continued fraction to rational\\
   
{\verb~CoprimeFactorBasis~} &
      determine coprime factor base for a set of integers or ring elements\\
   
{\verb~count~} &
      count the objects in a list\\
   
{\verb~covers~} &
      a poset description from the list of the strict relations\\
   
{\verb~DiagMat~} &
      matrix with given diagonal\\
   
{\verb~diff~} &
      returns the difference between two lists\\
   
{\verb~distrib~} &
      the distribution of objects in a list\\
   
{\verb~DivAlg~} &
      division algorithm\\
   
{\verb~elim~} &
      eliminate variables\\
   
{\verb~ElimHomogMat~} &
      matrix for elimination ordering\\
   
{\verb~ElimMat~} &
      matrix for elimination ordering\\
   
{\verb~EqSet~} &
      checks if the set of elements in two lists are equal\\
   
{\verb~eval~} &
      substitute numbers or polynomials for indeterminates\\
   
{\verb~EvalQuasiPoly~} &
      Evaluate a quasi-polynomial at an integer\\
   
{\verb~Ext~} &
      presentation Ext modules as quotients of free modules\\
   
{\verb~FGLM5~} &
      perform a FGLM Groebner Basis conversion\\
   
{\verb~first~} &
      the first N elements of a list\\
   
{\verb~flatten~} &
      flatten a list\\
   
{\verb~foreach~} &
      loop command\\
   
{\verb~FrobeniusMat~} &
      matrix of the Frobenius Map\\
   
{\verb~FVector~} &
      f-vector of a top simplices list\\
   
{\verb~GBM~} &
      intersection of ideals for zero-dimensional schemes\\
   
{\verb~gcd~} &
      greatest common divisor\\
   
{\verb~HGBM~} &
      intersection of ideals for zero-dimensional schemes\\
   
{\verb~HilbertSeriesShifts~} &
      the Hilbert-Poincare series\\
   
{\verb~homog~} &
      homogenize wrt an indeterminate\\
   
{\verb~ideal~} &
      ideal generated by list\\
   
{\verb~IdealAndSeparatorsOfPoints~} &
      ideal and separators for affine points\\
   
{\verb~IdealAndSeparatorsOfProjectivePoints~} &
      ideal and separators for points\\
   
{\verb~implicit~} &
      implicitization\\
   
{\verb~ImplicitHypersurface~} &
      implicitization of hypersurface\\
   
{\verb~ImplicitPlot~} &
      outputs the zero locus of a bivariate polynomial to a file\\
   
{\verb~ImplicitPlotOn~} &
      outputs the zero locus of a bivariate polynomial to a file\\
   
{\verb~in~} &
      list element selector in list constructor\\
   
{\verb~indent~} &
      prints in a more readable way\\
   
{\verb~IndetsProd~} &
      (product of) indeterminates actually in a polynomial\\
   
{\verb~InitialIdeal~} &
      Initial ideal\\
   
{\verb~insert [OBSOLESCENT]~} &
      [OBSOLESCENT] insert an object in a list\\
   
{\verb~Interpolate~} &
      interpolating polynomial\\
   
{\verb~interreduce~} &
      interreduce a list of polynomials\\
   
{\verb~interreduced~} &
      interreduce a list of polynomials\\
   
{\verb~intersection~} &
      intersect lists, ideals, or modules\\
   
{\verb~IntersectionList~} &
      intersect lists, ideals, or modules\\
   
{\verb~IsArrCentral~} &
      checks if the arrangement is central\\
   
{\verb~IsEmpty~} &
      checks if a list is empty\\
   
{\verb~IsFactorClosed~} &
      test whether a list of PPs is factor closed\\
   
{\verb~IsHomog~} &
      test whether given polynomials are homogeneous\\
   
{\verb~IsIn~} &
      check if one object is contained in another\\
   
{\verb~IsLattice~} &
      checks if the poset is a lattice\\
   
{\verb~IsMultiArrFree~} &
      checks if the multiarrangement is free\\
   
{\verb~IsPosetGraded~} &
      checks if the poset is graded\\
   
{\verb~IsSubset~} &
      checks if the elements of one list are a subset of another\\
   
{\verb~IsTree5~} &
      checks if a facet complex is a tree\\
   
{\verb~JacobianMat~} &
      the Jacobian matrix of a list of polynomials\\
   
{\verb~last~} &
      the last N elements of a list\\
   
{\verb~lcm~} &
      least common multiple\\
   
{\verb~len~} &
      the length of an object\\
   
{\verb~LexSegmentIdeal~} &
      lex-segment ideal containing L, or with the same HilbertFn as I\\
   
{\verb~LinKerBasis~} &
      find the kernel of a matrix\\
   
{\verb~MakeMatByRows, MakeMatByCols~} &
      convert a list into a matrix\\
   
{\verb~MakeSet~} &
      remove duplicates from a list\\
   
{\verb~MakeTerm~} &
      returns a monomial (power-product) with given exponents\\
   
{\verb~matrix~} &
      convert a list into a matrix\\
   
{\verb~max~} &
      a maximum element of a sequence or list\\
   
{\verb~MaxBy~} &
      a maximum element of a list\\
   
{\verb~MaxChains~} &
      computes all the maximal chains from the relations of the poset\\
   
{\verb~min~} &
      a minimum element of a sequence or list\\
   
{\verb~MinBy~} &
      a minimum element of a list\\
   
{\verb~MinGBoverZZ [PROTOTYPE]~} &
      [PROTOTYPE] minimal Groebner basis of polys over ZZ\\
   
{\verb~ModuleElem~} &
      create a module element\\
   
{\verb~moebius~} &
      Moebius function of a poset\\
   
{\verb~MultiArrDerModule~} &
      set of generators of the module of logarithmic derivations of a multiarrangement of hyperplanes\\
   
{\verb~MultiArrExponents~} &
      exponents of a free multiarrangement of hyperplanes\\
   
{\verb~MultiArrRestrictionZiegler~} &
      Ziegler multirestriction of the arrangement of hyperplanes  wrt a hyperplane\\
   
{\verb~MultiArrToArr~} &
      underling arrangement from a multiarrangement\\
   
{\verb~MultiplicationMat~} &
      multiplication matrix of a ringelem\\
   
{\verb~NewPolyRing~} &
      create a new PolyRing\\
   
{\verb~NmzComputation~} &
      flexible access to Normaliz\\
   
{\verb~NmzEhrhartRing~} &
      Ehrhart ring\\
   
{\verb~NmzIntClosureMonIdeal~} &
      integral closure of a monomial ideal\\
   
{\verb~NmzIntClosureToricRing~} &
      integral closure of a toric ring\\
   
{\verb~NmzNormalToricRing~} &
      normalization of a toric ring\\
   
{\verb~NonZero~} &
      remove zeroes from a list\\
   
{\verb~NR~} &
      normal reduction\\
   
{\verb~NumBChambers~} &
      number of bounded chambers of an arrangement of hyperplanes\\
   
{\verb~NumChambers~} &
      number of chambers of an arrangement of hyperplanes\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~OrlikTeraoIdeal~} &
      Orlik-Terao ideal of an arrangement of hyperplanes\\
   
{\verb~permutations~} &
      returns all permutations of the entries of a list\\
   
{\verb~PlotPoints~} &
      outputs the coordinates of the points to a file\\
   
{\verb~PlotPointsOn~} &
      outputs the coordinates of the points to a file\\
   
{\verb~PolyAlgebraHom~} &
      homomorphism of polynomial algebras\\
   
{\verb~PolyRingHom~} &
      homomorphism of polynomial rings\\
   
{\verb~PosetCharPoly~} &
      characteristic polynomial of a poset from the relations of the poset\\
   
{\verb~PosetDual~} &
      dual of a poset from the relations of the poset\\
   
{\verb~PosetJoin~} &
      join between two elements of a poset from the relations of the poset\\
   
{\verb~PosetMeet~} &
      meet between two elements of a poset from the relations of the poset\\
   
{\verb~PosetNRank~} &
      rank of the node N from the relations of the graded poset\\
   
{\verb~PosetPoincarePoly~} &
      Poincare polynomial of a poset from the relations of the poset\\
   
{\verb~PosetRank~} &
      rank of the poset from its relations\\
   
{\verb~PrintBettiDiagram~} &
      print the diagram of the graded Betti numbers\\
   
{\verb~product~} &
      the product of the elements of a list\\
   
{\verb~QZP~} &
      change field for polynomials and ideals\\
   
{\verb~RandomSubset~} &
      random subset\\
   
{\verb~RandomTuple~} &
      random tuple\\
   
{\verb~RationalSolve~} &
      Rational solutions for 0-dim polynomial system\\
   
{\verb~RationalSolveHomog~} &
      Rational solutions for 0-dim polynomial system\\
   
{\verb~RatReconstructWithBounds~} &
      deterministic rational reconstruction from modular image\\
   
{\verb~ReloadMan~} &
      Reload CoCoAManual/CoCoAHelp.xml\\
   
{\verb~remove~} &
      remove an object in a list\\
   
{\verb~reverse, reversed~} &
      reverse a list\\
   
{\verb~RingsOf~} &
      list of the rings of an object\\
   
{\verb~RMap [OBSOLESCENT]~} &
      [OBSOLESCENT] define ring homomorphism for function image\\
   
{\verb~RowMat~} &
      single row matrix\\
   
{\verb~ScalarProduct~} &
      scalar product\\
   
{\verb~SeparatorsOfPoints~} &
      separators for affine points\\
   
{\verb~SeparatorsOfProjectivePoints~} &
      separators for projective points\\
   
{\verb~SetCol~} &
      set a list as a column into a matrix\\
   
{\verb~SetRow~} &
      set a list as a row into a matrix\\
   
{\verb~shape~} &
      extended list of types involved in an expression\\
   
{\verb~SimplexInfo~} &
      Stanley-Reisner ideal, AlexanderDual complex, ideal of top simplices\\
   
{\verb~SimplicialHomology~} &
      simplicial homology of a top simplices list\\
   
{\verb~SolomonTeraoIdeal~} &
      Solomon-Terao ideal of an arrangement of hyperplanes wrt a poly\\
   
{\verb~sort~} &
      sort a list\\
   
{\verb~SortBy~} &
      sort a list\\
   
{\verb~sorted~} &
      sort a list\\
   
{\verb~SortedBy~} &
      sort a list\\
   
{\verb~StableBBasis5~} &
      Stable Border Basis of ideal of points\\
   
{\verb~StableIdeal~} &
      stable ideal containing L\\
   
{\verb~StagedTrees~} &
      staged trees from Statistics\\
   
{\verb~StronglyStableIdeal~} &
      strongly stable ideal containing L\\
   
{\verb~submat~} &
      submatrix\\
   
{\verb~submodule~} &
      submodule generated by list\\
   
{\verb~subsets~} &
      returns all sublists of a list\\
   
{\verb~sum~} &
      the sum of the elements of a list\\
   
{\verb~SwinnertonDyerPoly~} &
      compute Swinnerton-Dyer polynomial with given roots\\
   
{\verb~SymbolRange~} &
      range of symbols for the indeterminates of a PolyRing\\
   
{\verb~syz~} &
      syzygy modules\\
   
{\verb~tail~} &
      remove the first element of a list\\
   
{\verb~toric~} &
      saturate toric ideals\\
   
{\verb~tuples~} &
      N-tuples\\
   
{\verb~TVecFromHF~} &
      Type vector from Hilbert Function\\
   
{\verb~TVecPoints~} &
      points associated to type vector\\
   
{\verb~TVecPrintRes~} &
      resolution associated to type vector\\
   
{\verb~TVecToHF~} &
      Hilbert Function of a type vector\\
   
{\verb~WithoutNth~} &
      removes the N-th component from a list\\
   
{\verb~ZPQ~} &
      change field for polynomials and ideals\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning LIST}
\label{Commands and Functions returning LIST}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~ArrBettiNumbers~} &
      Betti numbers of an arrangement of hyperplanes\\
   
{\verb~ArrBoolean~} &
      boolean arrangement\\
   
{\verb~ArrBraid~} &
      braid arrangement\\
   
{\verb~ArrCatalanA~} &
      Catalan arrangement of type A\\
   
{\verb~ArrCatalanB~} &
      Catalan arrangement of type B\\
   
{\verb~ArrCatalanD~} &
      Catalan arrangement of type D\\
   
{\verb~ArrCone~} &
      cone of an arrangement of hyperplanes\\
   
{\verb~ArrDeletion~} &
      deletes a hyperplane from a list of hyperplanes\\
   
{\verb~ArrExponents~} &
      exponents of a free arrangement of hyperplanes\\
   
{\verb~ArrFlats~} &
      list of flats of an arrangement of hyperplanes\\
   
{\verb~ArrGraphical~} &
      graphical arrangement\\
   
{\verb~ArrLattice~} &
      lattice of an arrangement of hyperplanes\\
   
{\verb~ArrRestriction~} &
      arrangement of hyperplanes A restricted to a hyperplane\\
   
{\verb~ArrShiA~} &
      Shi arrangement of type A\\
   
{\verb~ArrShiB~} &
      Shi arrangement of type B\\
   
{\verb~ArrShiCatalanA~} &
      Shi-Catalan arrangement of type A with multiplicities\\
   
{\verb~ArrShiCatalanB~} &
      Shi-Catalan arrangement of type B with given multiplicities\\
   
{\verb~ArrShiCatalanD~} &
      Shi-Catalan arrangement of type D with given multiplicities\\
   
{\verb~ArrShiD~} &
      Shi arrangement of type D\\
   
{\verb~ArrSignedGraphical~} &
      signed graphical arrangement\\
   
{\verb~ArrToMultiArr~} &
      multiarrangement from an arrangement and a list of multiplicities\\
   
{\verb~ArrTypeB~} &
      reflection arrangement of type B\\
   
{\verb~ArrTypeD~} &
      reflection arrangement of type D\\
   
{\verb~ascii~} &
      convert between characters and ascii code\\
   
{\verb~BBasis5~} &
      Border Basis of zero dimensional ideal\\
   
{\verb~BettiNumbers~} &
      (Multi-)graded Betti numbers\\
   
{\verb~BinomialRepr, BinomialReprShift~} &
      binomial representation of integers\\
   
{\verb~CanonicalBasis~} &
      canonical basis of a free module\\
   
{\verb~CartesianProduct, CartesianProductList~} &
      Cartesian product of lists\\
   
{\verb~CFApproximants~} &
      continued fraction approximants\\
   
{\verb~coefficients~} &
      list of coefficients of a polynomial\\
   
{\verb~CoefficientsWRT~} &
      list of coeffs and PPs of a poly wrt indet or list of indets\\
   
{\verb~CoeffListWRT~} &
      list of coefficients of a polynomial wrt an indet\\
   
{\verb~CoeffListWRTSupport~} &
      list of coefficients of a polynomial wrt a power-product basis\\
   
{\verb~compts~} &
      list of components of a ModuleElem\\
   
{\verb~concat~} &
      concatenate lists\\
   
{\verb~ConcatLists~} &
      concatenate a list of lists\\
   
{\verb~ContFrac~} &
      continued fraction quotients\\
   
{\verb~CoprimeFactorBasis~} &
      determine coprime factor base for a set of integers or ring elements\\
   
{\verb~covers~} &
      a poset description from the list of the strict relations\\
   
{\verb~CurrentTypes~} &
      lists all data types\\
   
{\verb~diff~} &
      returns the difference between two lists\\
   
{\verb~distrib~} &
      the distribution of objects in a list\\
   
{\verb~eigenfactors~} &
      eigenfactors of a matrix\\
   
{\verb~eigenvectors~} &
      eigenvalues and eigenvectors of a matrix\\
   
{\verb~EquiIsoDec~} &
      equidimensional isoradical decomposition\\
   
{\verb~exponents~} &
      the list of exponents of the leading term of a polynomial\\
   
{\verb~ExternalLibs~} &
      Linked external libraries\\
   
{\verb~FGLM5~} &
      perform a FGLM Groebner Basis conversion\\
   
{\verb~fields~} &
      list the fields of a record\\
   
{\verb~flatten~} &
      flatten a list\\
   
{\verb~FrbAlexanderDual~} &
      Alexander Dual of monomial ideals\\
   
{\verb~FrbAssociatedPrimes~} &
      Associated primes of monomial ideals\\
   
{\verb~FrbIrreducibleDecomposition~} &
      Irreducible decomposition of monomial ideals\\
   
{\verb~FrbMaximalStandardMonomials~} &
      Maximal standard monomials of monomial ideals\\
   
{\verb~FrbPrimaryDecomposition~} &
      Primary decomposition of monomial ideals\\
   
{\verb~GBasis~} &
      calculate a Groebner basis\\
   
{\verb~GBasisByHomog~} &
      calculate a Groebner basis by homogenization\\
   
{\verb~GBasisTimeout~} &
      compute a Groebner basis with a timeout\\
   
{\verb~GenericPoints~} &
      random projective points\\
   
{\verb~GenRepr~} &
      representation in terms of generators\\
   
{\verb~gens~} &
      list of generators of an ideal\\
   
{\verb~GensJacobian~} &
      set of generators of the Jacobian ideal of a polynomial\\
   
{\verb~GetCol~} &
      convert a column of a matrix into a list\\
   
{\verb~GetCols~} &
      convert a matrix into a list of lists\\
   
{\verb~GetRow~} &
      convert a row of a matrix into a list\\
   
{\verb~GetRows~} &
      convert a matrix into a list of lists\\
   
{\verb~GraverBasis~} &
      Graver basis\\
   
{\verb~GroebnerFanIdeals~} &
      all reduced Groebner bases of an ideal\\
   
{\verb~GroebnerFanReducedGBases~} &
      Groebner fan reduced GBases\\
   
{\verb~HilbertBasisKer~} &
      Hilbert basis for a monoid\\
   
{\verb~homog~} &
      homogenize wrt an indeterminate\\
   
{\verb~HVector~} &
      the h-vector of a module or quotient object\\
   
{\verb~in~} &
      list element selector in list constructor\\
   
{\verb~indets~} &
      list of indeterminates in a PolyRing\\
   
{\verb~IndetSubscripts~} &
      the indices in the name of an indeterminate\\
   
{\verb~interreduced~} &
      interreduce a list of polynomials\\
   
{\verb~intersection~} &
      intersect lists, ideals, or modules\\
   
{\verb~IntersectionList~} &
      intersect lists, ideals, or modules\\
   
{\verb~InverseSystem~} &
      Inverse system of an ideal of derivations\\
   
{\verb~JanetBasis~} &
      the Janet basis of an ideal\\
   
{\verb~LinKerBasis~} &
      find the kernel of a matrix\\
   
{\verb~MakeSet~} &
      remove duplicates from a list\\
   
{\verb~MaxChains~} &
      computes all the maximal chains from the relations of the poset\\
   
{\verb~MinGBoverZZ [PROTOTYPE]~} &
      [PROTOTYPE] minimal Groebner basis of polys over ZZ\\
   
{\verb~MinGens~} &
      list of minimal generators\\
   
{\verb~minors~} &
      list of minor determinants of a matrix\\
   
{\verb~MinSubsetOfGens~} &
      list of minimal generators\\
   
{\verb~moebius~} &
      Moebius function of a poset\\
   
{\verb~monomials~} &
      the list of monomials of a polynomial\\
   
{\verb~MultiArrExponents~} &
      exponents of a free multiarrangement of hyperplanes\\
   
{\verb~MultiArrRestrictionZiegler~} &
      Ziegler multirestriction of the arrangement of hyperplanes  wrt a hyperplane\\
   
{\verb~MultiArrToArr~} &
      underling arrangement from a multiarrangement\\
   
{\verb~NewList~} &
      create a new list\\
   
{\verb~NmzDiagInvariants~} &
      ring of invariants of a diagonalizable group action\\
   
{\verb~NmzEhrhartRing~} &
      Ehrhart ring\\
   
{\verb~NmzFiniteDiagInvariants~} &
      ring of invariants of a finite group action\\
   
{\verb~NmzIntClosureMonIdeal~} &
      integral closure of a monomial ideal\\
   
{\verb~NmzIntClosureToricRing~} &
      integral closure of a toric ring\\
   
{\verb~NmzIntersectionValRings~} &
      intersection of ring of valuations\\
   
{\verb~NmzNormalToricRing~} &
      normalization of a toric ring\\
   
{\verb~NmzTorusInvariants~} &
      ring of invariants of torus action\\
   
{\verb~NonZero~} &
      remove zeroes from a list\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~packages~} &
      list of loaded packages\\
   
{\verb~partitions~} &
      partitions of an integer\\
   
{\verb~permutations~} &
      returns all permutations of the entries of a list\\
   
{\verb~PosetDual~} &
      dual of a poset from the relations of the poset\\
   
{\verb~PosetJoin~} &
      join between two elements of a poset from the relations of the poset\\
   
{\verb~PosetMeet~} &
      meet between two elements of a poset from the relations of the poset\\
   
{\verb~PrimaryDecomposition~} &
      primary decomposition of an ideal\\
   
{\verb~PrimaryDecompositionGTZ0~} &
      primary decomposition of a 0-dimensional ideal\\
   
{\verb~QuotientBasis~} &
      vector space basis for zero-dimensional quotient rings\\
   
{\verb~QuotientBasisSorted~} &
      vector space basis for zero-dimensional quotient rings\\
   
{\verb~QZP~} &
      change field for polynomials and ideals\\
   
{\verb~RandomPermutation~} &
      random permutation (of indices)\\
   
{\verb~RandomSubset~} &
      random subset\\
   
{\verb~RandomSubsetIndices~} &
      indices for random subset\\
   
{\verb~RandomTuple~} &
      random tuple\\
   
{\verb~RandomTupleIndices~} &
      indices for random tuples\\
   
{\verb~RealRoots~} &
      real roots of a univariate polynomial\\
   
{\verb~RealRootsApprox~} &
      approximations to the real roots of a univariate poly\\
   
{\verb~ReducedGBasis~} &
      reduced Groebner basis\\
   
{\verb~res~} &
      free resolution\\
   
{\verb~reverse, reversed~} &
      reverse a list\\
   
{\verb~RingElemList, RingElems~} &
      convert expressions into a LIST of RINGELEM\\
   
{\verb~RingsOf~} &
      list of the rings of an object\\
   
{\verb~SeparatorsOfPoints~} &
      separators for affine points\\
   
{\verb~SeparatorsOfProjectivePoints~} &
      separators for projective points\\
   
{\verb~shape~} &
      extended list of types involved in an expression\\
   
{\verb~sorted~} &
      sort a list\\
   
{\verb~SortedBy~} &
      sort a list\\
   
{\verb~starting~} &
      list functions starting with a given string\\
   
{\verb~StdBasis~} &
      Standard basis\\
   
{\verb~SturmSeq~} &
      Sturm sequence of a univariate polynomial\\
   
{\verb~subsets~} &
      returns all sublists of a list\\
   
{\verb~support~} &
      the list of terms of a polynomial or moduleelem\\
   
{\verb~SymbolRange~} &
      range of symbols for the indeterminates of a PolyRing\\
   
{\verb~SymmetricPolys~} &
      list of symmetric polynomials\\
   
{\verb~tail~} &
      remove the first element of a list\\
   
{\verb~TopLevelFunctions~} &
      returns the functions available at top-level\\
   
{\verb~tuples~} &
      N-tuples\\
   
{\verb~TVecFromHF~} &
      Type vector from Hilbert Function\\
   
{\verb~UniversalGBasis~} &
      universal Groebner basis of the input ideal\\
   
{\verb~wdeg~} &
      multi-degree of a polynomial\\
   
{\verb~WithoutNth~} &
      removes the N-th component from a list\\
   
{\verb~ZPQ~} &
      change field for polynomials and ideals\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{RECORD}
\label{RECORD}

      

% -- SECTION --------------------------------
\section{Introduction to RECORD}
\label{Introduction to RECORD}

        
A record is a data type in CoCoA representing a list of bindings of
the form \textbf{name to object}.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  P := record[ I := ideal(x,y^2-z), F := x^2 + y, Misc := [1,3,4]];
/**/  P.I;
ideal(x, y^2 -z)
/**/ P["I"];
ideal(x, y^2 -z)

/**/  P.Misc;
[1, 3, 4]
/**/  P.Misc[2];
3

/**/  P.Date := "1/1/98";
/**/ indent(P);
record[
  Date := "1/1/98",
  F := x^2 +y,
  I := ideal(x, y^2 -z),
  Misc := [1, 3, 4]
]

/**/  P["Misc",3];  -- equivalent to P.Misc[3]
4
\end{Verbatim}


Each entry in a record is called a \textbf{field}.  Note that records are
\textbf{open} in the sense that their fields can be extended, as shown in
the previous example.  At present, there is no function for deleting
fields from a record, one must rewrite the record, selecting the
fields to retain:
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/   P := record[A := 2, B := 3, C := 5, D := 7];
/**/   Q := record[];

  Foreach F In Fields(P) Do
    If F <> "C" Then Q[F] := P[F]; EndIf;
  EndForeach;

/**/  P := Q;
/**/  P;
record[A := 2, B := 3, D := 7]
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  Commands and Functions for RECORD(\ref{Commands and Functions for RECORD} pg.\pageref{Commands and Functions for RECORD}), 
    Commands and Functions returning RECORD(\ref{Commands and Functions returning RECORD} pg.\pageref{Commands and Functions returning RECORD})

% -- SECTION --------------------------------
\section{Commands and Functions for RECORD}
\label{Commands and Functions for RECORD}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~CoefficientsWRT~} &
      list of coeffs and PPs of a poly wrt indet or list of indets\\
   
{\verb~fields~} &
      list the fields of a record\\
   
{\verb~indent~} &
      prints in a more readable way\\
   
{\verb~MSatLinSolve~} &
      \\
   
{\verb~NmzComputation~} &
      flexible access to Normaliz\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~PrintBettiDiagram~} &
      print the diagram of the graded Betti numbers\\
   
{\verb~RealRootRefine~} &
      refine a real root of a univariate polynomial\\
   
{\verb~record field selector~} &
      select a field of a record\\
   
{\verb~shape~} &
      extended list of types involved in an expression\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning RECORD}
\label{Commands and Functions returning RECORD}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~AlmostQR~} &
      QR decomposition of a matrix\\
   
{\verb~ApproxPointsNBM~} &
      Numerical Border Basis of ideal of points\\
   
{\verb~ApproxSolve~} &
      Approximate real solutions for polynomial system\\
   
{\verb~CocoaLimits~} &
      limits on exponents and ring characteristics\\
   
{\verb~ContentFreeFactor~} &
      factorization of multivariate polynomial into content-free factors\\
   
{\verb~CRT~} &
      Chinese Remainder Theorem\\
   
{\verb~CRTPoly~} &
      Chinese Remainder Theorem on polynomial coefficients\\
   
{\verb~DivAlg~} &
      division algorithm\\
   
{\verb~eigenvectors~} &
      eigenvalues and eigenvectors of a matrix\\
   
{\verb~factor~} &
      factor a polynomial\\
   
{\verb~FactorINT~} &
      find prime factors of an integer\\
   
{\verb~FVector~} &
      f-vector of a top simplices list\\
   
{\verb~HadamardBoundSq~} &
      Hadamard bound for determinant\\
   
{\verb~IdealAndSeparatorsOfPoints~} &
      ideal and separators for affine points\\
   
{\verb~IdealAndSeparatorsOfProjectivePoints~} &
      ideal and separators for points\\
   
{\verb~IndetSymbols~} &
      the names of the indeterminates in a PolyRing\\
   
{\verb~LinearSimplify~} &
      simplifying linear substitution for a univariate poly over QQ\\
   
{\verb~MantissaAndExponent10~} &
      convert rational number to a float\\
   
{\verb~MantissaAndExponent2~} &
      convert rational number to a binary float\\
   
{\verb~NmzComputation~} &
      flexible access to Normaliz\\
   
{\verb~OpenSocket~} &
      open a socket connection\\
   
{\verb~preimage0~} &
      preimage of a RINGELEM\\
   
{\verb~PreprocessPts~} &
      Reduce redundancy in a set of approximate points\\
   
{\verb~RationalSolve~} &
      Rational solutions for 0-dim polynomial system\\
   
{\verb~RationalSolveHomog~} &
      Rational solutions for 0-dim polynomial system\\
   
{\verb~RatReconstructByContFrac~} &
      rational reconstruction from modular image\\
   
{\verb~RatReconstructByLattice~} &
      rational reconstruction from modular image\\
   
{\verb~RatReconstructWithBounds~} &
      deterministic rational reconstruction from modular image\\
   
{\verb~RealRootRefine~} &
      refine a real root of a univariate polynomial\\
   
{\verb~record~} &
      create a record\\
   
{\verb~shape~} &
      extended list of types involved in an expression\\
   
{\verb~SimplexInfo~} &
      Stanley-Reisner ideal, AlexanderDual complex, ideal of top simplices\\
   
{\verb~SimplicialHomology~} &
      simplicial homology of a top simplices list\\
   
{\verb~SmoothFactor [OBSOLESCENT]~} &
      [OBSOLESCENT] see FactorINT TrialDiv variant\\
   
{\verb~SqFreeFactor~} &
      compute a squarefree factorization\\
   
{\verb~StableBBasis5~} &
      Stable Border Basis of ideal of points\\
   
{\verb~starting~} &
      list functions starting with a given string\\
   
{\verb~SymbolRange~} &
      range of symbols for the indeterminates of a PolyRing\\
   
{\verb~ThmProve [PROTOTYPE]~} &
      [PROTOTYPE] ThmProve\\
   
{\verb~VersionInfo~} &
      version and info about CoCoA\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{FUNCTION}
\label{FUNCTION}

      

% -- SECTION --------------------------------
\section{Introduction to FUNCTION}
\label{Introduction to FUNCTION}

        
The most important construct in CoCoA programming is the user-defined
function.  These functions take parameters, perform CoCoA commands,
and return values.  Collections of functions can be stored in text
files and read into CoCoA sessions using ``\verb&source&'' (\ref{source} pg.\pageref{source}).  To
prevent name conflicts of the type that are likely to arise if
functions are to be made available for use by others, the functions
can be collected in \textbf{packages}.
\par 
To learn about user functions, look up ``\verb&define&'' (\ref{define} pg.\pageref{define}) (online, enter
``\verb&?define&'').


% -- SECTION --------------------------------
\section{FUNCTIONs are first class objects}
\label{FUNCTIONs are first class objects}

        
In CoCoA-5 functions are "first class objects", and so may be passed
like any other value.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
-- The following function MyMax takes a function LessThan as parameter,
-- and returns the maximum of X and Y w.r.t. the ordering defined by the
-- function LessThan.

/**/  Define MyMax(LessThan, X, Y)
/**/    If LessThan(X, Y) Then Return Y; Else Return X; EndIf;
/**/  EndDefine;

-- Let's use MyMax by giving two different orderings.

/**/  Define CompareLT(X, Y)  Return LT(X) < LT(Y);  EndDefine;
/**/  Define CompareLC(X, Y)  Return LC(X) < LC(Y);  EndDefine;

/**/  use R ::= QQ[x,y,z];
/**/  MyMax(CompareLC, 3*x-y, 5*z-2);
5*z -2
/**/  MyMax(CompareLT, 3*x-y, 5*z-2);
3*x -y
\end{Verbatim}



% -- SECTION --------------------------------
\section{Commands and Functions for FUNCTION}
\label{Commands and Functions for FUNCTION}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~CallOnGroebnerFanIdeals~} &
      apply a function to Groebner fan ideals\\
   
{\verb~MaxBy~} &
      a maximum element of a list\\
   
{\verb~MinBy~} &
      a minimum element of a list\\
   
{\verb~ref~} &
      passing function parameters by reference\\
   
{\verb~return~} &
      exit from a function\\
   
{\verb~SortBy~} &
      sort a list\\
   
{\verb~SortedBy~} &
      sort a list\\
   
{\verb~TopLevel~} &
      make a top-level variable accessible inside a function\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning FUNCTION}
\label{Commands and Functions returning FUNCTION}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~define~} &
      define a function\\
   
{\verb~func~} &
      Anonymous function\\
   
{\verb~TopLevelFunctions~} &
      returns the functions available at top-level\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{TYPE}
\label{TYPE}

      

% -- SECTION --------------------------------
\section{Commands and Functions for TYPE}
\label{Commands and Functions for TYPE}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~describe~} &
      information about an object\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning TYPE}
\label{Commands and Functions returning TYPE}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~CurrentTypes~} &
      lists all data types\\
   
{\verb~shape~} &
      extended list of types involved in an expression\\
   
{\verb~type~} &
      the data type of an expression\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{RING}
\label{RING}

      

% -- SECTION --------------------------------
\section{Introduction to RING}
\label{Introduction to RING}

        
Rings, and especially polynomial rings, play a central role in CoCoA.
\par 
The user can define many rings, but at any time a single \textbf{current ring}
is active within the system.
\par 
Once a ring has been defined, the system can handle the following
mathematical objects defined over that ring:
\begin{verbatim}
 * elements of the ring
 * ideals
 * matrices
 * lists of objects
 * modules (submodules of a free module)
 * rings
\end{verbatim}
Variables containing ring-dependent objects such as polynomials,
ideals, and matrices are \textbf{labeled} by their ring.
Any operation on them is performed in their ring, independently of
what the current ring is.

\SeeAlso %---- SEE ALSO ----
  Polynomial Rings(\ref{Polynomial Rings} pg.\pageref{Polynomial Rings}), 
    Commands and Functions for RING(\ref{Commands and Functions for RING} pg.\pageref{Commands and Functions for RING}), 
    Commands and Functions returning RING(\ref{Commands and Functions returning RING} pg.\pageref{Commands and Functions returning RING})

% -- SECTION --------------------------------
\section{Polynomial Rings}
\label{Polynomial Rings}

        
CoCoA starts with the default (polynomial) ring ``\verb&R = QQ[x,y,z]&''.
Polynomial rings are created with the function ``\verb&NewPolyRing&'' (\ref{NewPolyRing} pg.\pageref{NewPolyRing}),
but there is a special simplyfied syntax working in most cases:
it must be preceded by the command ``\verb&use&'' (\ref{use} pg.\pageref{use}) or by the symbol ``\verb&::=&''
(or both)
\begin{verbatim}
     R ::= C[X:INDETS];           use C[X:INDETS];
     R ::= C[X:INDETS], O;        use C[X:INDETS], O;
\end{verbatim}
``\verb&R&'' is the identifier of a CoCoALanguage variable,
``\verb&C&'' is a RING,
``\verb&X&'' is an expression that defines the indeterminates,
``\verb&O&'' is a pre-defined ordering (``\verb&lex&'', ``\verb&deglex&'',
``\verb&degrevlex&'').  The default ordering is DegRevLex.
\par 
After the ring is defined using the above syntax, it can be made to be
the current ring with the command ``\verb&use&'' (\ref{use} pg.\pageref{use}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[a,b,c];  -- define and use the ring R
/**/  K := NewFractionField(R);
/**/  S ::= K[x,y], Lex;
/**/  CurrentRing;  -- the current ring is still R
RingWithID(21, "QQ[a,b,c]")
/**/  use S;  -- now the ring S is the current ring
/**/  CurrentRing;
RingWithID(23, "RingWithID(22)[x,y]")
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing}), 
    CurrentRing(\ref{CurrentRing} pg.\pageref{CurrentRing})

% -- SECTION --------------------------------
\section{Coefficient Rings}
\label{Coefficient Rings}

        
The coefficient ring for a CoCoA polynomial ring may be any ring ``\verb&R&'':
\begin{verbatim}
 1. ZZ: (arbitrarily large) integer numbers;
 2. QQ: (arbitrarily large) rational numbers;
 3. ZZ/(N);
 4. R[a,b,c];
 5. K(a,b,c);  ....
\end{verbatim}
The first two types of coefficients are based on the GNU-gmp library.
Some operations work only when coefficients are in a field
(a meaningful error message will be thrown).
\par 
NOTE: inside ``\verb&define/enddefine&'' the top-level variables 
``\verb&ZZ&'' (\ref{ZZ} pg.\pageref{ZZ}) and ``\verb&QQ&'' (\ref{QQ} pg.\pageref{QQ}) are not directly visible.
Use ``\verb&RingZZ()&'' or ``\verb&RingQQ()&'' instead (or import them
with ``\verb&TopLevel&'' (\ref{TopLevel} pg.\pageref{TopLevel})).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  R ::= QQ[x,y];    R;
/**/  S ::= ZZ/(5)[t];  S;
/**/  -- NOTE: "::=" for special syntax C[X], ":=" for normal function call
/**/  QQi ::= QQ[i];
/**/  K := NewQuotientRing(QQi, "i^2+1");
/**/  U ::= K[u,v];     U;
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CoeffRing(\ref{CoeffRing} pg.\pageref{CoeffRing})

% -- SECTION --------------------------------
\section{Indeterminates}
\label{Indeterminates}

        
An \textbf{indeterminate} is represented by an identifier followed by one or
more integer indices.  For example, ``\verb&x&'', ``\verb&alpha[1]&'', ``\verb&x[1,2,3]&'' are legal (and
different) indeterminates,
as is ``\verb&x[i, 2*i+1]&'' if ``\verb&i&'' is of type INT.
\par 
When creating a ring the indeterminates are listed separate by commas.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  use R ::= QQ[x[1..2,4..8],y[1..3],u,v];
/**/  Indets(R);
[x[1,4], x[1,5], x[1,6], x[1,7], x[1,8], x[2,4], x[2,5], x[2,6],
x[2,7], x[2,8], y[1], y[2], y[3], u, v]
-------------------------------
\end{Verbatim}



% -- SECTION --------------------------------
\section{Term Orderings}
\label{Term Orderings}

        
Polynomials are always sorted with respect to the ordering of their
base ring; this ordering is specified when the ring is created.  All
operations involving polynomials utilize and preserve this ordering.
There are mnemonic keywords for some predefined term-orderings;
otherwise a custom ordering defined by an "ordering matrix" can be
specified when using the function ``\verb&NewPolyRing&'' (\ref{NewPolyRing} pg.\pageref{NewPolyRing}).
\par 
The predefined term-orderings are:
\par 
 * standard-degree reverse lexicographic: ``\verb&DegRevLex&''  (default)
\par 
 * standard-degree lexicographic: ``\verb&DegLex&''
\par 
 * pure lexicographic: ``\verb&Lex&'' (no grading)
\par 
 * pure xel: ``\verb&Xel&'' (no grading)
\par 
If the indeterminates are given in the order ``\verb&x_1, ...,x_n&'',
then ``\verb&x_1 > ... > x_n&'' with respect to Lex, and
``\verb&x_1 < ... < x_n&'' with respect to Xel.

\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
-- Specify the ordering when you create the ring:
/**/  P ::= QQ[x,y,z];             --> default is DegRevLex
/**/  P ::= QQ[x,y,z], DegRevLex;  --> same as above
/**/  P ::= QQ[x,y,z], lex;
/**/  P ::= QQ[x,y,z], DegLex;
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewPolyRing(\ref{NewPolyRing} pg.\pageref{NewPolyRing}), 
    OrdMat(\ref{OrdMat} pg.\pageref{OrdMat}), 
    elim(\ref{elim} pg.\pageref{elim})

% -- SECTION --------------------------------
\section{Module Orderings}
\label{Module Orderings}

        
***** NOT YET UPDATED TO CoCoA-5 *****
\par 
First we recall the definition of a module term-ordering. We assume
that all our free modules have finite rank and are of the type $M = R^r$
where R is a polynomial ring with n indeterminates.  Let
$[e_i|i=1,...,r]$ be the canonical basis of M. A \textbf{term} of M is an
element of the form $Te_i$ where T belongs to the set T(R) of the terms
of R.  Hence the set T(M), of the terms of M, is in one-to-one
correspondence with the Cartesian product, $T(R)\times [1,...,r]$.
\par 
A \textbf{module term-ordering} is defined as a total ordering $>$ on T(M)
such that for all ``\verb&T, T_1, T_2&'' in T(R), with T not equal to 1, and for
all i, j in {1,...,r},
\begin{verbatim}
   (1)  T * T_1 * e_i > T_1 * e_i
   (2)  T_1 * e_i > T_2 * e_j  =>  T * T_1 * e_i > T * T_2 * e_j
\end{verbatim}
Each term-ordering on the current ring induces several term-orderings
on a free module.  CoCoA allows the user to choose between the
following:
\par 
   * the ordering called ``\verb&ToPos&'' (which is the default one) defined by:
\begin{verbatim}
      T_1 * e_i > T_2 * e_j <=>  T_1 > T_2 in R
                                 or, if  T_1 = T_2 , i < j
\end{verbatim}
   * the ordering called ``\verb&PosTo&'' defined by:
\begin{verbatim}
       T_1 * e_i > T_2 * e_j <=> i < j
                                 or, if i = j, T_1 > T_2 in R .
\end{verbatim}

The leading term of the vector $(x,y^2)$ with respect
to two different module term-orderings:
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
  use R ::= QQ[x,y], ToPos;
  LT(Vector(x,y^2));
Vector(0, y^2)
-------------------------------
  use R ::= QQ[x,y], PosTo;
  LT(Vector(x,y^2));
Vector(x, 0)
-------------------------------
\end{Verbatim}



% -- SECTION --------------------------------
\section{Quotient Rings}
\label{Quotient Rings}

        
If ``\verb&R&'' is a ring and ``\verb&I&'' is an ideal (in ``\verb&R&'')
then ``\verb&R/I&'' creates the corresponding quotient ring.  There is
a convenient shorthand for quotients of ``\verb&ZZ&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use ZZ/(11)[x];
/**/  (x+3)^11;
x^11 + 3
/**/  use R ::= QQ[x,y];
/**/  I := ideal(x^3+y^3, x^2*y-y^2*x);
/**/  Q := R/I;
/**/  HilbertFn(Q);  -- the Hilbert function for Q
H(0) = 1
H(1) = 2
H(2) = 3
H(3) = 2
H(4) = 1
H(t) = 0   for t >= 5
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  NewQuotientRing(\ref{NewQuotientRing} pg.\pageref{NewQuotientRing})

% -- SECTION --------------------------------
\section{Commands and Functions for RING}
\label{Commands and Functions for RING}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~AffHilbertFn~} &
      the affine Hilbert function\\
   
{\verb~AffHilbertSeries~} &
      the affine Hilbert-Poincare series\\
   
{\verb~ApproxPointsNBM~} &
      Numerical Border Basis of ideal of points\\
   
{\verb~ArrBoolean~} &
      boolean arrangement\\
   
{\verb~ArrBraid~} &
      braid arrangement\\
   
{\verb~ArrCatalanA~} &
      Catalan arrangement of type A\\
   
{\verb~ArrCatalanB~} &
      Catalan arrangement of type B\\
   
{\verb~ArrCatalanD~} &
      Catalan arrangement of type D\\
   
{\verb~ArrGraphical~} &
      graphical arrangement\\
   
{\verb~ArrShiA~} &
      Shi arrangement of type A\\
   
{\verb~ArrShiB~} &
      Shi arrangement of type B\\
   
{\verb~ArrShiCatalanA~} &
      Shi-Catalan arrangement of type A with multiplicities\\
   
{\verb~ArrShiCatalanB~} &
      Shi-Catalan arrangement of type B with given multiplicities\\
   
{\verb~ArrShiCatalanD~} &
      Shi-Catalan arrangement of type D with given multiplicities\\
   
{\verb~ArrShiD~} &
      Shi arrangement of type D\\
   
{\verb~ArrSignedGraphical~} &
      signed graphical arrangement\\
   
{\verb~ArrTypeB~} &
      reflection arrangement of type B\\
   
{\verb~ArrTypeD~} &
      reflection arrangement of type D\\
   
{\verb~BaseRing~} &
      the base ring of a ring\\
   
{\verb~BettiDiagram~} &
      the diagram of the graded Betti numbers\\
   
{\verb~BringIn~} &
      bring in objects from another ring\\
   
{\verb~CanonicalHom~} &
      canonical homomorphism\\
   
{\verb~ChainCanonicalHom~} &
      canonical homomorphism\\
   
{\verb~characteristic~} &
      the characteristic of a ring\\
   
{\verb~CoeffEmbeddingHom~} &
      returns the coefficient embedding homomorphism of a polynomial ring\\
   
{\verb~CoeffRing~} &
      the ring of coefficients of a polynomial ring\\
   
{\verb~ColMat~} &
      single column matrix\\
   
{\verb~DefiningIdeal~} &
      defining ideal of a quotient ring\\
   
{\verb~DensePoly~} &
      the sum of all power-products of a given degree\\
   
{\verb~depth~} &
      Depth of a module\\
   
{\verb~DiagMat~} &
      matrix with given diagonal\\
   
{\verb~dim~} &
      the dimension of a (quotient) ring\\
   
{\verb~EmbeddingHom~} &
      returns the embedding homomorphism of a fraction field\\
   
{\verb~GenericPoints~} &
      random projective points\\
   
{\verb~GradingMat~} &
      matrix of generalized weights for indeterminates\\
   
{\verb~HilbertFn~} &
      the Hilbert function\\
   
{\verb~HilbertPoly~} &
      the Hilbert polynomial\\
   
{\verb~HilbertSeries~} &
      the Hilbert-Poincare series\\
   
{\verb~HilbertSeriesMultiDeg~} &
      the Hilbert-Poincare series wrt a multigrading\\
   
{\verb~HVector~} &
      the h-vector of a module or quotient object\\
   
{\verb~ideal~} &
      ideal generated by list\\
   
{\verb~IdealOfPoints~} &
      ideal of a set of affine points\\
   
{\verb~IdealOfProjectivePoints~} &
      ideal of a set of projective points\\
   
{\verb~IdentityMat~} &
      the identity matrix\\
   
{\verb~implicit~} &
      implicitization\\
   
{\verb~ImplicitHypersurface~} &
      implicitization of hypersurface\\
   
{\verb~indet~} &
      individual indeterminates\\
   
{\verb~indets~} &
      list of indeterminates in a PolyRing\\
   
{\verb~IndetSymbols~} &
      the names of the indeterminates in a PolyRing\\
   
{\verb~InducedHom~} &
      homomorphism induced by a homomorphism\\
   
{\verb~IsCommutative~} &
      test whether a ring is commutative\\
   
{\verb~IsField~} &
      test whether a ring is a field\\
   
{\verb~IsFiniteField~} &
      test whether a ring is a finite field\\
   
{\verb~IsFractionField~} &
      test whether a ring is a fraction field\\
   
{\verb~IsIntegralDomain~} &
      test whether a ring is integral\\
   
{\verb~IsPolyRing~} &
      test whether a ring is a polynomial ring\\
   
{\verb~IsQQ~} &
      test whether a ring is the ring of rationals\\
   
{\verb~IsQuotientRing~} &
      test whether a ring is a quotient ring\\
   
{\verb~IsStdGraded~} &
      checks if the grading is standard\\
   
{\verb~IsTrueGCDDomain~} &
      test whether a ring is a true GCD domain\\
   
{\verb~IsZZ~} &
      test whether a ring is the ring of integers\\
   
{\verb~LogCardinality~} &
      extension degree of a finite field\\
   
{\verb~MakeTerm~} &
      returns a monomial (power-product) with given exponents\\
   
{\verb~matrix~} &
      convert a list into a matrix\\
   
{\verb~multiplicity~} &
      the multiplicity (degree) of a ring\\
   
{\verb~NewFractionField~} &
      create a new fraction field\\
   
{\verb~NewFreeModule~} &
      create a new FreeModule\\
   
{\verb~NewMat~} &
      Zero matrix\\
   
{\verb~NewPolyRing~} &
      create a new PolyRing\\
   
{\verb~NewQuotientRing~} &
      create a new quotient ring\\
   
{\verb~NewWeylAlgebra~} &
      create a new Weyl Algebra\\
   
{\verb~NumIndets~} &
      number of indeterminates\\
   
{\verb~one~} &
      one of a ring\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~OrdMat~} &
      matrix defining a term-ordering\\
   
{\verb~PolyAlgebraHom~} &
      homomorphism of polynomial algebras\\
   
{\verb~PolyRingHom~} &
      homomorphism of polynomial rings\\
   
{\verb~PrintBettiDiagram~} &
      print the diagram of the graded Betti numbers\\
   
{\verb~PrintSectionalMatrix~} &
      print sectional matrix\\
   
{\verb~QQEmbeddingHom~} &
      returns the homomorphism QQ --> R\\
   
{\verb~QuotientingHom~} &
      returns the projection homomorphism into a quotient ring\\
   
{\verb~RandomLinearForm~} &
      random linear form in polynomial ring\\
   
{\verb~RandomSparseNonSing01Mat~} &
      random sparse non-singular (0,1) matrix\\
   
{\verb~RandomUnimodularMat~} &
      random unimodular matrix\\
   
{\verb~reg~} &
      Castelnuovo-Mumford regularity of a module\\
   
{\verb~RegularityIndex~} &
      regularity index of a Hilbert function or series\\
   
{\verb~RingElem~} &
      convert an expression into a RINGELEM\\
   
{\verb~RingElemList, RingElems~} &
      convert expressions into a LIST of RINGELEM\\
   
{\verb~RingID~} &
      identification for ring\\
   
{\verb~RowMat~} &
      single row matrix\\
   
{\verb~SectionalMatrix~} &
      sectional matrix \\
   
{\verb~SymmetricPolys~} &
      list of symmetric polynomials\\
   
{\verb~zero~} &
      zero of a ring\\
   
{\verb~ZeroMat~} &
      matrix filled with 0\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning RING}
\label{Commands and Functions returning RING}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~BaseRing~} &
      the base ring of a ring\\
   
{\verb~codomain~} &
      codomain of a homomorphism\\
   
{\verb~CoeffRing~} &
      the ring of coefficients of a polynomial ring\\
   
{\verb~CurrentRing~} &
      the current ring\\
   
{\verb~domain~} &
      domain of a homomorphism\\
   
{\verb~NewFractionField~} &
      create a new fraction field\\
   
{\verb~NewPolyRing~} &
      create a new PolyRing\\
   
{\verb~NewQuotientRing~} &
      create a new quotient ring\\
   
{\verb~NewRingTwinFloat~} &
      create a new twin-float ring\\
   
{\verb~NewWeylAlgebra~} &
      create a new Weyl Algebra\\
   
{\verb~NewZZmod~} &
      create a new finite ring (integers mod N)\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~QQ~} &
      the ring of rationals\\
   
{\verb~RingOf~} &
      the ring of the object\\
   
{\verb~RingQQ~} &
      the ring of rationals\\
   
{\verb~RingQQt~} &
      pre-defined polynomial rings\\
   
{\verb~RingsOf~} &
      list of the rings of an object\\
   
{\verb~RingZZ~} &
      the ring of integers\\
   
{\verb~ZZ~} &
      the ring of integers\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{RINGHOM}
\label{RINGHOM}

      

% -- SECTION --------------------------------
\section{Introduction to RINGHOM}
\label{Introduction to RINGHOM}

        
A value of type INT or RAT can be automatically mapped into
any ring.  The way to "move" a RINGELEM value from one ring to
another is to apply a ring homomorphism; the homomorphism can also
transform the value as it is mapped.  \textbf{Think mathematically!} ;-)
\par 
Common ways to create a ring homomorphism include ``\verb&CanonicalHom&'' (\ref{CanonicalHom} pg.\pageref{CanonicalHom}),
``\verb&PolyRingHom&'' (\ref{PolyRingHom} pg.\pageref{PolyRingHom}) and ``\verb&PolyAlgebraHom&'' (\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}).
\par 
The syntax mimics that of a function call (as in mathematical formulas).
Given a RINGHOM ``\verb&phi&'' just type
  ``\verb&phi(x)&''        if ``\verb&x&'' is a RINGELEM,
  ``\verb&phi(x)&''        if ``\verb&x&'' is a LIST or MAT; applies ``\verb&phi&'' to each entry.
An ideal cannot be mapped directly, you must instead map the generators
individually: \textit{e.g.} ``\verb&ideal(phi(gens(I)))&''.
\par 
There are also a few handy shortcuts which automatically determine and
apply a homomorphism.  The functions ``\verb&matrix&'' (\ref{matrix} pg.\pageref{matrix}) and ``\verb&RingElem&'' (\ref{RingElem} pg.\pageref{RingElem}) will map
the argument into the given ring (\textit{e.g.} ``\verb&matrix(R, M)&'' maps ``\verb&M&'' into a
new matrix in the ring ``\verb&R&'').  Another shortcut is ``\verb&BringIn&'' (\ref{BringIn} pg.\pageref{BringIn}) (easy, but slow).
\par 
NOTE: all CoCoA functions should be smart enough to take into account
the RING in which their value was defined, for example
``\verb&GBasis&'' (\ref{GBasis} pg.\pageref{GBasis}), ``\verb&LT&'' (\ref{LT} pg.\pageref{LT}), ``\verb&wdeg&'' (\ref{wdeg} pg.\pageref{wdeg}),...

\SeeAlso %---- SEE ALSO ----
  Commands and Functions for RINGHOM(\ref{Commands and Functions for RINGHOM} pg.\pageref{Commands and Functions for RINGHOM}), 
    Commands and Functions returning RINGHOM(\ref{Commands and Functions returning RINGHOM} pg.\pageref{Commands and Functions returning RINGHOM}), 
    CanonicalHom(\ref{CanonicalHom} pg.\pageref{CanonicalHom}), 
    PolyAlgebraHom(\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}), 
    PolyRingHom(\ref{PolyRingHom} pg.\pageref{PolyRingHom}), 
    matrix(\ref{matrix} pg.\pageref{matrix}), 
    RingElem(\ref{RingElem} pg.\pageref{RingElem}), 
    BringIn(\ref{BringIn} pg.\pageref{BringIn})

% -- SECTION --------------------------------
\section{Composition of RINGHOM}
\label{Composition of RINGHOM}

        
Two RINGHOM ``\verb&phi: R-->S&'' and ``\verb&psi: S-->T&''
can be composed.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  R := NewPolyRing(QQ, "a");
/**/  S := NewFractionField(R);  -- QQ(a)
/**/  T := NewPolyRing(S, "x");
/**/  phi := CanonicalHom(R,S);
/**/  psi := CanonicalHom(S,T);
/**/  theta := psi(phi);
/**/  theta(RingElem(R, "a^2+a-1"));
a^2 +a -1
/**/  RingOf(theta(RingElem(R, "a^2+a-1"))) = T;
true
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  CanonicalHom(\ref{CanonicalHom} pg.\pageref{CanonicalHom}), 
    InducedHom(\ref{InducedHom} pg.\pageref{InducedHom})

% -- SECTION --------------------------------
\section{Commands and Functions for RINGHOM}
\label{Commands and Functions for RINGHOM}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~codomain~} &
      codomain of a homomorphism\\
   
{\verb~domain~} &
      domain of a homomorphism\\
   
{\verb~InducedHom~} &
      homomorphism induced by a homomorphism\\
   
{\verb~IsInImage~} &
      check if a RINGELEM is in image of RINGHOM\\
   
{\verb~IsInjective~} &
      check if a RINGHOM is injective\\
   
{\verb~IsSurjective~} &
      check if a RINGHOM is surjective\\
   
{\verb~ker~} &
      Kernel of a homomorphism\\
   
{\verb~PolyRingHom~} &
      homomorphism of polynomial rings\\
   
{\verb~preimage0~} &
      preimage of a RINGELEM\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning RINGHOM}
\label{Commands and Functions returning RINGHOM}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~CanonicalHom~} &
      canonical homomorphism\\
   
{\verb~ChainCanonicalHom~} &
      canonical homomorphism\\
   
{\verb~CoeffEmbeddingHom~} &
      returns the coefficient embedding homomorphism of a polynomial ring\\
   
{\verb~EmbeddingHom~} &
      returns the embedding homomorphism of a fraction field\\
   
{\verb~InducedHom~} &
      homomorphism induced by a homomorphism\\
   
{\verb~PolyAlgebraHom~} &
      homomorphism of polynomial algebras\\
   
{\verb~PolyRingHom~} &
      homomorphism of polynomial rings\\
   
{\verb~QQEmbeddingHom~} &
      returns the homomorphism QQ --> R\\
   
{\verb~QuotientingHom~} &
      returns the projection homomorphism into a quotient ring\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{RINGELEM}
\label{RINGELEM}

      

% -- SECTION --------------------------------
\section{Introduction to RINGELEM}
\label{Introduction to RINGELEM}

        
An object of type RINGELEM in CoCoA represents an element of a ring.
\par 
To fix terminology about polynomials (elements of a polynomial ring):
a polynomial is a sum of terms; each term is the product of a
coefficient and power-product, and a power-product is a product of
powers of indeterminates.
\par 
In English it is standard to use \textbf{monomial} to mean a power-product,
however, in other languages, such as Italian, monomial connotes a
power-product multiplied by a scalar.  In the interest of world peace, we
will use the term power-product in those cases where confusion may arise.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use P ::= QQ[x,y,z];
/**/  f := 3*x*y*z + x*y^2;
/**/  f;
x*y^2 + 3*x*y*z
-------------------------------
/**/  use P ::= QQ[x[1..5]];
/**/  sum([x[N]^2 | N in 1..5]);
x[1]^2 + x[2]^2 + x[3]^2 + x[4]^2 + x[5]^2
-------------------------------
\end{Verbatim}

CoCoA always keeps polynomials ordered with respect to the
term-orderings of their corresponding rings.
\par 
The following algebraic operations on polynomials are supported:
\begin{verbatim}
  F^N, +F, -F, F*G, F/G if G divides F, F+G, F-G,
\end{verbatim}
where F, G are polynomials and N is an integer.  The result may be a
rational function.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  F := x^2 +x*y;
/**/  G := x;
/**/  F/G;
x + y

-- /**/  F/(x+z); --> !!! ERROR !!! as expected: Inexact division

/**/  F^2;
x^4 +2*x^3*y +x^2*y^2
\end{Verbatim}



% -- SECTION --------------------------------
\section{Evaluation of Polynomials}
\label{Evaluation of Polynomials}

        
The cleanest and most efficient way to evaluate polynomials is
defining the appropriate ``\verb&PolyAlgebraHom&'' (\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}).
However there are some handy shortcuts: ``\verb&subst&'' (\ref{subst} pg.\pageref{subst}) and ``\verb&eval&'' (\ref{eval} pg.\pageref{eval}).
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y,z];
/**/  f := x+y+z;  --> let x=2 and y=1 in f
/**/  phi := PolyAlgebraHom(R, R, [2,1,z]);  phi(f);
z +3
/**/  eval(f, [2,1]);
z +3
/**/  subst(f, [[x,2],[y,1]]);
z +3
\end{Verbatim}


\SeeAlso %---- SEE ALSO ----
  PolyAlgebraHom(\ref{PolyAlgebraHom} pg.\pageref{PolyAlgebraHom}), 
    eval(\ref{eval} pg.\pageref{eval}), 
    subst(\ref{subst} pg.\pageref{subst})

% -- SECTION --------------------------------
\section{Commands and Functions for RINGELEM}
\label{Commands and Functions for RINGELEM}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~abs~} &
      absolute value of a number\\
   
{\verb~ApproxSolve~} &
      Approximate real solutions for polynomial system\\
   
{\verb~ArrCone~} &
      cone of an arrangement of hyperplanes\\
   
{\verb~ArrDeletion~} &
      deletes a hyperplane from a list of hyperplanes\\
   
{\verb~ArrDerModule~} &
      set of generators of the module of logarithmic derivations of an arrangement of hyperplanes\\
   
{\verb~ArrExponents~} &
      exponents of a free arrangement of hyperplanes\\
   
{\verb~ArrRestriction~} &
      arrangement of hyperplanes A restricted to a hyperplane\\
   
{\verb~AsINT~} &
      convert into an INT\\
   
{\verb~AsRAT~} &
      convert into a RAT\\
   
{\verb~binomial~} &
      binomial coefficient\\
   
{\verb~CanonicalRepr~} &
      representative of a class in a quotient ring\\
   
{\verb~CharPoly~} &
      characteristic polynomial of a matrix\\
   
{\verb~ChebyshevPoly~} &
      Orthogonal Polynomials: Chebyshev, Hermite, Laguerre\\
   
{\verb~ClearDenom~} &
      clear common denominator of a polynomial with rational coeffs\\
   
{\verb~CoeffHeight~} &
      the maximum of the absolute values of the coefficients of a polynomial\\
   
{\verb~coefficients~} &
      list of coefficients of a polynomial\\
   
{\verb~CoefficientsWRT~} &
      list of coeffs and PPs of a poly wrt indet or list of indets\\
   
{\verb~CoeffListWRT~} &
      list of coefficients of a polynomial wrt an indet\\
   
{\verb~CoeffListWRTSupport~} &
      list of coefficients of a polynomial wrt a power-product basis\\
   
{\verb~CoeffOfTerm~} &
      coefficient of a term of a polynomial\\
   
{\verb~CommonDenom~} &
      Common denominator of a polynomial with rational coefficients\\
   
{\verb~ComputeElimFirst~} &
      ComputeElimFirst\\
   
{\verb~ConstantCoeff~} &
      constant coefficient of a polynomial\\
   
{\verb~content~} &
      content of a polynomial\\
   
{\verb~ContentFreeFactor~} &
      factorization of multivariate polynomial into content-free factors\\
   
{\verb~ContentWRT~} &
      content of a polynomial wrt and indet or a list of indets\\
   
{\verb~CoprimeFactorBasis~} &
      determine coprime factor base for a set of integers or ring elements\\
   
{\verb~CRTPoly~} &
      Chinese Remainder Theorem on polynomial coefficients\\
   
{\verb~cyclotomic~} &
      n-th cyclotomic polynomial\\
   
{\verb~DecimalStr~} &
      convert rational number to decimal string\\
   
{\verb~deg~} &
      the standard degree of a polynomial or moduleelem\\
   
{\verb~den~} &
      denominator\\
   
{\verb~deriv~} &
      the derivative of a polynomial or rational function\\
   
{\verb~DerivationAction~} &
      Action of a derivation\\
   
{\verb~DF~} &
      the degree form of a polynomial\\
   
{\verb~DicksonPoly~} &
      Dickson polynomial\\
   
{\verb~discriminant~} &
      the discriminant of a polynomial\\
   
{\verb~DivAlg~} &
      division algorithm\\
   
{\verb~eigenfactors~} &
      eigenfactors of a matrix\\
   
{\verb~eigenvectors~} &
      eigenvalues and eigenvectors of a matrix\\
   
{\verb~elim~} &
      eliminate variables\\
   
{\verb~eval~} &
      substitute numbers or polynomials for indeterminates\\
   
{\verb~EvalQuasiPoly~} &
      Evaluate a quasi-polynomial at an integer\\
   
{\verb~exponents~} &
      the list of exponents of the leading term of a polynomial\\
   
{\verb~factor~} &
      factor a polynomial\\
   
{\verb~FixedDivisor~} &
      compute (integer) fixed divisor for polynomial\\
   
{\verb~FloatApprox~} &
      approx. of rational number of the form $M*2^E$\\
   
{\verb~FloatStr~} &
      convert rational number to a decimal string\\
   
{\verb~FrbAlexanderDual~} &
      Alexander Dual of monomial ideals\\
   
{\verb~gcd~} &
      greatest common divisor\\
   
{\verb~GenRepr~} &
      representation in terms of generators\\
   
{\verb~GensJacobian~} &
      set of generators of the Jacobian ideal of a polynomial\\
   
{\verb~GinJacobian~} &
      generic initial ideal of the Jacobian ideal of a polynomial\\
   
{\verb~graeffe~} &
      graeffe transformation (squares the roots)\\
   
{\verb~HermitePoly~} &
      Orthogonal Polynomials: Chebyshev, Hermite, Laguerre\\
   
{\verb~homog~} &
      homogenize wrt an indeterminate\\
   
{\verb~HomogCompt~} &
      homogeneous part of given degree\\
   
{\verb~ideal~} &
      ideal generated by list\\
   
{\verb~IndetIndex~} &
      index of an indeterminate\\
   
{\verb~IndetName~} &
      the name of an indeterminate\\
   
{\verb~IndetsProd~} &
      (product of) indeterminates actually in a polynomial\\
   
{\verb~IndetSubscripts~} &
      the indices in the name of an indeterminate\\
   
{\verb~interreduce~} &
      interreduce a list of polynomials\\
   
{\verb~interreduced~} &
      interreduce a list of polynomials\\
   
{\verb~IsArrFree~} &
      checks if the arrangement is free\\
   
{\verb~IsConstant~} &
      checks if a ringelem is in the coefficient ring\\
   
{\verb~IsCoprime~} &
      checks if t1 is coprime with t2\\
   
{\verb~IsDivisible~} &
      checks if A is divisible by B\\
   
{\verb~IsElem~} &
      checks if A is an element of B\\
   
{\verb~IsEvenPoly, IsOddPoly~} &
      test whether a polynomial is even or odd as a function\\
   
{\verb~IsHomog~} &
      test whether given polynomials are homogeneous\\
   
{\verb~IsIn~} &
      check if one object is contained in another\\
   
{\verb~IsIndet~} &
      check if argument is an indeterminate\\
   
{\verb~IsIndetPosPower~} &
      check if argument is a power of an indeterminate\\
   
{\verb~IsInImage~} &
      check if a RINGELEM is in image of RINGHOM\\
   
{\verb~IsInRadical~} &
      check if a polynomial (or ideal) is in a radical\\
   
{\verb~IsInteger~} &
      check if a RINGELEM is integer\\
   
{\verb~IsInvertible~} &
      check if a RINGELEM is invertible\\
   
{\verb~IsIrred~} &
      check if a RINGELEM is irreducible\\
   
{\verb~IsMinusOne~} &
      test whether an object is -1\\
   
{\verb~IsOne~} &
      test whether an object is one\\
   
{\verb~IsPthPower~} &
      p-th power test\\
   
{\verb~IsRational~} &
      check if a RINGELEM is rational\\
   
{\verb~IsSqFree~} &
      check if an INT or RINGELEM is square-free\\
   
{\verb~IsTerm~} &
      checks if the argument is a term\\
   
{\verb~IsZero~} &
      test whether an object is zero\\
   
{\verb~IsZeroDivisor~} &
      test whether a RINGELEM is a zero-divisor\\
   
{\verb~JacobianMat~} &
      the Jacobian matrix of a list of polynomials\\
   
{\verb~LaguerrePoly~} &
      Orthogonal Polynomials: Chebyshev, Hermite, Laguerre\\
   
{\verb~LC~} &
      the leading coefficient of a polynomial or ModuleElem\\
   
{\verb~lcm~} &
      least common multiple\\
   
{\verb~LF~} &
      the leading form of a polynomial or an ideal\\
   
{\verb~LinearSimplify~} &
      simplifying linear substitution for a univariate poly over QQ\\
   
{\verb~LM~} &
      the leading monomial of a polynomial or ModuleElem\\
   
{\verb~LPP~} &
      the leading power-product of a polynomial or ModuleElem\\
   
{\verb~LT~} &
      the leading term of an object\\
   
{\verb~MantissaAndExponent2~} &
      convert rational number to a binary float\\
   
{\verb~max~} &
      a maximum element of a sequence or list\\
   
{\verb~min~} &
      a minimum element of a sequence or list\\
   
{\verb~MinGBoverZZ [PROTOTYPE]~} &
      [PROTOTYPE] minimal Groebner basis of polys over ZZ\\
   
{\verb~MinPoly~} &
      minimal polynomial of a matrix\\
   
{\verb~MinPolyQuot~} &
      minimal polynomial in quotient ring\\
   
{\verb~MinPowerInIdeal~} &
      the mininum power of a polynomial is an ideal\\
   
{\verb~monic~} &
      divide polynomials by their leading coefficients\\
   
{\verb~monomials~} &
      the list of monomials of a polynomial\\
   
{\verb~MultiArrRestrictionZiegler~} &
      Ziegler multirestriction of the arrangement of hyperplanes  wrt a hyperplane\\
   
{\verb~MultiplicationMat~} &
      multiplication matrix of a ringelem\\
   
{\verb~NewMatFilled~} &
      matrix filled with value\\
   
{\verb~NF~} &
      normal form\\
   
{\verb~NmzEhrhartRing~} &
      Ehrhart ring\\
   
{\verb~NmzIntClosureMonIdeal~} &
      integral closure of a monomial ideal\\
   
{\verb~NmzIntClosureToricRing~} &
      integral closure of a toric ring\\
   
{\verb~NmzNormalToricRing~} &
      normalization of a toric ring\\
   
{\verb~NR~} &
      normal reduction\\
   
{\verb~num~} &
      numerator\\
   
{\verb~NumRealRoots~} &
      number of real roots of a polynomial\\
   
{\verb~NumTerms~} &
      number of terms in a polynomial\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~PerpIdealOfForm~} &
      Ideal of derivations annihilating a form\\
   
{\verb~power~} &
      compute a power\\
   
{\verb~preimage0~} &
      preimage of a RINGELEM\\
   
{\verb~prim~} &
      primitive part of a polynomial\\
   
{\verb~product~} &
      the product of the elements of a list\\
   
{\verb~PthRoot~} &
      Compute p-th root\\
   
{\verb~QZP~} &
      change field for polynomials and ideals\\
   
{\verb~radical~} &
      radical of an ideal\\
   
{\verb~RationalSolve~} &
      Rational solutions for 0-dim polynomial system\\
   
{\verb~RationalSolveHomog~} &
      Rational solutions for 0-dim polynomial system\\
   
{\verb~RatReconstructPoly~} &
      Rational reconstruction of polynomial coefficents\\
   
{\verb~RealRoots~} &
      real roots of a univariate polynomial\\
   
{\verb~RealRootsApprox~} &
      approximations to the real roots of a univariate poly\\
   
{\verb~resultant~} &
      the resultant of two polynomials\\
   
{\verb~RingElem~} &
      convert an expression into a RINGELEM\\
   
{\verb~RingOf~} &
      the ring of the object\\
   
{\verb~RingsOf~} &
      list of the rings of an object\\
   
{\verb~RootBound~} &
      bound on roots of a polynomial over QQ\\
   
{\verb~RootBoundTransform~} &
      transform of a polynomial, helpful for checking RootBound\\
   
{\verb~ScientificStr~} &
      convert integer/rational to a floating-point string\\
   
{\verb~SetEntry~} &
      set an entry into a matrix\\
   
{\verb~SolomonTeraoIdeal~} &
      Solomon-Terao ideal of an arrangement of hyperplanes wrt a poly\\
   
{\verb~SqFreeFactor~} &
      compute a squarefree factorization\\
   
{\verb~SturmSeq~} &
      Sturm sequence of a univariate polynomial\\
   
{\verb~subst~} &
      substitute values for indeterminates\\
   
{\verb~sum~} &
      the sum of the elements of a list\\
   
{\verb~support~} &
      the list of terms of a polynomial or moduleelem\\
   
{\verb~SwinnertonDyerPoly~} &
      compute Swinnerton-Dyer polynomial with given roots\\
   
{\verb~SylvesterMat~} &
      the Sylvester matrix of two polynomials\\
   
{\verb~syz~} &
      syzygy modules\\
   
{\verb~ThmProve [PROTOTYPE]~} &
      [PROTOTYPE] ThmProve\\
   
{\verb~UnivariateIndetIndex~} &
      the index of the indeterminate of a univariate polynomial\\
   
{\verb~wdeg~} &
      multi-degree of a polynomial\\
   
{\verb~ZPQ~} &
      change field for polynomials and ideals\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning RINGELEM}
\label{Commands and Functions returning RINGELEM}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~abs~} &
      absolute value of a number\\
   
{\verb~ArrCharPoly~} &
      characteristic polynomial of an arrangement of hyperplanes\\
   
{\verb~ArrPoincarePoly~} &
      Poincare polynomial of an arrangement of hyperplanes\\
   
{\verb~ArrTuttePoly~} &
      Tutte polynomial of an arrangement of hyperplanes\\
   
{\verb~binomial~} &
      binomial coefficient\\
   
{\verb~CanonicalRepr~} &
      representative of a class in a quotient ring\\
   
{\verb~CharPoly~} &
      characteristic polynomial of a matrix\\
   
{\verb~ChebyshevPoly~} &
      Orthogonal Polynomials: Chebyshev, Hermite, Laguerre\\
   
{\verb~ClearDenom~} &
      clear common denominator of a polynomial with rational coeffs\\
   
{\verb~CoeffHeight~} &
      the maximum of the absolute values of the coefficients of a polynomial\\
   
{\verb~CoeffListWRT~} &
      list of coefficients of a polynomial wrt an indet\\
   
{\verb~CoeffListWRTSupport~} &
      list of coefficients of a polynomial wrt a power-product basis\\
   
{\verb~CoeffOfTerm~} &
      coefficient of a term of a polynomial\\
   
{\verb~CommonDenom~} &
      Common denominator of a polynomial with rational coefficients\\
   
{\verb~ComputeElimFirst~} &
      ComputeElimFirst\\
   
{\verb~ConstantCoeff~} &
      constant coefficient of a polynomial\\
   
{\verb~content~} &
      content of a polynomial\\
   
{\verb~ContentWRT~} &
      content of a polynomial wrt and indet or a list of indets\\
   
{\verb~cyclotomic~} &
      n-th cyclotomic polynomial\\
   
{\verb~den~} &
      denominator\\
   
{\verb~DensePoly~} &
      the sum of all power-products of a given degree\\
   
{\verb~DenSigma~} &
      den of ideal, wrt to ordering sigma\\
   
{\verb~deriv~} &
      the derivative of a polynomial or rational function\\
   
{\verb~det~} &
      the determinant of a matrix\\
   
{\verb~DF~} &
      the degree form of a polynomial\\
   
{\verb~DicksonPoly~} &
      Dickson polynomial\\
   
{\verb~discriminant~} &
      the discriminant of a polynomial\\
   
{\verb~eigenfactors~} &
      eigenfactors of a matrix\\
   
{\verb~EvalQuasiPoly~} &
      Evaluate a quasi-polynomial at an integer\\
   
{\verb~FirstNonZero~} &
      the first non-zero entry in a MODULEELEM\\
   
{\verb~FirstNonZeroPosn~} &
      the position of the first non-zero entry in a MODULEELEM\\
   
{\verb~FixedDivisor~} &
      compute (integer) fixed divisor for polynomial\\
   
{\verb~FrobeniusNormSq~} &
      Frobenius norm of a matrix\\
   
{\verb~gcd~} &
      greatest common divisor\\
   
{\verb~graeffe~} &
      graeffe transformation (squares the roots)\\
   
{\verb~GraverBasis~} &
      Graver basis\\
   
{\verb~HermitePoly~} &
      Orthogonal Polynomials: Chebyshev, Hermite, Laguerre\\
   
{\verb~HilbertPoly~} &
      the Hilbert polynomial\\
   
{\verb~homog~} &
      homogenize wrt an indeterminate\\
   
{\verb~HomogCompt~} &
      homogeneous part of given degree\\
   
{\verb~ImplicitHypersurface~} &
      implicitization of hypersurface\\
   
{\verb~indet~} &
      individual indeterminates\\
   
{\verb~IndetsProd~} &
      (product of) indeterminates actually in a polynomial\\
   
{\verb~Interpolate~} &
      interpolating polynomial\\
   
{\verb~interreduced~} &
      interreduce a list of polynomials\\
   
{\verb~InverseSystem~} &
      Inverse system of an ideal of derivations\\
   
{\verb~JanetBasis~} &
      the Janet basis of an ideal\\
   
{\verb~LaguerrePoly~} &
      Orthogonal Polynomials: Chebyshev, Hermite, Laguerre\\
   
{\verb~LC~} &
      the leading coefficient of a polynomial or ModuleElem\\
   
{\verb~lcm~} &
      least common multiple\\
   
{\verb~LF~} &
      the leading form of a polynomial or an ideal\\
   
{\verb~LinKerBasis~} &
      find the kernel of a matrix\\
   
{\verb~LM~} &
      the leading monomial of a polynomial or ModuleElem\\
   
{\verb~LPP~} &
      the leading power-product of a polynomial or ModuleElem\\
   
{\verb~LT~} &
      the leading term of an object\\
   
{\verb~MakeTerm~} &
      returns a monomial (power-product) with given exponents\\
   
{\verb~MinPoly~} &
      minimal polynomial of a matrix\\
   
{\verb~MinPolyQuot~} &
      minimal polynomial in quotient ring\\
   
{\verb~monic~} &
      divide polynomials by their leading coefficients\\
   
{\verb~NF~} &
      normal form\\
   
{\verb~NmzDiagInvariants~} &
      ring of invariants of a diagonalizable group action\\
   
{\verb~NmzEhrhartRing~} &
      Ehrhart ring\\
   
{\verb~NmzFiniteDiagInvariants~} &
      ring of invariants of a finite group action\\
   
{\verb~NmzIntClosureMonIdeal~} &
      integral closure of a monomial ideal\\
   
{\verb~NmzIntClosureToricRing~} &
      integral closure of a toric ring\\
   
{\verb~NmzIntersectionValRings~} &
      intersection of ring of valuations\\
   
{\verb~NmzNormalToricRing~} &
      normalization of a toric ring\\
   
{\verb~NmzTorusInvariants~} &
      ring of invariants of torus action\\
   
{\verb~NR~} &
      normal reduction\\
   
{\verb~num~} &
      numerator\\
   
{\verb~one~} &
      one of a ring\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~pfaffian~} &
      the Pfaffian of a skew-symmetric matrix\\
   
{\verb~PosetCharPoly~} &
      characteristic polynomial of a poset from the relations of the poset\\
   
{\verb~PosetPoincarePoly~} &
      Poincare polynomial of a poset from the relations of the poset\\
   
{\verb~power~} &
      compute a power\\
   
{\verb~prim~} &
      primitive part of a polynomial\\
   
{\verb~PthRoot~} &
      Compute p-th root\\
   
{\verb~QZP~} &
      change field for polynomials and ideals\\
   
{\verb~radical~} &
      radical of an ideal\\
   
{\verb~RandomLinearForm~} &
      random linear form in polynomial ring\\
   
{\verb~RatReconstructPoly~} &
      Rational reconstruction of polynomial coefficents\\
   
{\verb~ReducedGBasis~} &
      reduced Groebner basis\\
   
{\verb~resultant~} &
      the resultant of two polynomials\\
   
{\verb~RingElem~} &
      convert an expression into a RINGELEM\\
   
{\verb~RingElemList, RingElems~} &
      convert expressions into a LIST of RINGELEM\\
   
{\verb~RootBoundTransform~} &
      transform of a polynomial, helpful for checking RootBound\\
   
{\verb~ScalarProduct~} &
      scalar product\\
   
{\verb~SwinnertonDyerPoly~} &
      compute Swinnerton-Dyer polynomial with given roots\\
   
{\verb~SymmetricPolys~} &
      list of symmetric polynomials\\
   
{\verb~UniversalGBasis~} &
      universal Groebner basis of the input ideal\\
   
{\verb~zero~} &
      zero of a ring\\
   
{\verb~ZPQ~} &
      change field for polynomials and ideals\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{IDEAL}
\label{IDEAL}

      

% -- SECTION --------------------------------
\section{Commands and Functions for IDEAL}
\label{Commands and Functions for IDEAL}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~AreGensMonomial~} &
      checks if given gens are monomial\\
   
{\verb~AreGensSqFreeMonomial~} &
      checks if given gens are squarefree monomial\\
   
{\verb~BBasis5~} &
      Border Basis of zero dimensional ideal\\
   
{\verb~BettiDiagram~} &
      the diagram of the graded Betti numbers\\
   
{\verb~BettiMatrix~} &
      the matrix of the graded Betti numbers\\
   
{\verb~BettiNumbers~} &
      (Multi-)graded Betti numbers\\
   
{\verb~CallOnGroebnerFanIdeals~} &
      apply a function to Groebner fan ideals\\
   
{\verb~colon~} &
      ideal or module quotient\\
   
{\verb~ComputeElimFirst~} &
      ComputeElimFirst\\
   
{\verb~DenSigma~} &
      den of ideal, wrt to ordering sigma\\
   
{\verb~depth~} &
      Depth of a module\\
   
{\verb~elim~} &
      eliminate variables\\
   
{\verb~EquiIsoDec~} &
      equidimensional isoradical decomposition\\
   
{\verb~FrbAlexanderDual~} &
      Alexander Dual of monomial ideals\\
   
{\verb~FrbAssociatedPrimes~} &
      Associated primes of monomial ideals\\
   
{\verb~FrbIrreducibleDecomposition~} &
      Irreducible decomposition of monomial ideals\\
   
{\verb~FrbMaximalStandardMonomials~} &
      Maximal standard monomials of monomial ideals\\
   
{\verb~FrbPrimaryDecomposition~} &
      Primary decomposition of monomial ideals\\
   
{\verb~FrobeniusMat~} &
      matrix of the Frobenius Map\\
   
{\verb~GBasis~} &
      calculate a Groebner basis\\
   
{\verb~GBasisByHomog~} &
      calculate a Groebner basis by homogenization\\
   
{\verb~GBasisTimeout~} &
      compute a Groebner basis with a timeout\\
   
{\verb~GenRepr~} &
      representation in terms of generators\\
   
{\verb~gens~} &
      list of generators of an ideal\\
   
{\verb~gin~} &
      generic initial ideal\\
   
{\verb~GroebnerFanIdeals~} &
      all reduced Groebner bases of an ideal\\
   
{\verb~GroebnerFanReducedGBases~} &
      Groebner fan reduced GBases\\
   
{\verb~HasGBasis~} &
      checks if the argument has a pre-computed GBasis\\
   
{\verb~HColon~} &
      ideal or module quotient\\
   
{\verb~HilbertFn~} &
      the Hilbert function\\
   
{\verb~HilbertSeries~} &
      the Hilbert-Poincare series\\
   
{\verb~homog~} &
      homogenize wrt an indeterminate\\
   
{\verb~HSaturation~} &
      saturation of ideals\\
   
{\verb~IdealOfGBasis~} &
      ideal generated by GBasis\\
   
{\verb~IdealOfMinGens~} &
      ideal generated by minimal generators\\
   
{\verb~indent~} &
      prints in a more readable way\\
   
{\verb~InitialIdeal~} &
      Initial ideal\\
   
{\verb~intersection~} &
      intersect lists, ideals, or modules\\
   
{\verb~IntersectionList~} &
      intersect lists, ideals, or modules\\
   
{\verb~InverseSystem~} &
      Inverse system of an ideal of derivations\\
   
{\verb~IsContained~} &
      checks if A is Contained in B\\
   
{\verb~IsElem~} &
      checks if A is an element of B\\
   
{\verb~IsHomog~} &
      test whether given polynomials are homogeneous\\
   
{\verb~IsIn~} &
      check if one object is contained in another\\
   
{\verb~IsInRadical~} &
      check if a polynomial (or ideal) is in a radical\\
   
{\verb~IsLexSegment~} &
      checks if an ideal is lex-segment\\
   
{\verb~IsMaximal~} &
      maximality test\\
   
{\verb~IsOne~} &
      test whether an object is one\\
   
{\verb~IsPrimary~} &
      primary test\\
   
{\verb~IsRadical~} &
      check if an IDEAL is radical\\
   
{\verb~IsSigmaGoodPrime~} &
      check if INT is good prime for IDEAL \\
   
{\verb~IsStable~} &
      checks if an ideal is stable\\
   
{\verb~IsStronglyStable~} &
      checks if an ideal is strongly stable\\
   
{\verb~IsZero~} &
      test whether an object is zero\\
   
{\verb~IsZeroDim~} &
      test whether an ideal is zero-dimensional\\
   
{\verb~JanetBasis~} &
      the Janet basis of an ideal\\
   
{\verb~LexSegmentIdeal~} &
      lex-segment ideal containing L, or with the same HilbertFn as I\\
   
{\verb~LF~} &
      the leading form of a polynomial or an ideal\\
   
{\verb~LT~} &
      the leading term of an object\\
   
{\verb~MayerVietorisTreeN1~} &
      N-1st Betti multidegrees of monomial ideals using Mayer-Vietoris trees\\
   
{\verb~MinGens~} &
      list of minimal generators\\
   
{\verb~MinPolyQuot~} &
      minimal polynomial in quotient ring\\
   
{\verb~MinPowerInIdeal~} &
      the mininum power of a polynomial is an ideal\\
   
{\verb~MinSubsetOfGens~} &
      list of minimal generators\\
   
{\verb~MonsInIdeal~} &
      ideal generated by the monomials in an ideal\\
   
{\verb~MultiplicationMat~} &
      multiplication matrix of a ringelem\\
   
{\verb~NewQuotientRing~} &
      create a new quotient ring\\
   
{\verb~NF~} &
      normal form\\
   
{\verb~NumGens~} &
      number of generators\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~PrimaryDecomposition~} &
      primary decomposition of an ideal\\
   
{\verb~PrimaryDecompositionGTZ0~} &
      primary decomposition of a 0-dimensional ideal\\
   
{\verb~PrimaryHilbertSeries~} &
      primary\\
   
{\verb~PrintBettiDiagram~} &
      print the diagram of the graded Betti numbers\\
   
{\verb~PrintBettiMatrix~} &
      print the matrix of the graded Betti numbers\\
   
{\verb~PrintBettiNumbers~} &
      print the (multi-)graded Betti numbers\\
   
{\verb~PrintSectionalMatrix~} &
      print sectional matrix\\
   
{\verb~product~} &
      the product of the elements of a list\\
   
{\verb~QuotientBasis~} &
      vector space basis for zero-dimensional quotient rings\\
   
{\verb~QuotientBasisSorted~} &
      vector space basis for zero-dimensional quotient rings\\
   
{\verb~QZP~} &
      change field for polynomials and ideals\\
   
{\verb~radical~} &
      radical of an ideal\\
   
{\verb~RadicalOfUnmixed~} &
      radical of an unmixed ideal\\
   
{\verb~ReducedGBasis~} &
      reduced Groebner basis\\
   
{\verb~reg~} &
      Castelnuovo-Mumford regularity of a module\\
   
{\verb~res~} &
      free resolution\\
   
{\verb~rgin~} &
      generic initial ideal wrt StdDegRevLex\\
   
{\verb~RingOf~} &
      the ring of the object\\
   
{\verb~RingsOf~} &
      list of the rings of an object\\
   
{\verb~saturate~} &
      saturation of ideals\\
   
{\verb~SectionalMatrix~} &
      sectional matrix \\
   
{\verb~StdBasis~} &
      Standard basis\\
   
{\verb~sum~} &
      the sum of the elements of a list\\
   
{\verb~syz~} &
      syzygy modules\\
   
{\verb~SyzOfGens~} &
      syzygy module for a given set of generators\\
   
{\verb~TgCone~} &
      tangent cone\\
   
{\verb~ThmProve [PROTOTYPE]~} &
      [PROTOTYPE] ThmProve\\
   
{\verb~toric~} &
      saturate toric ideals\\
   
{\verb~UniversalGBasis~} &
      universal Groebner basis of the input ideal\\
   
{\verb~ZPQ~} &
      change field for polynomials and ideals\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning IDEAL}
\label{Commands and Functions returning IDEAL}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~ArtinianOrlikTeraoIdeal~} &
      Artinian Orlik-Terao ideal of an arrangement of hyperplanes\\
   
{\verb~colon~} &
      ideal or module quotient\\
   
{\verb~DefiningIdeal~} &
      defining ideal of a quotient ring\\
   
{\verb~elim~} &
      eliminate variables\\
   
{\verb~EquiIsoDec~} &
      equidimensional isoradical decomposition\\
   
{\verb~GBM~} &
      intersection of ideals for zero-dimensional schemes\\
   
{\verb~gin~} &
      generic initial ideal\\
   
{\verb~GinJacobian~} &
      generic initial ideal of the Jacobian ideal of a polynomial\\
   
{\verb~HColon~} &
      ideal or module quotient\\
   
{\verb~HGBM~} &
      intersection of ideals for zero-dimensional schemes\\
   
{\verb~homog~} &
      homogenize wrt an indeterminate\\
   
{\verb~HSaturation~} &
      saturation of ideals\\
   
{\verb~ideal~} &
      ideal generated by list\\
   
{\verb~IdealOfGBasis~} &
      ideal generated by GBasis\\
   
{\verb~IdealOfMinGens~} &
      ideal generated by minimal generators\\
   
{\verb~IdealOfPoints~} &
      ideal of a set of affine points\\
   
{\verb~IdealOfProjectivePoints~} &
      ideal of a set of projective points\\
   
{\verb~implicit~} &
      implicitization\\
   
{\verb~InitialIdeal~} &
      Initial ideal\\
   
{\verb~intersection~} &
      intersect lists, ideals, or modules\\
   
{\verb~IntersectionList~} &
      intersect lists, ideals, or modules\\
   
{\verb~ker~} &
      Kernel of a homomorphism\\
   
{\verb~LexSegmentIdeal~} &
      lex-segment ideal containing L, or with the same HilbertFn as I\\
   
{\verb~LF~} &
      the leading form of a polynomial or an ideal\\
   
{\verb~LT~} &
      the leading term of an object\\
   
{\verb~MonsInIdeal~} &
      ideal generated by the monomials in an ideal\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~OrlikTeraoIdeal~} &
      Orlik-Terao ideal of an arrangement of hyperplanes\\
   
{\verb~PerpIdealOfForm~} &
      Ideal of derivations annihilating a form\\
   
{\verb~PrimaryDecomposition~} &
      primary decomposition of an ideal\\
   
{\verb~PrimaryDecompositionGTZ0~} &
      primary decomposition of a 0-dimensional ideal\\
   
{\verb~QZP~} &
      change field for polynomials and ideals\\
   
{\verb~radical~} &
      radical of an ideal\\
   
{\verb~RadicalOfUnmixed~} &
      radical of an unmixed ideal\\
   
{\verb~rgin~} &
      generic initial ideal wrt StdDegRevLex\\
   
{\verb~saturate~} &
      saturation of ideals\\
   
{\verb~SolomonTeraoIdeal~} &
      Solomon-Terao ideal of an arrangement of hyperplanes wrt a poly\\
   
{\verb~StableIdeal~} &
      stable ideal containing L\\
   
{\verb~StagedTrees~} &
      staged trees from Statistics\\
   
{\verb~StronglyStableIdeal~} &
      strongly stable ideal containing L\\
   
{\verb~TgCone~} &
      tangent cone\\
   
{\verb~toric~} &
      saturate toric ideals\\
   
{\verb~ZPQ~} &
      change field for polynomials and ideals\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{MAT}
\label{MAT}

      

% -- SECTION --------------------------------
\section{Introduction to MAT}
\label{Introduction to MAT}

        
An m x n matrix is represented in CoCoA by the list of its rows
(see ``\verb&matrix&'' (\ref{matrix} pg.\pageref{matrix})).
The (A,B)-th entry of a matrix M is given by ``\verb&M[A][B]&'' or ``\verb&M[A,B]&''.
\par 
The following operations are defined as one would expect for matrices
\begin{verbatim}
  M^A, +M, -N, M+N, M-N, M*N, F*M, M*F
\end{verbatim}
where M, N are matrices, A is a non-negative integer, and F is a
polynomial, with the obvious restrictions on the dimensions of the
matrices involved.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  use R ::= QQ[x,y];
/**/  N := matrix(R, [[1,2],[3,4]]);
/**/  N[1,2];
2;

/**/  N^2;
matrix( /*RingWithID(3, "QQ[x,y]")*/
 [[7, 10],
  [15, 22]])

/**/  x * N;
matrix( /*RingWithID(3, "QQ[x,y]")*/
 [[x, 2*x],
  [3*x, 4*x]])

/**/  N + matrix([[x,x], [y,y]]);
matrix( /*RingWithID(3, "QQ[x,y]")*/
 [[x +1, x +2],
  [y +3, y +4]])
\end{Verbatim}



% -- SECTION --------------------------------
\section{Commands and Functions for MAT}
\label{Commands and Functions for MAT}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~adj~} &
      classical adjoint matrix (also known as adjugate)\\
   
{\verb~AlmostQR~} &
      QR decomposition of a matrix\\
   
{\verb~ApproxPointsNBM~} &
      Numerical Border Basis of ideal of points\\
   
{\verb~BlockMat~} &
      create a block matrix\\
   
{\verb~BlockMat2x2~} &
      create a block matrix with 4 matrices\\
   
{\verb~CharPoly~} &
      characteristic polynomial of a matrix\\
   
{\verb~ConcatAntiDiag~} &
      create a simple block matrix\\
   
{\verb~ConcatDiag~} &
      create a simple block matrix\\
   
{\verb~ConcatHor~} &
      create a simple block matrix\\
   
{\verb~ConcatHorList~} &
      create a simple block matrix\\
   
{\verb~ConcatVer~} &
      create a simple block matrix\\
   
{\verb~ConcatVerList~} &
      create a simple block matrix\\
   
{\verb~det~} &
      the determinant of a matrix\\
   
{\verb~eigenfactors~} &
      eigenfactors of a matrix\\
   
{\verb~eigenvectors~} &
      eigenvalues and eigenvectors of a matrix\\
   
{\verb~ElimHomogMat~} &
      matrix for elimination ordering\\
   
{\verb~ElimMat~} &
      matrix for elimination ordering\\
   
{\verb~eval~} &
      substitute numbers or polynomials for indeterminates\\
   
{\verb~FGLM5~} &
      perform a FGLM Groebner Basis conversion\\
   
{\verb~FrobeniusNormSq~} &
      Frobenius norm of a matrix\\
   
{\verb~GetCol~} &
      convert a column of a matrix into a list\\
   
{\verb~GetCols~} &
      convert a matrix into a list of lists\\
   
{\verb~GetRow~} &
      convert a row of a matrix into a list\\
   
{\verb~GetRows~} &
      convert a matrix into a list of lists\\
   
{\verb~GFanContainsPositiveVector~} &
      ...\\
   
{\verb~GFanGeneratorsOfLinealitySpace~} &
      ...\\
   
{\verb~GFanGeneratorsOfSpan~} &
      ...\\
   
{\verb~GFanGetAmbientDimension~} &
      ...\\
   
{\verb~GFanGetCodimension~} &
      ...\\
   
{\verb~GFanGetDimension~} &
      ...\\
   
{\verb~GFanGetDimensionOfLinealitySpace~} &
      ...\\
   
{\verb~GFanGetFacets~} &
      ...\\
   
{\verb~GFanGetImpliedEquations~} &
      ...\\
   
{\verb~GFanGetUniquePoint~} &
      ...\\
   
{\verb~GFanRelativeInteriorPoint~} &
      relative interior point of a cone\\
   
{\verb~GraverBasis~} &
      Graver basis\\
   
{\verb~HadamardBoundSq~} &
      Hadamard bound for determinant\\
   
{\verb~HilbertBasisKer~} &
      Hilbert basis for a monoid\\
   
{\verb~HilbertSeriesMultiDeg~} &
      the Hilbert-Poincare series wrt a multigrading\\
   
{\verb~IdealOfPoints~} &
      ideal of a set of affine points\\
   
{\verb~IdealOfProjectivePoints~} &
      ideal of a set of projective points\\
   
{\verb~inverse~} &
      multiplicative inverse of matrix\\
   
{\verb~IsAntiSymmetric~} &
      checks if a matrix is anti-symmetric\\
   
{\verb~IsDiagonal~} &
      checks if a matrix is diagonal\\
   
{\verb~IsPositiveGrading~} &
      check if a matrix defines a positive grading\\
   
{\verb~IsSymmetric~} &
      checks if a matrix is symmetric\\
   
{\verb~IsTermOrdering~} &
      check if a matrix defines a term-ordering\\
   
{\verb~IsZero~} &
      test whether an object is zero\\
   
{\verb~IsZeroCol, IsZeroRow~} &
      test whether a column(row) is zero\\
   
{\verb~IsZeroDet~} &
      test whether determinant is zero\\
   
{\verb~LinKer~} &
      find the kernel of a matrix\\
   
{\verb~LinKerBasis~} &
      find the kernel of a matrix\\
   
{\verb~LinKerZZ~} &
      find the kernel of a matrix\\
   
{\verb~LinSolve~} &
      find a solution to a linear system\\
   
{\verb~MakeTermOrdMat~} &
      Make a term order matrix from a given matrix\\
   
{\verb~matrix~} &
      convert a list into a matrix\\
   
{\verb~minors~} &
      list of minor determinants of a matrix\\
   
{\verb~MinPoly~} &
      minimal polynomial of a matrix\\
   
{\verb~NewFreeModule~} &
      create a new FreeModule\\
   
{\verb~NewPolyRing~} &
      create a new PolyRing\\
   
{\verb~NmzDiagInvariants~} &
      ring of invariants of a diagonalizable group action\\
   
{\verb~NmzFiniteDiagInvariants~} &
      ring of invariants of a finite group action\\
   
{\verb~NmzHilbertBasis~} &
      Hilbert Basis of a monoid\\
   
{\verb~NmzHilbertBasisKer~} &
      Hilbert basis for a monoid\\
   
{\verb~NmzIntersectionValRings~} &
      intersection of ring of valuations\\
   
{\verb~NmzTorusInvariants~} &
      ring of invariants of torus action\\
   
{\verb~NumCols~} &
      number of columns in a matrix\\
   
{\verb~NumRows~} &
      number of rows in a matrix\\
   
{\verb~operators, shortcuts~} &
      Special characters equivalent to commands\\
   
{\verb~pfaffian~} &
      the Pfaffian of a skew-symmetric matrix\\
   
{\verb~power~} &
      compute a power\\
   
{\verb~PreprocessPts~} &
      Reduce redundancy in a set of approximate points\\
   
{\verb~product~} &
      the product of the elements of a list\\
   
{\verb~RingOf~} &
      the ring of the object\\
   
{\verb~RingsOf~} &
      list of the rings of an object\\
   
{\verb~rk~} &
      rank of a matrix or module\\
   
{\verb~rref~} &
      reduced row echelon form of a matrix\\
   
{\verb~SetCol~} &
      set a list as a column into a matrix\\
   
{\verb~SetEntry~} &
      set an entry into a matrix\\
   
{\verb~SetRow~} &
      set a list as a row into a matrix\\
   
{\verb~submat~} &
      submatrix\\
   
{\verb~sum~} &
      the sum of the elements of a list\\
   
{\verb~SwapCols~} &
      swap two columns in a matrix\\
   
{\verb~SwapRows~} &
      swap two rows in a matrix\\
   
{\verb~toric~} &
      saturate toric ideals\\
   
{\verb~transposed~} &
      the transposition of a matrix\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning MAT}
\label{Commands and Functions returning MAT}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~adj~} &
      classical adjoint matrix (also known as adjugate)\\
   
{\verb~ArrDerModule~} &
      set of generators of the module of logarithmic derivations of an arrangement of hyperplanes\\
   
{\verb~BlockMat~} &
      create a block matrix\\
   
{\verb~BlockMat2x2~} &
      create a block matrix with 4 matrices\\
   
{\verb~ColMat~} &
      single column matrix\\
   
{\verb~ConcatAntiDiag~} &
      create a simple block matrix\\
   
{\verb~ConcatDiag~} &
      create a simple block matrix\\
   
{\verb~ConcatHor~} &
      create a simple block matrix\\
   
{\verb~ConcatHorList~} &
      create a simple block matrix\\
   
{\verb~ConcatVer~} &
      create a simple block matrix\\
   
{\verb~ConcatVerList~} &
      create a simple block matrix\\
   
{\verb~DiagMat~} &
      matrix with given diagonal\\
   
{\verb~ElimHomogMat~} &
      matrix for elimination ordering\\
   
{\verb~ElimMat~} &
      matrix for elimination ordering\\
   
{\verb~FrobeniusMat~} &
      matrix of the Frobenius Map\\
   
{\verb~GensAsCols, GensAsRows~} &
      matrix of generators of a module\\
   
{\verb~GFanGeneratorsOfLinealitySpace~} &
      ...\\
   
{\verb~GFanGeneratorsOfSpan~} &
      ...\\
   
{\verb~GFanGetFacets~} &
      ...\\
   
{\verb~GFanGetImpliedEquations~} &
      ...\\
   
{\verb~GFanGetUniquePoint~} &
      ...\\
   
{\verb~GFanRelativeInteriorPoint~} &
      relative interior point of a cone\\
   
{\verb~GradingMat~} &
      matrix of generalized weights for indeterminates\\
   
{\verb~HilbertMat~} &
      create a Hilbert matrix over QQ\\
   
{\verb~IdentityMat~} &
      the identity matrix\\
   
{\verb~inverse~} &
      multiplicative inverse of matrix\\
   
{\verb~JacobianMat~} &
      the Jacobian matrix of a list of polynomials\\
   
{\verb~KroneckerProd~} &
      returns the Kronecker product of two matrices\\
   
{\verb~LawrenceMat~} &
      Lawrence lifting of a matrix\\
   
{\verb~LexMat~} &
      matrices for std. term-orderings\\
   
{\verb~LinKer~} &
      find the kernel of a matrix\\
   
{\verb~LinKerZZ~} &
      find the kernel of a matrix\\
   
{\verb~LinSolve~} &
      find a solution to a linear system\\
   
{\verb~MakeMatByRows, MakeMatByCols~} &
      convert a list into a matrix\\
   
{\verb~MakeTermOrdMat~} &
      Make a term order matrix from a given matrix\\
   
{\verb~matrix~} &
      convert a list into a matrix\\
   
{\verb~MultiArrDerModule~} &
      set of generators of the module of logarithmic derivations of a multiarrangement of hyperplanes\\
   
{\verb~MultiplicationMat~} &
      multiplication matrix of a ringelem\\
   
{\verb~NewMat~} &
      Zero matrix\\
   
{\verb~NewMatFilled~} &
      matrix filled with value\\
   
{\verb~NmzHilbertBasis~} &
      Hilbert Basis of a monoid\\
   
{\verb~NmzHilbertBasisKer~} &
      Hilbert basis for a monoid\\
   
{\verb~OrdMat~} &
      matrix defining a term-ordering\\
   
{\verb~power~} &
      compute a power\\
   
{\verb~PrintSectionalMatrix~} &
      print sectional matrix\\
   
{\verb~RandomSparseNonSing01Mat~} &
      random sparse non-singular (0,1) matrix\\
   
{\verb~RandomUnimodularMat~} &
      random unimodular matrix\\
   
{\verb~RevLexMat~} &
      matrix for rev lex term-ordering\\
   
{\verb~RowMat~} &
      single row matrix\\
   
{\verb~rref~} &
      reduced row echelon form of a matrix\\
   
{\verb~StdDegLexMat~} &
      matrix for std deg lex term-ordering\\
   
{\verb~StdDegRevLexMat~} &
      matrix for std deg rev lex term-ordering\\
   
{\verb~submat~} &
      submatrix\\
   
{\verb~SylvesterMat~} &
      the Sylvester matrix of two polynomials\\
   
{\verb~transposed~} &
      the transposition of a matrix\\
   
{\verb~XelMat~} &
      matrices for std. term-orderings\\
   
{\verb~ZeroMat~} &
      matrix filled with 0\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{MODULE}
\label{MODULE}

      

% -- SECTION --------------------------------
\section{Commands and Functions for MODULE}
\label{Commands and Functions for MODULE}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~BettiDiagram~} &
      the diagram of the graded Betti numbers\\
   
{\verb~BettiMatrix~} &
      the matrix of the graded Betti numbers\\
   
{\verb~BettiNumbers~} &
      (Multi-)graded Betti numbers\\
   
{\verb~CanonicalBasis~} &
      canonical basis of a free module\\
   
{\verb~colon~} &
      ideal or module quotient\\
   
{\verb~elim~} &
      eliminate variables\\
   
{\verb~GBasis~} &
      calculate a Groebner basis\\
   
{\verb~GBasisTimeout~} &
      compute a Groebner basis with a timeout\\
   
{\verb~GenRepr~} &
      representation in terms of generators\\
   
{\verb~gens~} &
      list of generators of an ideal\\
   
{\verb~GensAsCols, GensAsRows~} &
      matrix of generators of a module\\
   
{\verb~HilbertSeries~} &
      the Hilbert-Poincare series\\
   
{\verb~HilbertSeriesShifts~} &
      the Hilbert-Poincare series\\
   
{\verb~homog~} &
      homogenize wrt an indeterminate\\
   
{\verb~HVector~} &
      the h-vector of a module or quotient object\\
   
{\verb~IntersectionList~} &
      intersect lists, ideals, or modules\\
   
{\verb~IsContained~} &
      checks if A is Contained in B\\
   
{\verb~IsElem~} &
      checks if A is an element of B\\
   
{\verb~IsHomog~} &
      test whether given polynomials are homogeneous\\
   
{\verb~IsIn~} &
      check if one object is contained in another\\
   
{\verb~IsZero~} &
      test whether an object is zero\\
   
{\verb~LT~} &
      the leading term of an object\\
   
{\verb~MinGens~} &
      list of minimal generators\\
   
{\verb~MinSubsetOfGens~} &
      list of minimal generators\\
   
{\verb~ModuleElem~} &
      create a module element\\
   
{\verb~ModuleOf~} &
      the module environment of the object\\
   
{\verb~multiplicity~} &
      the multiplicity (degree) of a ring\\
   
{\verb~NF~} &
      normal form\\
   
{\verb~NumCompts~} &
      the number of components\\
   
{\verb~PrintBettiDiagram~} &
      print the diagram of the graded Betti numbers\\
   
{\verb~PrintBettiMatrix~} &
      print the matrix of the graded Betti numbers\\
   
{\verb~PrintBettiNumbers~} &
      print the (multi-)graded Betti numbers\\
   
{\verb~ReducedGBasis~} &
      reduced Groebner basis\\
   
{\verb~res~} &
      free resolution\\
   
{\verb~RingOf~} &
      the ring of the object\\
   
{\verb~RingsOf~} &
      list of the rings of an object\\
   
{\verb~rk~} &
      rank of a matrix or module\\
   
{\verb~submodule~} &
      submodule generated by list\\
   
{\verb~SubmoduleCols, SubmoduleRows~} &
      convert a matrix into a module\\
   
{\verb~SubmoduleOfMinGens~} &
      submodule generated by minimal generators\\
   
{\verb~syz~} &
      syzygy modules\\
   
{\verb~SyzOfGens~} &
      syzygy module for a given set of generators\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning MODULE}
\label{Commands and Functions returning MODULE}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~elim~} &
      eliminate variables\\
   
{\verb~homog~} &
      homogenize wrt an indeterminate\\
   
{\verb~IntersectionList~} &
      intersect lists, ideals, or modules\\
   
{\verb~LT~} &
      the leading term of an object\\
   
{\verb~ModuleOf~} &
      the module environment of the object\\
   
{\verb~NewFreeModule~} &
      create a new FreeModule\\
   
{\verb~submodule~} &
      submodule generated by list\\
   
{\verb~SubmoduleCols, SubmoduleRows~} &
      convert a matrix into a module\\
   
{\verb~SubmoduleOfMinGens~} &
      submodule generated by minimal generators\\
   
{\verb~syz~} &
      syzygy modules\\
   
{\verb~SyzOfGens~} &
      syzygy module for a given set of generators\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{MODULEELEM}
\label{MODULEELEM}

      

% -- SECTION --------------------------------
\section{Introduction to MODULEELEM}
\label{Introduction to MODULEELEM}

        
An object of type MODULEELEM in CoCoA represents a module element;
in CoCoA this usually means an element of the free module ``\verb&P^r&'',
where ``\verb&P&'' is a polynomial ring.
For ``\verb&v&'' and ``\verb&w&'' MODULEELEM in the same MODULE,
and ``\verb&f&'' RINGELEM in its base ring, the following are also MODULEELEM:
\begin{verbatim}
   +v, -v, f*v, v*f, v+w, v-w
\end{verbatim}
See ``\verb&ModuleElem&'' (\ref{ModuleElem} pg.\pageref{ModuleElem}).

\SeeAlso %---- SEE ALSO ----
  Commands and Functions for MODULEELEM(\ref{Commands and Functions for MODULEELEM} pg.\pageref{Commands and Functions for MODULEELEM}), 
    Commands and Functions returning MODULEELEM(\ref{Commands and Functions returning MODULEELEM} pg.\pageref{Commands and Functions returning MODULEELEM})

% -- SECTION --------------------------------
\section{Commands and Functions for MODULEELEM}
\label{Commands and Functions for MODULEELEM}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~compts~} &
      list of components of a ModuleElem\\
   
{\verb~DivAlg~} &
      division algorithm\\
   
{\verb~eval~} &
      substitute numbers or polynomials for indeterminates\\
   
{\verb~FirstNonZero~} &
      the first non-zero entry in a MODULEELEM\\
   
{\verb~FirstNonZeroPosn~} &
      the position of the first non-zero entry in a MODULEELEM\\
   
{\verb~GenRepr~} &
      representation in terms of generators\\
   
{\verb~homog~} &
      homogenize wrt an indeterminate\\
   
{\verb~IsElem~} &
      checks if A is an element of B\\
   
{\verb~IsHomog~} &
      test whether given polynomials are homogeneous\\
   
{\verb~IsIn~} &
      check if one object is contained in another\\
   
{\verb~IsTerm~} &
      checks if the argument is a term\\
   
{\verb~IsZero~} &
      test whether an object is zero\\
   
{\verb~LC~} &
      the leading coefficient of a polynomial or ModuleElem\\
   
{\verb~LM~} &
      the leading monomial of a polynomial or ModuleElem\\
   
{\verb~LPosn~} &
      the position of the leading power-product in a ModuleElem\\
   
{\verb~LPP~} &
      the leading power-product of a polynomial or ModuleElem\\
   
{\verb~LT~} &
      the leading term of an object\\
   
{\verb~ModuleOf~} &
      the module environment of the object\\
   
{\verb~monomials~} &
      the list of monomials of a polynomial\\
   
{\verb~NF~} &
      normal form\\
   
{\verb~NonZero~} &
      remove zeroes from a list\\
   
{\verb~NR~} &
      normal reduction\\
   
{\verb~NumCompts~} &
      the number of components\\
   
{\verb~product~} &
      the product of the elements of a list\\
   
{\verb~RingsOf~} &
      list of the rings of an object\\
   
{\verb~submodule~} &
      submodule generated by list\\
   
{\verb~sum~} &
      the sum of the elements of a list\\
   
{\verb~support~} &
      the list of terms of a polynomial or moduleelem\\
   
\end{longtable}
\end{center}

\noindent



% -- SECTION --------------------------------
\section{Commands and Functions returning MODULEELEM}
\label{Commands and Functions returning MODULEELEM}

        

\begin{center}
\begin{longtable}{ll}
   
{\verb~CanonicalBasis~} &
      canonical basis of a free module\\
   
{\verb~homog~} &
      homogenize wrt an indeterminate\\
   
{\verb~LM~} &
      the leading monomial of a polynomial or ModuleElem\\
   
{\verb~LT~} &
      the leading term of an object\\
   
{\verb~ModuleElem~} &
      create a module element\\
   
{\verb~NF~} &
      normal form\\
   
{\verb~NR~} &
      normal reduction\\
   
{\verb~ReducedGBasis~} &
      reduced Groebner basis\\
   
\end{longtable}
\end{center}

\noindent



% -- CHAPTER --------------------------------
\chapter{Creating new types}
\label{Creating new types}

      

% -- SECTION --------------------------------
\section{Tagging an Object}
\label{Tagging an Object}

        
If ``\verb&E&'' is any CoCoA object and ``\verb&S&'' a string, then the function
``\verb&Tagged(E, S)&'' returns the object ``\verb&E&'' tagged with the string ``\verb&S&''.
The returned object is then of type ``\verb&TAGGED(S)&''.
The function ``\verb&tag&'' (\ref{tag} pg.\pageref{tag}) returns ``\verb&S&'', the tag string of an object,
and the function ``\verb&untagged&'' (\ref{untagged} pg.\pageref{untagged}) returns ``\verb&E&'', the
original object, stripped of its tag.
\par 
This is the way to add a new type at run-time.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := ["Dave", "March 14, 1959", 372];
/**/  M := Tagged(L, "MiscData");  -- L tagged with the string "MiscData"
/**/  type(L);  -- L is a list
LIST
/**/  type(M);  -- M is a tagged object
TAGGED("MiscData")
/**/  --M;  -- Until a special print function is defined, the printing of M
            -- is the same as L (with a WARNING)
--> WARNING: Cannot find "$BackwardCompatible.PrintTagged", so I am implicitly untagging the value
--> ["Dave", "March 14, 1959", 372]
\end{Verbatim}

The next section explains how to define functions for pretty printing
of tagged objects.


% -- SECTION --------------------------------
\section{Printing a Tagged Object}
\label{Printing a Tagged Object}

        
Suppose the object ``\verb&E&'' is tagged with the string ``\verb&S&''.
When one tries to print ``\verb&E&''---say with ``\verb&Print E&''---
CoCoA looks for a user-defined function with name ``\verb&Print_S&''.  If no such function is
available, CoCoA prints E as if it were not tagged, otherwise, it
executes ``\verb&Print_S&''.
\begin{Verbatim}[label=example, rulecolor=\color{PineGreen}, frame=single]
/**/  L := ["Dave", "March 14", 1959, 372];
/**/  M := tagged(L,"MiscData");

/**/  Define SpecialPrinting(Dev, Obj)
/**/    Print Obj[1],"'s birthday is: ", Obj[2] on Dev;
/**/  EndDefine;

/**/  PrintTagged := record[MiscData := SpecialPrinting];

/**/  Print M;
Dave's birthday is: March 14
\end{Verbatim}



% -- SECTION --------------------------------
\section{Commands and Functions for Tags}
\label{Commands and Functions for Tags}

        
The following are commands and functions involving tags:

\begin{center}
\begin{longtable}{ll}
   
{\verb~tag~} &
      returns the tag string of an object\\
   
{\verb~tagged~} &
      tag an object for pretty printing\\
   
{\verb~untagged~} &
      untag an object\\
   
\end{longtable}
\end{center}

\noindent




\end{document}
  