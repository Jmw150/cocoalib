
<html>
<head>
<link rel="stylesheet" type="text/css" href="gui.css">
<title>toric</title>
</head>

<body bgcolor=#eeffff>
<div>
<a href="toc.html#toric">up</a> <a href="cmdTopLevelFunctions.html">previous</a>  <a href="cmdtransposed.html">next</A>

<br> 
<!-- ========================= -->
<table bgcolor=#00dddd width=100%><tr><td>
  <font size=+3><b>toric<small> <i> &nbsp;&nbsp; -- &nbsp;&nbsp; 
saturate toric ideals</i> </small></b></font>
</td></tr></table>
<br>

<br> 
<!-- ========================= -->
<table bgcolor=#00dddd width=100%><tr><td>
  <font size=+1><b>Syntax</b></font>
</td></tr></table>
<table bgcolor=#ccffff width=100%><tr><td><pre>
toric(I: IDEAL): IDEAL
toric(I: IDEAL, L: LIST of INDETS): IDEAL
toric(M: MAT|LIST of LIST): IDEAL
toric(M: LIST of PP): IDEAL</pre></td></tr></table>


<br> 
<!-- ========================= -->
<table bgcolor=#00dddd width=100%><tr><td>
  <font size=+2><b>Description</b></font>
</td></tr></table>

These functions return the saturation of an ideal, I, generated by
binomials.  In the first two cases, I is the ideal generated by the
binomials in L.  To describe the ideal in the last case, let K be the
integral elements in the kernel of M.  For each k in K, we can write k
= k(+) - k(-) where the i-th component of k(+) is the i-th component
of k, if positive, otherwise zero.  Then I is the ideal generated by
the binomials <tt><b style="background:#bbeeee">x^k(+) - x^k(-)</b></tt> as k ranges over K.
<br><br>
NOTE: successive calls to this last form of the function may produce
different generators for the saturation.
<br><br>
The first and third functions return the saturation of I.  For the
second function, if the saturation of I with respect to the variables
in X happens to equal the saturation of I, then the saturation of I is
returned.  Otherwise, an ideal <b>containing</b> the saturation with
respect to the given variables is returned.  The point is that if one
knows, a priori, that the saturation of I can be obtained by
saturating with respect to a subset of the variables, the second
function may be used to save time.
<br><br>
For more details, see the article:
A.M. Bigatti, R. La Scala, L. Robbiano, 
<b>Computing Toric Ideals,</b>
Journal of Symbolic Computation, 27, 351-365 (1999).
The article describes three different algorithms; the one implemented
in CoCoA is <b>EATI</b>.  The first two examples below are motivated
by B. Sturmfels, <b>Groebner Bases and Convex Polytopes,</b> Chapter
6, p. 51.  They count the number of homogeneous primitive partition
identities of degrees 8 and 9.
<br>

<br> 
<!-- ========================= -->
<table bgcolor=#00dddd width=100%><tr><td>
  <font size=+1><b>Example</b></font>
</td></tr></table>
<table bgcolor=#ccffff width=100%><tr><td><pre>
/**/  use QQ[x[1..8],y[1..8]];
/**/  HPPI8 := [x[1]^I*x[I+2]*y[2]^(I+1) -y[1]^I*y[I+2]*x[2]^(I+1) | I in 1..6];
/**/  BL := toric(ideal(HPPI8), [x[1],y[2]]);
/**/  len(gens(BL));
340

/**/  use QQ[x[1..9],y[1..9]];
/**/  HPPI9 := [x[1]^I*x[I+2]*y[2]^(I+1) -y[1]^I*y[I+2]*x[2]^(I+1) | I in 1..7];
/**/  BL := toric(ideal(HPPI9), [x[1],y[2]]);
/**/  len(gens(BL));
798

/**/  use R ::= QQ[x,y,z,w];
/**/  toric(ideal(x*z-y^2, x*w-y*z));
ideal(-y^2 +x*z, -y*z +x*w, z^2 -y*w)

/**/  toric(ideal(x*z-y^2, x*w-y*z), [y]);
ideal(-y^2 +x*z, -y*z +x*w, z^2 -y*w)

/**/  use R ::= QQ[x,y,z];
/**/  toric([[1,3,2],[3,4,8]]);
ideal(-x^16 +y^2*z^5)

/**/  toric(mat([[1,3,2],[3,4,8]]));
ideal(-x^16 +y^2*z^5)
</pre></td></tr></table>


<br> 
<!-- ========================= -->
<table bgcolor=#00dddd width=100%><tr><td>
  <font size=+2><b>See Also</b></font>
</td></tr></table>
<ul>
</ul>
</div>

</body>
</html>
