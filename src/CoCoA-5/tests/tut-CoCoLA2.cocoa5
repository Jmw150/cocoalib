------------------------------------------------------------
-- TUTORIAL 2
------------------------------------------------------------
-- COMMUTING FAMILIES OF ENDOMORPHISMS
------------------------------------------------------------
-- ring for minimal polynomials
QQz ::= QQ[z];
------------------------------------------------------------
-- EXAMPLE  our first commuting family of endomorphisms

M := IdentityMat(QQ, 9);  M;
L := GetRows(M);  L;

Z3 := ZeroMat(QQ, 3, 3);

A := [BlockMat([[Z3, MakeMatByCols(3,3,L[i])],
	        [Z3,            Z3          ]])
      | i in 1..9];

A[1];
A[2]; -- and so on..
A[4]*A[7];  --> 0
-- All products of two matrices gives 0-matrix
--    therefore they trivially commute ;-)

--------------------------------------------------
-- DEFINITION
-- Given a set of commuting endomorphisms S
--   the COMMUTING FAMILY  F  GENERATED BY  S
--     is the algebra F = K[S].
--   It may be presented as K[z_1,..,z_n]/J
--------------------------------------------------

-- The QQ-basis of the family F is Id(6)=A[i]^0, A[1], ...A[9]
-- therefore the dimension is 10

-- F = K[A] ~ K[z_1,..,z_9]/J
use QQ[z[1..9]];
BM := BMForMat(A); -- generalization of MinPoly to a set of matrices:
-- Groebner Basis (of J, the ideal of relations)
-- Quotient Basis (basis as K-vector space of K[z_1,..,z_9]/J)
indent(BM);

len(BM.QB); --> 10
Rel := BM.GB;
-- evaluation of these polys in the matrices A gives 0-matrix

------------------------------------------------------------
-- RECALL from Tutorial1:
define TutEvalPolyInMat(f, M)
  ResM := ZeroMat(RingOf(M), NumRows(M), NumCols(M));
  foreach summand in monomials(f) do
    ResM := ResM + LC(summand) * M^deg(LPP(summand));
  endforeach;
  return ResM;
enddefine; -- TutEvalPolyInMat

------------------------------------------------------------
-- NEW FUNCTION: eval multivariate poly in list of matrices
--   (generalization of TutEvalPolyInMat)
define TutEvalPolyInMatList(f, M)
  ResM := ZeroMat(RingOf(M[1]), NumRows(M[1]), NumCols(M[1]));
  foreach summand in monomials(f) do
    d := exponents(LPP(summand));
    ResM := ResM
          + LC(summand) * product([ M[i]^d[i] | i in 1..len(M)]);
  endforeach;
  return ResM;
enddefine; -- TutEvalPolyInMatList
------------------------------------------------------------

-- verify: some relations on A, the list of our 9 matrices
IsZero( TutEvalPolyInMatList(Rel[1], A) );  --> true
IsZero( TutEvalPolyInMatList(Rel[13], A) ); --> true

------------------------------------------------------------
-- THE KERNEL OF AN IDEAL IN A COMMUTING FAMILY

--------------------------------------------------
-- DEFINITION   I = <psi_1, ... psi_n> ideal in F.
--   Ker(I) := intersection_i (Ker(psi_i))
--------------------------------------------------

M1 := BlockMat([[Z3, MakeMatByCols(3,3, [1,2,3, 4,5,6, 7,8,9])],
		[Z3, Z3]]);
M2 := BlockMat([[Z3, MakeMatByCols(3,3, [9,8,7, 6,5,4, 3,2,1])],
		[Z3, Z3]]);
M3 := BlockMat([[Z3, MakeMatByCols(3,3, [1,3,1, 1,3,1, 1,3,1])],
		[Z3, Z3]]);
C := BlockMat([[M1], [M2], [M3]]);   C;

LinKerBasis(M1); -- basis of Ker(phi1)
LinKerBasis(M2); -- basis of Ker(phi2)
LinKerBasis(M3); -- basis of Ker(phi3)
LinKerBasis(C);  -- basis of intersection of the 3 kernels

-- EXERCISE: try with other endomorphisms (matrices)

--------------------------------------------------
-- ALGORITHM   1-DIMENSIONAL JOINT EIGENSPACES
--------------------------------------------------

-- input
A1:=matrix(QQ,
 [[0, 1, 0, 0],
  [0, 0, 0, 1],
  [-6, 5, 2, -1],
  [4, -8, 0, 5]]);
A2:= matrix(QQ,
 [[0, 0, 1, 0],
  [-6, 5, 2, -1],
  [3, -4, 2, 1],
  [-16, 12, 4, -2]]);
A1*A2 = A2*A1;

-- (1)
use QQz;
p1 := eigenfactors(A1, z);   p1;  -- 2 linear factors
B1_1 := LinKer(TutEvalPolyInMat(p1[1], A1));
B1_2 := LinKer(TutEvalPolyInMat(p1[2], A1));

B1_1; B1_2;

-- (2)
S := [B1_1]; -- bases of length 1
L := [B1_2]; -- bases of length >1

-- loop on Ai, loop on bases in S

-- (5)
MatB := B1_2;
Restr := A2 * MatB;  Restr;  -- restriction of phi2 to <B1>
B1_2;
MatRestr := LinSolve(MatB, Restr);
MatRestr;

-- (6)
p21 := eigenfactors(MatRestr, z);  p21;
LinKerBasis(TutEvalPolyInMat(p21[1], MatRestr)); 
LK := LinKer(TutEvalPolyInMat(p21[1], MatRestr)); -- directly as matrix
LK;
JointEig2 := MatB * LK;
JointEig2;

-- (7)
append(ref S, JointEig2);
indent(S);

-- verification:
GetCol(S[1],1);
GetCol(A1*S[1], 1);
GetCol(A2*S[1], 1);
LinSolve(S[1], A1*S[1]); -- eigenvalue of phi1
LinSolve(S[1], A2*S[1]); -- eigenvalue of phi2

GetCol(S[2],1);
GetCol(A1*S[2], 1);
GetCol(A2*S[2], 1);
LinSolve(S[2], A1*S[2]); -- eigenvalue of phi1
LinSolve(S[2], A2*S[2]); -- eigenvalue of phi2

------------------------------------------------------------
-- EXAMPLE

A1 := mat([[0,2,0,0],
	   [1,0,0,0],
	   [0,0,0,2],
	   [0,0,1,0]]);

A2 := mat([[0,0,8,0],
	   [0,0,0,8],
	   [1,0,0,0],
	   [0,1,0,0]]);
A1*A2 = A2*A1;
-- F commuting family generated by A1, A2

use QQz;
eigenfactors(A1, z);
eigenfactors(A2, z);
A3 := A1 + A2;  -- psi = phi1 + phi2
eigenfactors(A3, z); --> two eigenfactors
--> so phi1 and phi2 are not splitting endomorphisms 

p := eigenfactors(A3, z);
NumCols(LinKer(TutEvalPolyInMat(p[1], A3))); --> dim 2
NumCols(LinKer(TutEvalPolyInMat(p[2], A3))); --> dim 2
--> 2+2 = dim(QQ^4)  --> so BigKer = LinKer

-- EXERCISE check with the algorithm described above that
--  there are no 1-dimensional joint eigenspaces of F
------------------------------------------------------------
-- ALGORITHM CYCLICITY TEST
A1 := mat([[0,1,0,0],
	   [0,0,0,1],
	   [-1,1,1,0],
	   [9,-12,-1,6]]);

A2 := mat([[0,0,1,0],
	   [-1,1,1,0],
	   [-2,0,3,0],
	   [-1,0,1,1]]);

A1*A2 = A2*A1;
-- F commuting family generated by A1, A2

-- (1)
RelRing ::= QQ[x,y];
Rel := BMForMat(RelRing, [A1,A2]);
indent(Rel);
QB := Rel.QB;

-- (3)
AuxRing ::= QQ[w[1..4]];  -- auxiliary indeterminates
W := ColMat(indets(AuxRing));  -- matrix in R

QB;
matrices := [TutEvalPolyInMatList(t, [A1,A2]) | t in QB];
indent(matrices);
C := BlockMat([[mat(AuxRing,M) * W | M in matrices]]);
C;

-- (4)
D := det(C);  D;
eval(D, [1,0,0,0]); --> not 0  --> OK
--> [1,0,0,0] is a generator of QQ^3 as F-module
V := ColMat([1,0,0,0]);

C1000 := BlockMat([[M*V | M in matrices]]);
invC := inverse(C1000);  invC;
invC := mat(RelRing, invC);  invC;

B1 := TutEvalPolyInMatList(ScalarProduct(QB, GetCol(invC,1)),
			[A1,A2]);
B2 := TutEvalPolyInMatList(ScalarProduct(QB, GetCol(invC,2)),
			[A1,A2]);
B3 := TutEvalPolyInMatList(ScalarProduct(QB, GetCol(invC,3)),
			[A1,A2]);
B4 := TutEvalPolyInMatList(ScalarProduct(QB, GetCol(invC,4)),
			[A1,A2]);

B1; B2; B3; B4;

B1 * V;
B2 * V;
B3 * V;
B4 * V;

------------------------------------------------------------
-- EXERCISE try with these matrices
A1 := mat([[1,0,0],
	   [0,1,0],
	   [-1,-1,-1]]);
A2 := mat([[0,1,0],
	   [1,0,0],
	   [0,0,1]]);
------------------------------------------------------------
-- UNIGENERATED FAMILIES

A1 := matrix([[0,0,0,0,0,0,0],
	      [0,0,0,0,0,-12,0],
	      [0,0,0,0,0,0,-12],	
	      [1,0,0,0,0,0,0],
	      [0,1,0,0,0,7,0],
	      [0,0,0,1,0,0,0],
	      [0,0,0,0,1,3,0]]);

A2 := matrix([[0,0,0,0,0,0,0],
	      [1,0,0,0,0,0,0],
	      [0,1,0,0,0,0,0],	
	      [0,0,0,0,0,0,0],
	      [0,0,0,1,0,0,0],
	      [0,0,0,0,0,0,0],
	      [0,0,0,0,0,1,0]]);
A1*A2 = A2*A1;
-- F commuting family generated by A1, A2

use QQz;
MinPoly(A1, z);  CharPoly(A1, z);  --> commendable
MinPoly(A2, z);  CharPoly(A2, z);  --> non commendable

-- Then now we know that F is unigenerated (by A1)
--   in particular A2 is polynomial in A1:
--   how do we find this polynomial?

use P ::= QQ[x,y], lex;  --> lex is the key!
Rel := BMForMat(P, [A2,A1]);  -- the generator last
indent(Rel);

f := x - Rel.GB[2];  f;
TutEvalPolyInMatList(f, [A2,A1])  =  A2;
------------------------------------------------------------
