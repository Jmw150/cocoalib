------------------------------------------------------------
-- TUTORIAL 3
------------------------------------------------------------
-- ZERO DIMENSIONAL AFFINE ALGEBRAS
------------------------------------------------------------

------------------------------------------------------------
-- MULTIPLICATION ENDOMORPHISMS
------------------------------------------------------------

use P ::= QQ[x,y,z];  -- "::=" for the special meaning of [..]
I := ideal(x*y-z, x^2-3, y^2-1);
R := P/I;
IsZeroDim(I); --> true
QB := QuotientBasis(I);   QB; --> [1, z, y, x] in P

use R; -- interpret the symbols x,y,z in R, the quotient ring
f := x +y -z^2; -- in R
-- multiplication by f:
1 * f; -- "(..)" reminds this is the class of ".."
z * f;
y * f;
x * f;

-- it is easier to think in terms of polynomials:
use P; -- interpret the symbols x,y,z in P, the base ring
f := x +y -z^2; -- in P
NF(1 * f, I);
NF(z * f, I);
NF(y * f, I);
NF(x * f, I);

-- get the coefficients of the linear combinations
QB;
coefficients(NF(x * f, I), QB);
-- putting everything together:
-- matrix of the MULTIPLICATION ENDOMORPHISM by f on R
MultiplicationMat(f, I);

-- MULTIPLICATION FAMILY of R: generated by
S := [ MultiplicationMat(X,I) | X in indets(P) ];
indent(S);
-- indeed S are commuting endomorphisms:
for i := 1 to NumIndets(P) do
  for j := i+1 to NumIndets(P) do
    print i, j, ": ", S[i]*S[j] = S[j]*S[i], "  ";
  endfor;
endfor;

------------------------------------------------------------
-- CHINESE REMAINDER THEOREM
------------------------------------------------------------
-- Q1, Q2, Q3 comaximal ideals:
--   P/(Q1 ∩ Q2 ∩ Q3) ≅ P/Q1 x P/Q2 x P/Q3

Q1 := ideal(x-z+3, y-5*z+1, (z-1)^2);
Q2 := ideal(z^2+3*z, y-2*z-1, z^2+11);
Q3 := ideal(x^2-2, y-1, z^2+10);

-- are they comaximal?
1 IsIn Q1+Q2;
1 IsIn Q1+Q3;
1 IsIn Q2+Q3;

------------------
Q := [Q1, Q2, Q3];
E := NewList(3);
------------------------------
J := product(WithoutNth(Q,1));
repr1 := GenRepr(one(P), Q[1] + J); -- 1 = q+j
-- NOTE: GenRepr is a costly function

E[1] := ScalarProduct(gens(J), last(repr1, NumGens(J))); -- j = 1-q
E[1];
E[1] - 1 IsIn Q[1];  -- E1 = 1 mod Q[1]
E[1] IsIn Q[2];      -- E1 = 0 mod Q[2]
E[1] IsIn Q[3];      -- E1 = 0 mod Q[3]

------------------------------
J := product(WithoutNth(Q,2));
repr1 := GenRepr(one(P), Q[2] + J);
E[2] := ScalarProduct(gens(J), last(repr1, NumGens(J)));
E[2];

------------------------------
J := product(WithoutNth(Q,3));
repr1 := GenRepr(one(P), Q[3] + J);
E[3] := ScalarProduct(gens(J), last(repr1, NumGens(J)));
E[3];

indent(E);
sum(E);
NF(sum(E), IntersectList(Q));

-- EXERCISE:  Try with other 0-dimensional ideals
-- EXERCISE:  Write function ChineseRemainderTut

------------------------------------------------------------
-- THE HEURISTIC ALGORITHM for the PRIMARY DECOMPOSITION
------------------------------------------------------------

use P;
J1 := ideal(x^2-2, (y-2)^3, z-3);
J2 := ideal(x-1, y^3-3, (z-5)^2);
I := intersect(J1, J2);
I;

L := 1234*x - 9876*y + 555*z;
mi_L := MinPoly(MultiplicationMat(L,I), z);   mi_L;
-- it may be computed with other strategies (ask Elisa Palezzato ;-)
MinPolyQuotDef(L, I, z);
MinPolyQuotElim(L, I, z);

Facs := factor(mi_L);
p := Facs.factors;  m := Facs.multiplicities;
p; m;

-- many ways to evaluate p in L:
-- (1) let CoCoA work it out for you:
subst(p[1], z, L);
-- (2) function "eval"  (remember that z is the 3rd indet)
eval(p[1],[0,0,L]);
-- (3) define the evaluation homomorphism (works across rings)
phi := PolyAlgebraHom(P, P, [0,0,L]); -- domain, codomain, images
phi(p[1]);

Q1 := I + ideal(phi(p[1])^m[1]);
IsPrimary(Q1); -- we will see how to do it in Tutorial4
--> true!

Q2 := I + ideal(phi(p[2])^m[2]);
IsPrimary(Q2); 
--> true!

-- then [Q1, Q2]  is the primary decomposition of I 
Q1; Q2;  ---> hmmmmm....
GBasis(Q1);
GBasis(Q2);

Q1 = J2;   Q2 = J1;

-- we could do:
Q := [ I + ideal(phi(p[i])^m[i]) | i in 1..len(p)];

-- EXERCISE:  Try with other 0-dimensional ideals
-- EXERCISE:  Compare timings of the single operations
-- EXERCISE:  Write function PartialDec for a partial decomposition
-- EXERCISE:  Write function PrimaryDecTut doing all the checks
-- EXERCISE:  Compare reliability and timings
----------------------------------------------------------------------
-- COMPUTING THE RADICAL

indent(I);
J := I;

EF := eigenfactors(MultiplicationMat(x,J), x);  -- same indet
EF;
g := product(EF);
g;
J := I + ideal(g);
deg(g);  multiplicity(P/J); --> different: another indet

EF := eigenfactors(MultiplicationMat(y,J), y);
EF;
g := product(EF);
g;
J := J + ideal(g);  -- now the ideal is "simpler"
deg(g);  multiplicity(P/J); --> different: another indet

EF := eigenfactors(MultiplicationMat(z,J), z);
EF;
g := product(EF);
g;
J := J + ideal(g);
deg(g);  multiplicity(P/J); --> different. But we are done!

-------------------------------
-- an experiment
indent(I);
J := I;

L := 123*x + 234*y + 456*z;
EF := eigenfactors(MultiplicationMat(L,J), x);
EF := subst(EF, x, L);  -- is in J
g := product(EF);
g;
J := I + ideal(g);
deg(g);  multiplicity(P/J); --> the same!
-- DONE!

-- EXERCISE: try with other 0-dimensional ideals.
-- EXERCISE: write a function RadicalTut which computes the radical.
----------------------------------------------------------------------
